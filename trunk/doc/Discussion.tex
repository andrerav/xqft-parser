\chapter{Discussion}
\underline{\textbf{\LARGE //TODO:}} tekst her... innledning


husk generelt: Gjorde vi riktige valg? Ble ting som forventet? Hva hadde skjedd om vi brukte annet alternativ etc..

\input{discussion/DesignDecisions}
\input{discussion/AdaptW3C}
\input{discussion/DeadEnds}




\section{ANTLR}
\underline{\textbf{\LARGE //TODO: Andreas}}

Rett valg?
Vi kjipa med CUP + JFlexxx, hva skjedde med \aa~skrive for h\aa nd?
Har ikke peiling p\aa~ CUP og JFlexxx, AST mye lettere med ANTLR? Mindre omskriving syntaktisk? Har de predikater der? Kunne vi l\o st statetingen p\aa~ en annen m\aa te med CUP og Flexz? 

\underline{\textbf{\LARGE //ODOT:}}




\section{Covrage Test Results}

\underline{\textbf{\LARGE //TODO: Mads}}
\begin{itemize}
\item Testresultater, bra/d\aa rlig
\item testresultater (hva var de forskjellige feilene)
\item Generelt resultater vi skrev om i forrige kapittel
\end{itemize}

Covrage er ikke h\o yere mest sannsynlig p\aa~grunn av vi har reserved keywords, og noen ganger ser parseren for langt frem... skal se om jeg f\aa~r fiksa noe av dette til helga, sp\o rs p\aa~ hvor lang vi har kommet med rapporten.... Covrage testene er eXtremt bra til \aa~finne bugz.

\underline{\textbf{\LARGE //ODOT:}}

\section{AST}
\underline{\textbf{\LARGE //TODO: Andreas}}

AST'en som blir produsert vs syntakstre

Generelle resultat, bra/d\aa rlig (AST) \#\# typesjekking (bedre \aa~gj\o re p\aa~AST'en) -> putt i egen section i discussion -------v
symtabs (bedre \aa~gj\o re p\aa~ AST'en))

Gjorde vi riktige valg? Ble ting som forventet? Hva hadde skjedd om vi brukte alternativ m\aa te? 

\underline{\textbf{\LARGE //ODOT:}}

\section{Error Handling}
\underline{\textbf{\LARGE //TODO: Andreas}}

Pass p\aa~ at du ikke skriver om at nextToken() er kjip for mange ganger... =)

Hardkodet catching av exceptions i nextToken() begrenset muligheten for aa
fange opp *alle* feil, men dette er mulig aa fikse (definere egne baseklasser)

Feilhaandteringen

Hvorfor skrudde vi av default error handling? Var dette bra? Hva var kjipt da? Kunne vi gjort det p\aa~ noen annen m\aa te?

du kan evt dra inn det du har fra future / improvements, jeg lyst til \aa~ slakte det kapittelet

\textbf{sakset fra future work: litt omskriving n\oe dvendig?}
\subsubsection{Lexer Error Handling}
\label{sect:future_work:lexer_error_handling}
As noted in sections \ref{sect:error_handling:syntax_errors} and
\ref{sec:impl:errorhandling}, the \verb!nextToken()! method in the lexer base class
would ``hijack'' lexical exceptions and handle them by printing an error message
to stderr and then attempting to recover from the error by simply consuming the
offending character and ignoring it in the following construction of tokens. It is 
not immediately appareant, but the \verb!nextToken()! method can not be overridden and
forced to throw the exception onwards, due to the method signature itself which
does not allow exceptions to be thrown. 

However, one possible solution to this problem could be to override the \verb!nextToken()! method and employ the observer design pattern to allow a simple and decoupled way of flagging an exception to the parser.



\underline{\textbf{\LARGE //ODOT:}}


\section{Scope andz Typecheckz}

\underline{\textbf{\LARGE //TODO: Andreas}} Saksa det her fra future work... kan det bli mer diskusjon i stedet? Evt ogs\aa~dele det opp i to sections...

\subsubsection{Type Checking}
Currently the parser will not perform type checking on the parsed queries. This
is an essential feature and will be necessary to implement for the parser to be
applicable in any realistic setting. A type checking system with proper type
inference and synthesis could be a complex feature to implement in a language
such as XQuery, and might require considerable effort, especially in quality
assurance. 

\subsubsection{Scoping and Symbol Tables on AST}
Currently the scoping and symbol tables are being used directly in the grammar -
that is, during parse time. It would be benefitial to move this into being
performed in run time, and combine with type checking functionality.

\underline{\textbf{\LARGE //ODOT:}}