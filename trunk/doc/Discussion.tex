\chapter{Discussion}
\label{chapter:discussion}

\textbf{\underline{\LARGE TODO:}} innledning

\begin{itemize}
  \item (1,2) + 3 kan oppdages som feil ved at man merker iteratorvariable, atomiske og sekvenser + at man synes
  det er flott for optimalisering av sequencebygging
  \item kan sette context node til noe n\aa r man starter\ldots Tenke en virtuell /collection/doc struktur\ldots
  ellerno
	\item Hva med \$i = (1,2,3) \$i/hatt -> typefeil? kj\o re isInScope(scope) p\aa~noe som ikke har scope kolonne?
	\item MarkXRemove funker bra i unordered m0de tror jeg\ldots. Den er ogs\a~normalisert ref purely relational
	flwors, som sier LL er denormalisert..
\end{itemize}

\section{Loop Lift vs ``insertNameHere''}
\label{sect:discussion:llvsmXr}
\begin{itemize}
  \item vise til ll eksemplet sect \ref{sect:translation:ll:example} og f\aa~frem at ll krever DAGz ganske hardt,
  mye som blir brukt om igjen. Og fra begynnelsen til slutten for den saks skyld.
  \item fordeler vs ulemper..
  \item dra frem at markXremove bruker f\ae rre operatorer
  \item men st\o tter ikke all verden -> fundamental feil? -> ordering iallefall, types ogs\aa~til en viss grad
  \item hva med en switch if(!all verden) -> markXremove else LoopL
  \item pathfinder way kommer ikke til \aa~dra nytte av den mer ekspressive mars-algebraen\ldots Men er ekspressiv
	  bedre? Synes jeg s\aa~ noe i en av pathfinder artiklene hvor de sa at jo mer restriktiv, jo bedre
	  \aa~optimisere\ldots snakke med thorbj\o rnsen om dette..
\end{itemize}

\section{Rewriting}
\label{sect:discussion:rewriting}
\begin{itemize}
  \item fordeler vs ulemper med \aa~skrive om til core
  \item man mister jo informasjon\ldots. Hvis den er p\aa~denne m\aa ten --> gj\o re det akkurat
	  slik, en sp\o rring som skal gi tilsvarende svar er ikke sikkert at man kan
	  skrive p\aa~den samme m\aa ten helt uten videre..  
  \item samme svar = samme utf\o relse = er dette en fordel?
  \item kan man utnytte kunnskap om translation til \aa~optimisere xquery queries?
  \item hva med \aa~bare skrive om det man trenger? Ala det vi gjorde med FLWORz?
\end{itemize}

\input{discussion/ManualTreeParser}
\input{discussion/NotSupported}


\section{Order}
\label{sect:discussion:order}
\begin{itemize}
  \item hva skjer om noe er sortert.. s\aa~blir det kryssa? M\aa~vi alltid gi ting ordernumber? Herregud s\aa~likt
  pathfinder i s\aa fall =/
  \item kanskje denne section og den om type kan sl\aa s sammen til noe om representering av data?
\end{itemize}

\section{Type System}
\label{sect:discussion:typeSystem}
\begin{itemize}
  \item Hvordan f\aa~til noe typesystem?
  \item lagre false som ``false'' enn s\aa~lenge.. kjipt med /a/b[/a/b/c] hvis c er slik: <c>false</c>
  \item Mars st\o tter ikke forskjellige typer innenfor samme felt
  \item En sekvens er en sekvens i XQuery\ldots ikke en sekvens av booleans
  eller noder etc
  \item Et ekstra felt som sier type?
  \item Hva skjer med /a/b/c/text() vs /a/b/c ?
  \item hva skjer om man lager en <a> hei <b> jeje </b> </a> variabel? Dette
  m\aa~kunne representeres.
  \item Hvis vi hadde hatt statisk og sterk typing s\aa~ hadde mye v\ae rt
  ordna, f.eks \verb!for $i as xs:int in (1,2,3) return /a[$i]! s\aa vet man
  med en gang at \verb![$i]! er en ``numeric predicate''.
\end{itemize}

\section{Optimisations}
\label{sect:discussion:optimisations}
\begin{itemize}
  \item legg merke til bruk av Uk-skrivem\aa te (s vs z)
  \item enkeltverdier i sammenligning b\o r bli putta inn i selecten.. ikke lag
  eget sett og kryss
  \item enkeltverdier etterhverandre b\o r lages i en go, ikke \texttt{union}es
  sammen
  \item step for step pathexpr er ikke effektivt\ldots SCHADE ulempe med rene uttrykk: /a/b/c = trengs ingen
  joins egentlig
  \item et step b\o r kanskje egentlig joines med konteksten sin f\o r predikatet sitt -> /a/b[c] ((a join a/b)
  join a/b/c) ikke (a join (a/b join /a/b/c)
  \item vi har ordna, uten \aa~vite om det at man kan selecte i stedet for \aa~projecte n\aa r man er i logisk
  kontekst.. yeah!
  \item flere relative pathexprs i predikater b\o r egentlig kunne mergeInJoines sammen f\o r de blir merginjoina
	med det som predikatet st\aa r til\ldots dette er kanskje en optimalisering\ldots
  \item 
\end{itemize}