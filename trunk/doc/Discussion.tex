\chapter{Discussion}
\label{chapter:discussion}

\textbf{\underline{\LARGE TODO:}} innledning

\begin{itemize}
  
  \item kan sette context node til noe n\aa r man starter\ldots Tenke en virtuell /collection/doc struktur\ldots
  ellerno
	\item Hva med \$i = (1,2,3) \$i/hatt -> typefeil? kj\o re isInScope(scope) p\aa~noe som ikke har scope kolonne?
	\item MarkXRemove funker bra i unordered m0de tror jeg\ldots. Den er ogs\a~normalisert ref purely relational
	flwors, som sier LL er denormalisert. (bare normalisert innenfor en flwor.. den unormaliserer seg n\aa r den g\aa
	r ut av l\o kka (cross /m const))
\end{itemize}

\section{SingelT0n vs sequence Ye = finn p\aa~overskrift etter innhold}
\label{sect:disc:singelton}
\begin{itemize}
   \item (1,2) + 3 kan oppdages som feil ved at man merker iteratorvariable, atomiske og sekvenser + 
   \item at man synes det er flott for optimalisering av sequencebygging 
   \item order by (1,2) kan ogs\aa~oppdages. 
\end{itemize}


\section{Effective Boolean Value / ATOMIZATION}
\begin{itemize}
\item VI M\AA~SJEKKE ATOMIZATION.
\item noe er feil
\end{itemize}

\section{Loop Lift vs Tainting Dependencies}
\label{sect:disc:llvsmXr}
\begin{itemize}
  \item vise til ll eksemplet sect \ref{sect:trans:ll:example} og f\aa~frem at ll krever DAGz ganske hardt,
  mye som blir brukt om igjen. Og fra begynnelsen til slutten for den saks skyld.
  \item fordeler vs ulemper..
  \item dra frem at TD bruker f\ae rre operatorer
  \item pathfinder way kommer ikke til \aa~dra nytte av den mer ekspressive mars-algebraen\ldots Men er ekspressiv
	  bedre? Synes jeg s\aa~ noe i en av pathfinder artiklene hvor de sa at jo mer restriktiv, jo bedre
	  \aa~optimisere\ldots snakke med thorbj\o rnsen om dette..
\end{itemize}

\section{Rewriting}
\label{sect:disc:rewriting}
\begin{itemize}
  \item fordeler vs ulemper med \aa~skrive om til core
  \item man mister jo informasjon\ldots. Hvis den er p\aa~denne m\aa ten --> gj\o re det akkurat
	  slik, en sp\o rring som skal gi tilsvarende svar er ikke sikkert at man kan
	  skrive p\aa~den samme m\aa ten helt uten videre..  
  \item samme svar = samme utf\o relse = er dette en fordel?
  \item kan man utnytte kunnskap om translation til \aa~optimisere xquery queries?
  \item hva med \aa~bare skrive om det man trenger? Hva trenger man \aa~skriveom?
  \item sl\aa~sammen scopes blir frem og tilbake og frem igjen om man tenker core\ldots /a/b/c-> for..for..for ->
  /a/b/c
  \item se om det er mer tungvinne ting Core har\ldots har ikke satt meg helt inn i alle detaljene der.. hva skjer
  med predikater? blir de if.then.else? kan det hende at vi f\aa r un\o dvendige kryssprodukt?
  \item sluppet where-regel hvis man skriver om til if-then-else (dagens where er mer effektiv enn en if() then no
 e else tomt -> den VET at det som er usant blir kasta bort- jfr regel og select-operator)
\end{itemize}

\input{discussion/ManualTreeParser}
\input{discussion/NotSupported}


\section{Context Sensitive Visitor}
\label{sect:disc:contextSens}
\begin{itemize}
  \item Order/unorder kan dra nytte av kontekstsensitive visitors
\end{itemize}


\section{Order By}
\label{sect:disc:orderby}
\begin{itemize}
  \item Kanskje flytte denne til unsupported\ldots ikke forandre label
  \item st\o tte alle de sorteringsspesifiseringene.. st\o tte sortering over flere exprz.
\end{itemize}

\section{Type System}
\label{sect:disc:typeSystem}
\begin{itemize}
  \item Hvordan f\aa~til noe typesystem?
  \item lagre false som ``false'' enn s\aa~lenge.. kjipt med /a/b[/a/b/c] hvis c er slik: <c>false</c>
  \item Mars st\o tter ikke forskjellige typer innenfor samme felt
  \item En sekvens er en sekvens i XQuery\ldots ikke en sekvens av booleans
  eller noder etc
  \item Et ekstra felt som sier type?
  \item Hva skjer med /a/b/c/text() vs /a/b/c ?
  \item hva skjer om man lager en <a> hei <b> jeje </b> </a> variabel? Dette
  m\aa~kunne representeres.
  \item Hvis vi hadde hatt statisk og sterk typing s\aa~ hadde mye v\ae rt
  ordna, f.eks \verb!for $i as xs:int in (1,2,3) return /a[$i]! s\aa vet man
  med en gang at \verb![$i]! er en ``numeric predicate''.
  \item typeswitch / instance of / cast / castable / treat as
  \item There is however also a need to represent explicitly stated XML-nodes, as well
	as differentiate between the number \texttt{1} and the string \texttt{"1"}.
	This, and other issues about representing XQuery types will be treated in
	section \ref{sect:disc:typeSystem}.  \item 
\end{itemize}

\section{XQuery Functions}
\label{sect:disc:functions}
\begin{itemize}
  \item hvordan ordne XQuery funksjoner?
  \item Tror det skal v\ae re lagt til rette for \aa~ha en \textsf{function(FUNCTIONNAME; operator(list?)} operator
  \item 
\end{itemize}

\section{Optimisations}
\label{sect:disc:optimisations}
\begin{itemize}
  \item legg merke til bruk av Uk-skrivem\aa te (s vs z)
  \item \textbf{\Large TODO:} dette blir flyttet inn i Tainting Dependencies kap\ldots Vet ikke om det blir igjen
  noe \aa~si her..
  \item enkeltverdier i sammenligning b\o r bli putta inn i selecten.. ikke lag
  eget sett og kryss
  \item enkeltverdier etterhverandre b\o r lages i en go, ikke \texttt{union}es
  sammen
  \item step for step pathexpr er ikke effektivt\ldots SCHADE ulempe med rene uttrykk: /a/b/c = trengs ingen
  joins egentlig
  \item et step b\o r kanskje egentlig joines med konteksten sin f\o r predikatet sitt -> /a/b[c] ((a join a/b)
  join a/b/c) ikke (a join (a/b join /a/b/c)
  \item vi har ordna, uten \aa~vite om det at man kan selecte i stedet for \aa~projecte n\aa r man er i logisk
  kontekst.. yeah!
  \item flere relative pathexprs i predikater b\o r egentlig kunne inJoines sammen f\o r de blir inJoina
	med det som predikatet st\aa r til\ldots dette er kanskje en optimalisering\ldots
  \item tainting er strengt tatt bare n\o dvendig om sekvensen skal brukes til noe\ldots 
\end{itemize}