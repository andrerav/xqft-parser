\section{Path Expressions and Predicates}
\label{sect:trans:TD:pathNpred}

XQuery implement XPath 2.0 path expressions and predicates as described in section
\ref{sect:theory:xquery:PathExpressions} and \ref{sect:theory:xquery:Predicates}. In this section we will present
a method for translating some of these expressions into MQL relational algebra.

For the translations in this section to be correct, we have a few assumptions. A scope defined as a parameter to
the \textsf{scope}-operator starting with a slash (\textsf{/}) is an absolute scope. That means if the parameter
is e.g. \textsf{/a/b}, the operator will remove any tuples in the input relation where the $scope$ attribute does
not define the tuple to stem from a \texttt{b} scope within the root-scope \texttt{a}. Without a slash first in
the parameter, the scope is relative. E.g. \texttt{a/b} as a parameter will lead to removal of all tuples where
the $scope$ attribute does not define the tuple to stem from a \texttt{b} scope within an \texttt{a} scope.

We also assume that the tuples returned from a scope lookup in the \textsf{valocc}-index will have information of
the scope it self in the $scope$ attribute, and the contents of the scope in an $value$ attribute. E.g. a lookup of
\textsf{\$c} (the \textsf{\$}-sign indicates it is a scope) in this index may return a tuple with
\textsf{a[1].b[2].c[1]} as its $scope$ value.

The tuples returned from a lookup in the value occurence index will have to be ordered according to document
order. This order will have to hold even after the result is run through a \textsf{scope}


\subsection{Path Expressions}
\label{sect:trans:TD:pathExprs}
A path expression consists of a series of one or more steps, separated by ``/'' or ``//'', and optionally beginning
with ``/'' or ``//''.  Each step is either a axis step or a filter expression, and a axis step consist of a axis
and a node test. This can be seen from the exerpt of the W3C XQuery specification in figure \ref{fig:trans:TD:pathEBNF}.
A node test can be either a kind test or a name test, we will focus on the latter. Filter expressions will not
explicitly be handled.

\begin{figure}[h]
\begin{Verbatim}
[68] PathExpr        ::= ("/" RelativePathExpr?)
                       | ("//" RelativePathExpr)
                       | RelativePathExpr
[69] RelativePathExpr::= StepExpr (("/" | "//") StepExpr)*
[70] StepExpr        ::= FilterExpr | AxisStep
[71] AxisStep        ::= (ReverseStep | ForwardStep) PredicateList
[72] ForwardStep     ::= (ForwardAxis NodeTest) | AbbrevForwardStep
[75] ReverseStep     ::= (ReverseAxis NodeTest) | AbbrevReverseStep
\end{Verbatim}
\label{fig:trans:TD:pathEBNF}
\caption{Path expressions as specified by W3C}
\end{figure}
The semantics of such expressions reading from left to right, the result of one step expression is used as input
for the next. Within one step expression, the result from the preceding step will first be used as input for the
axis expression. The result of this will be filtered by a name or kind test, before this again is filtered by
possible predicates.

The effect of a ``/'' at the beginning of a path expression is to begin the path at the root node of the tree that
contains the context node. A ``//'' at the beginning of a path expression will establish an initial node sequence
that contains the root of the tree in which the context node is found, plus all nodes descended from this root.
Together with a name test these expressions can be translated as follows:

\begin{equation}
\frac{}{\mbox{\texttt{/}}QName_{1}}\longmapsto
\begin{array}{l}
\mbox{\textsf{numberate(index,[] ,[] ;}} \\ \quad
\mbox{\textsf{index(valocc;}} \\ \quad \quad
\mbox{\textsf{scope(/}}QName_{1}\mbox{\textsf{;}} \\ \quad\quad\quad
\mbox{\textsf{lookup(\$}}QName_{1}\mbox{\textsf{))))}}
\end{array}
\label{rule:trans:TD:sglSlash}
\end{equation}

\begin{equation}
\frac{}{\mbox{\texttt{//}}QName_{1}}\longmapsto
\begin{array}{l}
\mbox{\textsf{numberate(index, [], [];}} \\ \quad
\mbox{\textsf{index(valocc;}} \\ \quad \quad
\mbox{\textsf{lookup(\$}}QName_1\mbox{\textsf{)))}}
\end{array}
\label{rule:trans:TD:dblSlash}
\end{equation}

Where $QName_1$ is any XML-qualified name, and the dependencies returned are $\vartheta = \emptyset$. To ensure
correct ordering, the order of the tuples returned from the \textsf{lookup} operator must be the same as the order
of the tuples recieved by the \textsf{numberate} operator. 

Step expressions can be abbreviated. If the axis name is omitted from an axis step, the default axis is
\texttt{child}. \texttt{decendant-or-self} can be replaced by using ``\texttt{//}'' istead of ``\texttt{/}''
between the steps. \texttt{@} is an abbreviation of \texttt{attribute::}. Here we will present translation of
unabbreviated syntax.

A general step expression, axis + name test, can be translated like this:
\begin{equation}
\begin{array}{c}
\frac{}{\displaystyle e_{1}\texttt{/AXIS::}QName_1} \\ 
\longmapsto \begin{array}{c}\mbox{\tiny } \\ \mbox{\tiny } \end{array} \\
\begin{array}{l}
\mbox{\textsf{project(docId, index, value, pos, scope, }}\vartheta\mbox{\textsf{;}} \\ \quad
\mbox{\textsf{numberate(index, [sprIdx, index], [}}\vartheta\mbox{\textsf{];}} \\ \quad\quad
\mbox{\textsf{select(isFUNC(scope, lsc);}} \\ \quad \quad\quad
\mbox{\textsf{hhjoin([docId],[docId],[spridx=l.index,lsc=l.scope,r.value,}}\vartheta\mbox{\textsf{];}}\\
\quad\quad\quad\quad \mbox{\textbf{r(}}e_1\mbox{\textbf{)}\textsf{;}} \\ \quad \quad\quad \mbox{\textsf{numberate(index, [], [];}}\\ \quad\quad\quad\quad\quad
\mbox{\textsf{index(valocc;}} \\ \quad\quad\quad\quad\quad\quad
\mbox{\textsf{lookup(\$}}QName_1\mbox{\textsf{)))))))}}
\end{array}
\end{array}
\label{rule:trans:TD:pathStep}
\end{equation}

Where $\vartheta = e.1.\vartheta$. \textsf{r.value} is short for \textsf{value = right.value, index = right.index,
\ldots etc}, and \textsf{docId} is short for \textsf{documentId}. \texttt{AXIS} will map to an MQL funciton
\textsf{isFUNK} as described in table \ref{tab:trans:TD:axisMap}.

\begin{table}[h]
\centering
\begin{tabular}{c|c}
\texttt{AXIS} & \textsf{isFUNC} \\ \hline
\texttt{child} & \textsf{isChild} \\
\texttt{descendant} & \textsf{isDescendant} \\
\texttt{attribute} & \textsf{isChild} $^{*}$ \\
\texttt{self} & \textsf{isSelf} \\
\texttt{descendant-or-self} & \textsf{isDescendantOrSelf} \\
\texttt{following} & \textsf{isFollowing} \\
\texttt{following-sibling} & \textsf{isFollowingSibling} \\
\texttt{parent} & \textsf{isParent} \\
\texttt{ancestor} & \textsf{isAncestor} \\
\texttt{ancestor-or-self} & \textsf{isAncestorOrSelf} \\
\texttt{preceding} & \textsf{isPreceding} \\
\texttt{preceding-sibling} & \textsf{isPrecedingSibling} 
\end{tabular}
\caption{Mapping between XQuery axes and MQL functions. \label{tab:trans:TD:axisMap}}
\end{table}

$^{*}$For the \texttt{attribute} axis the parameter to \textsf{lookup} will have a \textsf{\$@}-prefix
instead of the \textsf{\$}-prefix described in the rule.

\begin{myExample}
Consider the exerpt of a XML-document of figure \ref{fig:trans:TD:pathExXml}. The subscript numbers are used to
differentiate the different elements with same names, and are not a part of the names. Further, let a non-iterator
variable \texttt{\$a} be bound to a sequence of the \texttt{A} elements of the figure, but \emph{not} in document order.
An illustration of the relational representation of \texttt{\$a} is shown in figure
\ref{fig:trans:TD:pathEx:varA}. The $val$-attribute indicates which XML-element is represented and the
$scope$-attribute indicates the scope of this element.

\begin{figure}[h]
\centering
\begin{equation*}
\begin{array}{l}
\qquad \qquad \vdots \\
\mbox{\texttt{<A}}_{1}\mbox{\texttt{>}} \\ \quad
\mbox{\texttt{<B}}_{1}\mbox{\texttt{/>}}\mbox{\texttt{<B}}_{2}\mbox{\texttt{/>}} \\
\mbox{\texttt{</A}}_{1}\mbox{\texttt{>}} \\
\mbox{\texttt{<A}}_{2}\mbox{\texttt{>}} \\ 
\mbox{\texttt{</A}}_{2}\mbox{\texttt{>}} \\
\mbox{\texttt{<A}}_{3}\mbox{\texttt{>}} \\ \quad
\mbox{\texttt{<B}}_{3}\mbox{\texttt{/>}}\mbox{\texttt{<B}}_{4}\mbox{\texttt{/>}}\mbox{\texttt{<B}}_{5}\mbox{\texttt{/>}}
\\ \mbox{\texttt{</A}}_{3}\mbox{\texttt{>}} \\
\qquad \qquad \vdots
\end{array}
\end{equation*}
\caption[Exerpt of example XML-document.]{Exerpt of example XML-document. The subscript numbers indicate the
instance of the elements, and are not part of the QName \label{fig:trans:TD:pathExXml}}
\end{figure}

Figure \ref{fig:trans:TD:pathQu} shows an exerpt of a query referring to the variable \texttt{\$a}.
\begin{figure}[!h]
\centering
\texttt{\$a/child::B}
\caption{Example XQuery path expression \label{fig:trans:TD:pathQu}}
\end{figure} 

First, a lookup of \texttt{\$B} (where \texttt{\$} indicates to find a element, not a word) is done in the value
occurence index. The result of this is numerated by a \textsf{numberate}-operator, as illustrated in figure
\ref{fig:trans:TD:pathEx:luB}. The $index$-attribute ($idx$ in the figure) now holds the document-order of the
\texttt{B} elements. As there may be more \texttt{B} elements in the document, the $index$ attribute may not start
at the value 1 for the tuples relevant to the query.

\begin{figure}[h]
\centering
\subfigure[\textbf{r(}\texttt{\$a}\textbf{)}]{
\begin{tabular}{|c|c|c|}  \hline
$idx$ & $val$ & $scope$ \\ \hline
1 & \texttt{A}$_{2}$ & \textsf{\ldots{A}[2]} \\ \hline
2 & \texttt{A}$_{3}$ & \textsf{\ldots{A}[3]} \\ \hline 
3 & \texttt{A}$_{1}$ & \textsf{\ldots{A}[1]} \\ \hline
\end{tabular}
\label{fig:trans:TD:pathEx:varA}
}
\qquad
\subfigure[]{
\begin{tabular}{|c|c|c|}  \hline
$idx$ & $val$ & $scope$ \\ \hline
$\ldots$ & \texttt{\ldots} & \textsf{\ldots} \\ \hline
5 & \texttt{B}$_{1}$ & \textsf{\ldots{A}[1].B[1]} \\ \hline
6 & \texttt{B}$_{2}$ & \textsf{\ldots{A}[1].B[2]} \\ \hline
7 & \texttt{B}$_{3}$ & \textsf{\ldots{A}[3].B[1]} \\ \hline
8 & \texttt{B}$_{4}$ & \textsf{\ldots{A}[3].B[2]} \\ \hline
9 & \texttt{B}$_{5}$ & \textsf{\ldots{A}[3].B[3]} \\ \hline
$\ldots$ & \texttt{\ldots} & \textsf{\ldots} \\ \hline  
\end{tabular}
\label{fig:trans:TD:pathEx:luB}
}
\caption[Evaluating the expression of figure \ref{fig:trans:TD:pathQu}]{Illustration of results evaluating the
expression in figure \ref{fig:trans:TD:pathQu}. (a) The variable \texttt{\$a}. (b) Experpt of a lookup on the term
\textsf{\$B}, and the following numbering. Some attribute names are shortened. $val$ attribute indicates which
XML-element is represented in the tuple.
\label{fig:trans:TD:pathEx}}
\end{figure}

The result of the lookup will be joined with the \texttt{\$a} relation on their $documentId$-attribute. As we
assume only one XML-document this attribute is omitted from our example. A \textsf{select} operator is applied to
the result of the join to prune the relation. Only the tuples where the $scope$ attribute stemming from the lookup
defines a scope which is the child scope (as defined by the MQL function \textsf{isChild() in section
\ref{sect:method:marsAddedOperators}}) of the scope defined by the $scope$-attribute stemming from the
\texttt{\$a} relation (called $lsc$). After the selection the result will be as illustrated in figure
\ref{fig:trans:TD:pathEx:joinSel}.

\begin{figure}[h]
\subfigure[]{
\begin{tabular}{|c|c|c|c|c|} \hline
$sIdx$ & $idx$ & $val$ & $scope$ & $lsc$ \\ \hline
2 & 9 & \texttt{B}$_{5}$ & \textsf{\ldots{A}[3].B[3]} & \textsf{\ldots{A}[3]} \\ \hline
2 & 8 & \texttt{B}$_{4}$ & \textsf{\ldots{A}[3].B[2]}& \textsf{\ldots{A}[3]} \\ \hline
2 & 7 & \texttt{B}$_{3}$ & \textsf{\ldots{A}[3].B[1]}& \textsf{\ldots{A}[3]} \\ \hline 
3 & 5 & \texttt{B}$_{1}$ & \textsf{\ldots{A}[1].B[1]} & \textsf{\ldots{A}[1]} \\ \hline
3 & 6 & \texttt{B}$_{2}$ & \textsf{\ldots{A}[1].B[2]} & \textsf{\ldots{A}[1]} \\ \hline
\end{tabular}
\label{fig:trans:TD:pathEx:joinSel}
}
\qquad
\subfigure[]{
\begin{tabular}{|c|c|c|} \hline
$idx$ & $val$ & $scope$ \\ \hline
1 & \texttt{B}$_{3}$ & \textsf{\ldots{A}[3].B[1]}\\ \hline 
2 & \texttt{B}$_{4}$ & \textsf{\ldots{A}[3].B[2]}\\ \hline
3 & \texttt{B}$_{5}$ & \textsf{\ldots{A}[3].B[3]}\\ \hline
4 & \texttt{B}$_{1}$ & \textsf{\ldots{A}[1].B[1]}\\ \hline
5 & \texttt{B}$_{2}$ & \textsf{\ldots{A}[1].B[2]}\\ \hline
\end{tabular}
\label{fig:trans:TD:pathEx:done}
}
\caption[Further evaluation of the path expression]{Further evaluation of the path expression in figure
\ref{fig:trans:TD:pathQu}. (a) The result of the selection of the joining of \textbf{r(}\texttt{\$a}\textbf{)} and
the numerated result of the lookup of \textsf{\$B}. (b) Renumbering an projection on the relation of (a). Some
attribute names are shortened.}
\end{figure}

Finally, renumbering is employed, followed by a projection removing the last attributes stemming from the
\texttt{\$a} relation. The result of the expression is illustrated in figure \ref{fig:tans:TD:pathEx:done}.

\end{myExample}

\subsection{Predicates}
\label{sect:trans:TD:predicates}
\begin{itemize}
  \item isNumber() ifThenElse xqBoolean()
  \item contextnode p\aa~boks\ldots trengs dette alltid? Strengt tatt.. veldig vanskelig \aa~vite n\aa r man
  garantert ikke trenger den iallefall\ldots
\end{itemize}
