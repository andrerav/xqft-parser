\newpage
\section{Tainting Dependencies}
\label{sect:trans:taintingDependencies}

\begin{itemize}
  \item \textbf{\LARGE TODO:} det er en newpage p\aa~denne siden
  \item INTRO for teh wind
  \item har vokst ut av MarkXRemove
  \item Tainting dependencies (TD)
  \item og mer text
\end{itemize}

\subsection{Inference Rule Language Explanation}
\label{sect:trans:TD:langExpl}
\underline{\textbf{\LARGE TODO:}} Skal jeg bruke greske bokstaver i stedet for tekstlig marsgreie n\aa r jeg
skriver regler?

During this chapter we will present some inference rules. In this section we will explain the various
typographical representations.

\begin{table}[h]
\begin{tabular}{l|l}

  $\longmapsto$  			& Translates into \\
  $\vartheta$ 				& A set of iteration variable references \\
  \textsf{sans serif} 		& MQL expressions \\
  \texttt{monospaced} 		& XQuery expressions \\
  $e,\ldots,e_{n}$			& Generic expressions \\
  $\chi,\ldots,\chi_{n}$	& Generic variable names \\
  $I_{\chi}$				& The iterator expression which declares $\chi$ \\
  \textbf{bold} 			& Operations done during the generation of the algebra \\
  \textbf{r(}$e$\textbf{)} 	& Returns the relational algebraic representation of $e$   \\
  \textbf{t(}\textbf{r(}$e$\textbf{)}\textbf{,}$\vartheta'$\textbf{)} & Returns \textbf{r(}$e$\textbf{)} tainted
  with the dependencies $\vartheta'$ \\
  $\Delta$ 					&  The default context \\ 
  $\Lambda$ 				& The logical/boolean context \\
  
\end{tabular}
\caption{Explanation of inference rule symbols}
\label{tab:trans:td:langExpl}
\end{table}

Inference rules are generally in this format:
\begin{equation*}
\frac{\mbox{\textbf{cxt}}\vdash cond}{e}\longmapsto \mbox{\textbf{r(}}e\mbox{\textbf{)}}
\end{equation*}

This should be read as: in the context of \textbf{cxt}, if condition $cond$ is satisfied, the XQuery expression
$e$ will be translated into \textbf{r(}$e$\textbf{)}.

The translator is in the logical context, $\Lambda$, if the AST node it is currently visiting is a successor of a
boolean operator or within the condition part of an \texttt{if..then..else} expression. In all other cases the
translator is in the default context, $\Delta$. If no context is mentioned in the inference rules the default
context is assumed.

\subsection{Basics}
\label{sect:trans:TD:basics}
The method assumes left-to-right traversal of the assymetric syntax tree. In most cases the traversal is
postorder, meaning a subtree can be evaluated independently from its ancestors -- the exception being the logical
context set by boolean operators. The relational algebra will thus be generated bottom-up. In addition to the
evaluated subtree, a node must be able to inform its parent node about its variable dependencies ($\vartheta$),
which we will discuss later.

One XQuery sequence is represented as one relation and one XQuery item is represented as one tuple. This is sound,
as all XQuery items are sequences, and all sequences are one-dimensional (section
\ref{sect:theory:xquery:basics}). As we mentioned in section \ref{sect:trans:MarkXRemove}, the MarkXRemove method
did actually not consider the ordering of items in sequences at all. In Tainting Dependencies, however, we have
introduced an attribute $index$ holding the intra sequence number of the item. Consider the XQuery sequence
\texttt{('a','b',}$\ldots$\texttt{,'z')}. With this attribute, the relational representation will be as follwing:

\begin{center}
\begin{tabular}{|c|c|} \hline
$index$ & $value$ \\\hline
1		& \texttt{'a'} \\\hline
2		& \texttt{'b'} \\\hline
$\ldots$& $\ldots$ \\\hline
$n$		& \texttt{'z'} \\\hline
\end{tabular}
\end{center}


As can be seen, the item value is stored in the $value$ attribute. For the course of this chapter we will, for the
sake of simplicity, treat $value$ as a polymorphic type attribute. This simplification has minimal consequences
for the method and the way XQuery expressions are translated. XQuery types and relational representation of such
will is handled in section \ref{sect:disc:typeSystem}. \marginpar{\textbf{\LARGE TODO:} noen andre steder?.}

Also for simplicity, the $documentId$, $pos$ and $scope$ attributes have been left out of the
fields specified in \textsf{project} operators. If the \textsf{project} operator is applied to the result of a
join or cartesian product, these fields will follow the $value$ attribute. That is, if $r.value$ is projected,
then so is $r.documentId$, etc\ldots if applicable.

Tainting Dependencies utilises a symbol table for storing of variables declared. The table has two functions:
\begin{itemize}
  \item \textbf{put(}$\chi$\textbf{, }\textbf{r(}$e$\textbf{))} -- will store the
  algebraic version of the expression bound to the variable \texttt{\$}$\chi$ with $\chi$ as the key.  
  \item \textbf{get(}$\chi$\textbf{)} -- will do a lookup in the table based on the name of the variable
  \texttt{\$}$\chi$ and return the algebraic version of the expression linked to it.
\end{itemize}
The symbol table handles scoping according to XQuery semantics (section \ref{sect:theory:xquery:Flwor}), meaning
the translator will always be able to find the right declared variable based on which node in the AST the
translator is visiting.

\subsection{Iterator Variable Dependency}
\label{sect:trans:TD:dependency}

The concept of iterator variable dependency form the basis of the Tainting Dependency method. Such dependency is
defined as follows:

\noindent
\begin{myDefinition}
An XQuery expression $e_{1}$ is \textbf{dependant} on an \textbf{iterator variable} \texttt{\$}$\chi$, if in the
corresponding abstract syntax tree there exists a upwards path from a reference to \texttt{\$}$\chi$ to $I_{\chi}$
via $e_{1}$.
\label{def:iterVarDep}
\end{myDefinition}

Consider the example subexpression of figure \ref{fig:trans:td:varDep}, where \texttt{\$x} and \texttt{\$y} both
are iterator variables. Here, the expresion $e_{1}$ is dependent on both variables, but expression $e_{2}$ is only
dependent on the variable \texttt{\$x}.

\begin{figure}[h]
\centering
\tikzstyle{astNode}=[circle, draw=blue!70,fill=blue!20,solid,thick, minimum
size=26pt]
\begin{tikzpicture}[grow via three points={one child at (0,-1.5) and two
children at (-1.5,-1.0) and (1.5,-1.0)}]
\draw[loosely dotted, thick] (0,0) -- (0,-1);
\node at (0,-1) [astNode, label=above left:$e_{1}$ ] {\texttt{and}} 
child{node [astNode, label=above left:$e_{2}$] {\texttt{+}}
	child{node [astNode] {\texttt{\$x}}}
	child{node [astNode] {\texttt{3}}}
 }
child{node [astNode] {\texttt{\$y}}}
 ;
\end{tikzpicture}
\label{fig:trans:td:varDep}
\caption[Iterator variable dependency]{Iterator variable dependency}
\end{figure}

The iterator variable dependencies of an expression $e$ are part of the set $e.\vartheta$. As mentioned earlier,
an AST node must be able to inform its parent about the node's dependencies as well as the algebra generated. This
can be done by for an expression $e$ letting $e.\vartheta$ piggyback the \textbf{r(}$e$\textbf{)} returned.
\marginpar{\textbf{\Large TODO} klarer ikke skrive setninger\ldots}. The variable dependencies for an expression
$e$ with the subexpressions $e_{1},\ldots,e_{n}$ can be described as following:
\begin{equation*}
e.\vartheta = e_{1}.\vartheta\cup\ldots\cup e_{n}.\vartheta
\end{equation*}

The dependancy on the variable \texttt{\$}$\chi$ manifest itself relationally by the attribute $\chi$$numb$. The
value of $\chi$$numb$ is the iteration number of $I_{\chi}$, that is, for a tuple ($\chi$$numb$, $value$) the value
$value$ will appear in the $\chi$$numb$th iteration of $I_{\chi}$.

When an iterator variable \texttt{\$}$\chi$ is declared it is assigned a $\chi$$numb$ by renaming the $index$
field of corresponding iterator sequence $\chi$$numb$. Which leads us to the inference rule for translating the
(optional) \texttt{for} clause of a FLWOR expression:
\begin{equation}
\frac{}{\mbox{\texttt{for \$}}\chi \mbox{\texttt{ in }} e \mbox{\texttt{\ldots}}}\longmapsto
\begin{array}{l}
\mbox{\textbf{put(}}\chi\mbox{\textbf{, }} \\ \quad
\mbox{\textsf{project(}}\chi\mbox{\textsf{numb = index, value;}} \\ \quad \quad
\mbox{\textbf{r(}}e\mbox{\textbf{)}\textsf{)}\textbf{)}}
\end{array}
\label{rule:trans:td:forclause}
\end{equation}
Where the dependancies piggybacking the \textsf{project} operator can be expressed as:
$\vartheta = e.\vartheta \cup \chi$.

From definition \ref{def:iterVarDep} it can be seen that $\chi$ is not part of the set of dependancies the iterator
$I_{\chi}$ returns its parent. This is in fact the only case a variable is removed from a dependency set.
Because of this, we must be careful not to incidentally remove a $\chi$$numb$ attribute from a relation by means
of a \textsf{project} operator. When we in this chapter write $\vartheta$ enclosed in MQL syntax it is to be
interpreted as a comma seperated list of all the attributes linked to the dependencies in the set $\vartheta$.

\subsection{Dependencies Tainting}
\label{sect:trans:TD:tainting}

The iterator body of an iterator with a iterator sequence with length $n$ will have to executed $n$ times. This
can be done by e.g. evaluating the cartesian product between the body or the sequence, as with the MarkXRemove
method. To avoid any denormalised intermediate results, an ideal solution would be to always calculate such
products after all other evaluations of the query is done. Consider the following simple example of the query $e$:

\begin{center}
\begin{tabular}{l}
\texttt{for \$a in (1, 2) return} \\ \qquad
\texttt{for \$b in (3, 4) return} \\ \qquad \qquad
\texttt{5 + 6}
\end{tabular}
\end{center}

For this query the result can be calculated like this:
\noindent
\begin{center}
\textbf{r(}$e$\textbf{)}$=$\textbf{r(}\texttt{(1, 2)}\textbf{)}$\times$\textbf{r(}\texttt{(3,
4)}\textbf{)}$\times$\textbf{r(}\texttt{5 + 6}\textbf{)}.
\end{center}
\noindent

But such a simple solution is not adequate if there is a reference to an iterator variable somewhere within the
iterator body. This was managed by MarkXRemove by implementing iterator variable dependencies, similar to the
concept discussed in section \ref{sect:trans:TD:dependency}, and replacing the cartesian product operator with
something like a natural join operator (section \ref{sect:trans:mxr:basics}).

\noindent
\begin{myDefinition}
An XQuery expression $e$ is \textbf{dependant} on an \textbf{iterator} $I_{\chi}$ if $e$ occurs within the iterator
body of $I_{\chi}$.
\label{def:iteratorDep}
\end{myDefinition}

MarkXRemove has shorcommings when it comes to evaluating expressions where a sequence building expression
containing a iterator variable reference is a subexpression. Tainting Dependencies mend for this by expanding the
notion of dependencies to include an expression's knowledge of a iterator dependency. Iterator dependencies are
handled exactly like the iterator variable dependencies described in section \ref{sect:trans:TD:dependency} with
the amendment of tainting. This holds as any expression $e$ dependant on the iterator variable \texttt{\$}$\chi$
\textit{must} be dependant on the iterator $I_{\chi}$.

Tainting is the concept of sharing the knowledge of which iterators an expression is i dependent on -- an
expression is tainted with the dependencies of another expression. Expressions explicitly taint other expressions
with their dependencies during sequence building. Consider the subexpression $e$:
\begin{center}
\begin{tabular}{l}
\quad \;\, $\vdots$  \\
\texttt{(}$e_{1}$\texttt{, }$e_{2}$\texttt{)}\\
\quad \;\, $\vdots$  
\end{tabular}
\end{center}
Where $e_{1}.\vartheta = \left\{\chi_{1}\right\}$ and $e_{2}.\vartheta = \emptyset$. Here $e_{2}$ will be tainted
by $e_{1}$'s dependency on $\chi_{1}$, but as $e_{2}$ have no dependencies, $e_{1}$ will not be tainted.. The
tainting process is carried out by calculating the cartesian product of $e_{2}$ and the $\chi$$numb$ column of
\texttt{\$}$\chi$ stored in the symbol table.

More generally, for an sequence building expression $e$, \texttt{(}$e_{1}$\texttt{, \ldots, }$e_{n}$\texttt{)},
tainting can be expressed like this: \marginpar{\underline{\textbf{\Large TODO:}} \scriptsize noe \aa~utsette
p\aa~bruken av $\Pi$ ?}
\begin{center}
\begin{equation}
\begin{array}{l}
e.\vartheta = e_{1}.\vartheta \cup \ldots \cup e_{n}.\vartheta = \left\{\chi_{1},\ldots\chi_{m}\right\} \\
i \in \left\{1,\ldots,n\right\} \\
\mbox{\textbf{t(r(}}e_{i}\mbox{\textbf{),}}e.\vartheta\mbox{\textbf{)}} = 
\mbox{\textbf{r(}}e_{i}\mbox{\textbf{)}} \times {\displaystyle \prod_{\chi_{j} \in e.\vartheta -
e_{i}.\vartheta}} \mbox{\textsf{project(}}\chi_{j}numb\mbox{\textsf{;
}\textbf{get(}}\chi_{j}\mbox{\textbf{)}\textsf{)}}
\end{array}
\label{eq:trans:TD:taint}
\end{equation}
\end{center}

In addition to be spread by iterator variable dependencies and tainting in sequence building, iterator dependencies
may be spread by forced tainting as we will see later. 

\subsection{Litterals}
\label{sect:trans:TD:litteral}

The XQuery Full Text specification\cite{w3c01} defines a number of literals as seen in figure
\ref{fig:trans:TD:litEBNF}. A \texttt{StringLiteral} is a text string enclosed in apostrophes or quotation marks,
and the numeric literals are similar to numeric types from other programming languages. 

\begin{figure}[h]
\begin{Verbatim}
[85] Literal        ::= NumericLiteral|StringLiteral
[86] NumericLiteral ::= IntegerLiteral|DecimalLiteral|DoubleLiteral
\end{Verbatim}
\caption[Literals in XQuery]{Definition of literals in XQuery Full Text}
\label{fig:trans:TD:litEBNF}
\end{figure}

To be able to include such expressions in evaluation of relational algebra, they need a relational representation.
As we in this chapter assume $value$ is a polymorphic type attribute, with the help of the \textsf{make} operator
this makes quite a simple translation:

\begin{equation}
\frac{e \in \left\{Literals\right\}}{e}\longmapsto
\mbox{\textsf{make(name:=["index","value"], [1, }}e\mbox{\textsf{])}}
\label{rule:trans:TD:literal}
\end{equation}

This is an general way to translate literals, but there exists quite a few simplifications. Most importantly when
constructing sequences entirely composed of literals, as we will discuss in section
\ref{sect:trans:TD:optimisations}.

\subsection{Sequence Construction}
\label{sect:trans:TD:seqBuild}

A sequence in XQuery can be built with the comma operator --\texttt{,}. But this operator is the XQuery operator
with the lowest precedence, therefore, in most cases a sequence construction expression will be enclosed in
paratheses. This is to solve parser ambiguities, which can be seen in the exerpt of the W3C XQuery Full Text EBNF
specification\cite{w3c01} in figure \ref{fig:trans:TD:seqEBNF}. An \texttt{ExprSingle} can solely consist of a
\texttt{ParenthesizedExpr} via a series of productions omitted from the figure. Also note a \texttt{ExprSingle}
can be a \texttt{FLWORExpr}.

\begin{figure}[h]
\begin{Verbatim}
[33] FLWORExpr         ::= (ForClause | LetClause)+ WhereClause? 
                               OrderByClause? "return" ExprSingle
[45] IfExpr            ::= "if" "(" Expr ")" "then" ExprSingle 
                               "else" ExprSingle
[31] Expr              ::= ExprSingle ("," ExprSingle)*
[89] ParenthesizedExpr ::= "(" Expr? ")"
\end{Verbatim}
\caption[Exerpt from W3C XQuery EBNF]{Exerpt from W3C XQuery EBNF showing sequence construction}
\label{fig:trans:TD:seqEBNF}
\end{figure}

As can be seen from the figure the for clause of a FLWOR expression, as many other expressions, accepts an
\texttt{ExprSingle}. If a sequence is to be constructed in the for clause, it will have to be parenthesised. 

With the concept of tainting and iterator dependencies explained, we are now ready to introduce the translation of
an XQuery sequence construction expression:

\begin{equation}
\frac{}{e_{1}\mbox{\texttt{, \ldots, }}e_{n}}\longmapsto
\begin{array}{l}
\mbox{\textsf{numberate(index, [sprIdx, index], [}}\vartheta\mbox{\textsf{];}} \\ \quad
\mbox{\textsf{union(}} \\ \quad \quad
\mbox{\textsf{project(sprIdx=1, index, value; }} \\ \quad \quad \quad
\mbox{\textbf{t(r(}}e_{1}\mbox{\textbf{), }}\vartheta\mbox{\textbf{)}\textsf{);}} \\ \quad \quad
\qquad\vdots\\ \quad \quad
\mbox{\textsf{project(sprIdx=}\textit{n}\textsf{, index, value; }} \\ \quad \quad \quad
\mbox{\textbf{t(r(}}e_{n}\mbox{\textbf{), }}\vartheta\mbox{\textbf{)}\textsf{)))}}
\end{array}
\label{rule:trans:TD:seqConstr}
\end{equation}
Where $\vartheta=e_{1}.\vartheta \cup \ldots \cup e_{n}.\vartheta$.

The basis of a sequence construction is the \textsf{union} operator -- as with MarkXRemove. But because we in
Tainted Dependencies have introduced the explicit ordering of items with the $index$ attribute, additional
operations have been added. Each item in the sequences returned from the subexpressions is equipped with a
temporary field $sprIdx$ (superindex) holding the relative position of each subexpression. Based on the
positioning defined by $sprIdx$ and $index$ the \textsf{numberate} operator can now renumberate the resulting
sequence.


\subsection{Simple FLWORs}
\label{sect:trans:TD:simpleFLWOR}
\begin{itemize}
  \item bare for e1 in e2 return e3
  \item where
  \item order (enkel) kan v\ae re spr\o
\end{itemize}

\subsection{Comparative and Arithmetic Expressions}
\label{sect:trans:TD:compArit}
\begin{itemize}
  \item value comparators (eq, ne, lt\ldots)
  \item general comparators (>, <, = \ldots)
  \item arithmetic operators (+, -, \%,\ldots)
  \item idiv mod div
  \item unary expr -/+
\end{itemize}

\subsection{Logical Operator Expressions}
\label{sect:trans:TD:logical}
\begin{itemize}
  \item and
  \item or
\end{itemize}

\subsection{Path Expressions}
\label{sect:trans:TD:pathExprs}
\begin{itemize}
  \item axes
  \item samling av child axes /a/b/c/d -> ikke e1/e2
  \item i logical context -> outer join
\end{itemize}

\subsection{Predicates}
\label{sect:trans:TD:predicates}
\begin{itemize}
  \item isNumber() ifThenElse xqBoolean()
  \item contextnode p\aa~boks\ldots trengs dette alltid? Strengt tatt.. veldig vanskelig \aa~vite n\aa r man
  garantert ikke trenger den iallefall\ldots
\end{itemize}

\subsection{Conditional Expressions}
\label{sect:trans:TD:ifThenElse}
\begin{itemize}
  \item if(e1) then else
  \item e1 er i logical context..
\end{itemize}

\subsection{Full Text Expressions}
\label{sect:trans:TD:fulltext}
\begin{itemize}
  \item lookup.. passe p\aa~ contextnode
\end{itemize}

\subsection{other Th1ngz:}
\begin{itemize}
  \item node comparisons\ldots\ldots tviler p\aa~at vi f\aa r til dette glatt\ldots
  \item constructors\ldots element, CDATA, attribute etc etc
\end{itemize}


\subsection{Optimisations}
\label{sect:trans:TD:optimisations}
\begin{itemize}
  \item sekvenser:
	  \begin{itemize}
	    \item suprIndx kan doppes n\aa r bare singelton
	    \item singeltons trenger ikke index
      \end{itemize} 
  \item Litterals: 
		\begin{itemize}
          \item implies that any sequence of
				explicitly stated items will first have to be made as one-tuple relations and
				then spliced together. As the \textsf{make} operator supports multiple items, a
					better solution would be to collect all items in one MQL operator. Further, if
					the item is part of a singleton sequence, there is no need for a representation
					in form of an relation, as the item could be made part of the parameters of an
					operator (e.g. $\alpha$ \texttt{> 1} $\Longrightarrow$
					\textsf{select(gt(value, 1) $\alpha$)}).   
        \end{itemize}
  \item FLWOR:
  	\begin{itemize}
        \item  kan bli -> project , ved singelton return
      \end{itemize}         
\end{itemize}