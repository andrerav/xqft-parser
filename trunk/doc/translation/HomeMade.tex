\section{MarkXremove}
\label{sect:translation:markXremove}

One of the greatest challenges in transforming XQuery to relational algebra
lies in preserving the semantics of the iterative FLWOR construct. One
course of action for solving this is a method we have called ``MarkXremove'' --
pronounced ``mark, cross and remove''. The basis of the method is that the
result from the \textsf{return} clause will always be crossed (cartesian product
see \ref{sect:theory:crossProduct}) with the sequence bound in the
corresponding \textsf{for} clause. Any referal in the \textsf{return} clause to a
variable bound in a \textsf{for} clause will have to be marked with a number
corresponding to the iteration number the instance of the variable exists in.
After the cross product is calculated, rows not conforming to predicates
calculated in the \textsf{return} clause will be removed. One of these is that
the variable instance will have to correspond to the interation number.

In the following sections we will present the MarkXremove method for
translating various aspects of XQuery to relational algebra.

\subsection{Basics}
The algebra will be generated by traversing the abstract syntax tree bottom-up, left-to-right. After visiting a
node the algebra for this node and its children as well as a set, $\vartheta$, of the names of the iterator
variables reffered to in the tree, will be returned to the nodes parent. When $\vartheta$ is refered to in an MQL,
it represents a comma separated list of the names of the fields holding the iteration number for the iterator
variables. A tuple dependancy on a iterator variable \textsf{X} will correspond to a field \texttt{Xnumb}. This
will be further explained in section \ref{sect:translation:variables}.

It is assumed that a symbol table exists which handles scoping. The functions
\textbf{put(}\textsf{X}, $\alpha$\textbf{)} and \textbf{get(}\textsf{X}\textbf{)}
will respectively store and fetch algebra trees based on a key \verb!X!. When
moving out of a scope, the symbol table will remove all entries linked to this scope.

The translator is in the logical context, $\Lambda$, if its current node is a
successor of a boolean operator or within the $\alpha$ part of an
\textsf{if($\alpha$) then $\beta$ else $\gamma$} expression. In all other cases
the translator is in the default context, $\Delta$. If no context is mentioned
in the inference rules the default context is assumed.

For simplicity all data fields (e.g \texttt{dokumentId, scope}) will be
referred to as \verb!fields!, if one field is not explicitly needed.

\subsection{Literals and Numbers}
\label{sect:translation:litAndNumbers}
To be able to use litterals and numbers in the algebra processing, they need a
relational representation. A simple way to do this is hold the value in a
created relation with a single field, ``value'' (rule
\ref{eq:translation:literalsAndNumbers} ).

\begin{equation}
\centering
\frac{\alpha \in \left\{ Literals, Numbers \right\} }{\alpha}
\Longrightarrow
\texttt{make(name := "value",} \alpha \texttt{)}
\label{eq:translation:literalsAndNumbers}
\end{equation}

There is however also a need to represent explicitly stated XML-nodes, as well
as differentiate between the number \textsf{1} and the string \textsf{"1"}.
This, and other issues about representing XQuery types will be treated in
section \ref{sect:discussion:typeSystem}.

Rule \ref{eq:translation:literalsAndNumbers} implies that any sequence of
explicitly stated items will first have to be made as one-tuple relations and
then spliced together. As the \texttt{make} operator supports multiple items, a
better solution would be to collect all items in one MQL operator. Further, if
the item is part of a singleton sequence, there is no need for a representation
in form of an relation, as the item could be made part of the parameters of an
operator (e.g. $\alpha$ \textsf{> 1} $\Longrightarrow$
\texttt{select(gt(value, 1) $\alpha$)}). Both these issues will be discussed
further in section \ref{sect:discussion:optimisations}.



\subsection{Sequence Making}
\label{sect:translation:sequencing}
As XQuery sequences can only be one dimensional (section
\ref{sect:theory:xquery}), the creation of a sequence can be translated into a
splice of the relations corresponding to the items constituting the sequence.
This can be seen in rule \ref{eq:translation:sequencing}. 

\begin{equation}
\centering
\texttt{(} \alpha , \beta \texttt{)}
\Longrightarrow
\begin{array}{l}
\mbox{\texttt{union(}} 
\alpha \mbox{\texttt{,}} 
\beta \mbox{\texttt{)}}
\end{array}
\label{eq:translation:sequencing}
\end{equation}

\marginpar{\underline{\Large TODO} \footnotesize B\o r dette flyttes til
method:mars:assumedOperatorz i stedet? Det med NULL verdier i radene m\aa~
ogs\aa~skrives om.. blir mye om det her kanskje ja\ldots}
This method assumes that the \texttt{union} operator accepts relations with
different schemas, and does not remove duplicates (but contrary to disjoint
union, there is no need to differansiate elements by their orgin set in the
resultset). The schema for the result relation can be described as:
\begin{equation*}
schema(\texttt{union(}\alpha, \beta\texttt{)}) = schema(\alpha) \cup
schema(\beta).
\end{equation*}
Where $\cup$ is the ordinary set theory operator. Provided this is a
unreasonable task to implement, it can be done manually by the translator with
the help of \texttt{project} operators.

As two fields with different types cannot be spliced together, we presume all
\texttt{value} fields are strings for the time being. This will be further
discussed in section \ref{sect:discussion:typeSystem}.

\subsection{Variables}
\label{sect:translation:variables}
When a variable is declared, be it in the form of a \textsf{for} clause, \textsf{let} clause or a \textsf{declare
variable} expression, the right side of such an expression is transformed into algebra. The tree and its
$\vartheta$ is then stored in the symbol table by means of the previously mentioned \textbf{put(}\textsf{X},
$\alpha$\textbf{)}. The translator will have to in some way recognise which variables are iterator variables, e.g.
by means of a flag. Rule \ref{eq:translation:variableNotIterator} shows the translation of the reference of a
variable that is not an iterator.

\begin{equation}
\centering
\frac{\displaystyle \textsf{X} \notin \vartheta}{\displaystyle \textsf{\$X}}
\Longrightarrow
\begin{array}{l}
	\mbox{\textbf{get(}\textsf{X}\textbf{)}}
\end{array}
\label{eq:translation:variableNotIterator}
\end{equation}

When entering a predicate of a path expression, the algebra corresponding to the steps up to the predicate will be
stored in the symbol table as the iterator variable \textsf{``.''} (the context item). The context node may
implicitly be used with a relative path expression within the predicate. Rule
\ref{eq:translation:iteratorVariable} shows the translation of using a iterator variable. The same principles is
behind the inference rule for using the context node within a predicate.

\begin{equation}
\centering
\frac{\displaystyle \textsf{X} \in \left\{ Iterators \right\}}
	{\displaystyle \textsf{\$X}}
\Longrightarrow
\begin{array}{l}
	\mbox{\texttt{project([Xnumb=counter(),fields,}} \vartheta
	\mbox{\texttt{];}}
	\\ \quad
	\mbox{\textbf{get(}\textsf{X}\textbf{)} \texttt{)}}
\end{array}
\label{eq:translation:iteratorVariable}
\end{equation}

Where $\vartheta = \vartheta + $ \textsf{X}.
Rule \ref{eq:translation:iteratorVariable} also shows the introduction of a -\texttt{numb} field. This field
contains information about which iteration the instance of the variable in that row belongs to. All tuples with a
not \texttt{NULL} value in a -\texttt{numb} will be dependant on which iteration the loop linked to that variable
is in.


\subsection{Path Expressions}
\label{sect:translation:smpPathExpr}
XQuery implements XPath 2.0 path expressions as described in section
\ref{sect:theory:xqueryPathExpressions}. The \texttt{scope} operator of
MQL(section \ref{sect:method:marsOperators}) makes it possible to
filter results based on the scope. The operator does however only support paths
equivalent to path expressions with only \textsf{child} axis steps. Methods to
translate expressions with other types of axis steps will be discussed in
section \ref{sect:discussion:notAxis}.

Figure \ref{fig:translation:pathAST} shows the abstract syntax tree for the
generic child axis and name test only path expression \textsf{/a/\ldots/y/z}. It
should be noted that for the sake of simplicitly the AST node \textbf{AST\_STEPEXPR} is
omitted from the representation. The corresponding translation into MQL of such
expressions can be seen in rule \ref{eq:translation:pathExpr}.


\begin{figure}[h]
\centering
\tikzstyle{astNode}=[circle, draw=blue!70,fill=blue!20,solid,thick, minimum
size=26pt]
\begin{tikzpicture}[grow via three points={one child at (0,-1.5) and two
children at (-1.5,-1.0) and (1.5,-1.0)}]

\node at (0,0) [ellipse,
draw=blue!70,fill=blue!20]{AST\_PATHEXPR\_SGL} 
child{node [astNode] {/}
	child{node [astNode] {/}
		child{node [astNode] {/} 
			child{node [astNode] {a} edge from parent [draw, solid, thin]}
			child{node [astNode] {\ldots} edge from parent [draw, solid, thin]}
			edge from parent [draw,dotted, thick] 
			}
		child{node [astNode] {y}}
		}
	child{node [astNode] {z}}
	};
\end{tikzpicture}
\label{fig:translation:pathAST}
\caption[AST of path expression]{A simplified version of the abstract syntax
tree of a simple path expression}
\end{figure}


\begin{equation}
\centering
\textsf{/a/\ldots/y/z}
\Longrightarrow
\begin{array}{l}
	\mbox{\texttt{scope(/a/\ldots/y;}} \\
	\quad \mbox{\texttt{index(valloc; lookup(\$z))}}
\end{array}
\label{eq:translation:pathExpr}
\end{equation}

Rule \ref{eq:translation:singleStep} shows how a single child axis step can be
translated.

\begin{equation}
\centering
\alpha \texttt{/} \beta
\Longrightarrow
\begin{array}{l}
	\mbox{\texttt{project([r.fields,}} \vartheta \mbox{\texttt{];}} \\ \quad
 	\mbox{\texttt{select(isInScope(r.scope, l.scope);}} \\ \quad \quad
 	\mbox{\texttt{join([documentId], [documentId]; }} 
 	\alpha;\, \beta \mbox{\texttt{)))}}; \\
\end{array}
\label{eq:translation:singleStep}
\end{equation}

Where $\vartheta = \alpha.\vartheta \cup \beta.\vartheta$. If $\alpha.\vartheta \cap \beta.\vartheta \neq
\emptyset$, the algebra will have to be augmented with a \texttt{select} operator removing tuples where the common
variables iteration number is not equal. The synchronisation of iteration numbers may be done either before or
after or in combination with the existing \textsf{select} operator in the rule. This is a general rule, and is
applied whenever two expressions are joined or crossed together.

\subsection{Predicates}
As described in section \ref{sect:theory:xqueryPredicates}, predicates are used to restrict the items returned
from the expression it is assigned to. The predicate expression returns either true/false or an integer value. Rule
\ref{eq:translation:predicate} shows how predicates, which neither implisitly nor explicitly makes use of the
context item, are translated into MQL. 

\marginpar{\underline{\Large TODO} \footnotesize litt feil bruk av $\vdash$
her.. kan det tillates?}
\begin{equation}
\centering
\begin{array}{c}
	\frac{\displaystyle \textbf{put(ctx,}\alpha\textbf{)}\vdash\textbf{ctx}\notin\beta.\vartheta}
	{\displaystyle \alpha\textsf{[}\beta\textsf{]}}

	\Longrightarrow 
	\\
	\mbox{}
	\\
	\begin{array}{l}
		\mbox{\texttt{project([fields = l.fields,}} \vartheta \mbox{\texttt{];}} 
		\\ \quad \mbox{\texttt{select(ifThenElse(isNumber(r.value),}} \\ \quad 
		\qquad\qquad \mbox{\texttt{scopeIndex(scope,r.value),xqBool(r.value));}} \\ \quad\quad
		\mbox{\texttt{cross(}} 
		\alpha \texttt{;}
		\beta \mbox{\texttt{)))}}
	\end{array}
\end{array}
\label{eq:translation:predicate}
\end{equation}


\texttt{isNumber(r.value), scopeIndex(scope, r.value)} and \texttt{xqBool(r.value))} are explained in section
\ref{sect:method:marsAddedOperators}. The use of \texttt{scopeIndex(scope,pred)} may however not be valid in cases
where there are multiple predicates, or when the predicate is assigned to a path expression which utilises some
axes like e.g. \textsf{decendant-or-self}. This will be discussed in section \ref{sect:discussion:predicates}.
With the same limitations rule \ref{eq:translation:iterationPredicate} shows how a predicate which \emph{does}
reffer to the context node (implicitly or explicitly) is translated.

\begin{equation}
\centering
\begin{array}{c}
	\frac{\displaystyle \textbf{put(ctx,}\alpha\textbf{)}\vdash\textbf{ctx}\in\beta.\vartheta}
	{\displaystyle \alpha\textsf{[}\beta\textsf{]}}

	\Longrightarrow 
	\\
	\mbox{}
	\\
	\begin{array}{l}
		\mbox{\texttt{project([fields = l.fields,}} \vartheta \mbox{\texttt{];}} 
		\\ \quad \mbox{\texttt{select(ifThenElse(isNumber(r.value),}} \\ \quad 
		\qquad\qquad \mbox{\texttt{scopeIndex(scope,r.value),xqBool(r.value));}} \\ \quad\quad
		\mbox{\texttt{cross( join?}} \\ \quad\quad\quad
		\mbox{\texttt{project(counter())}}\alpha \texttt{;} \\ \quad\quad\quad
		\beta \mbox{\texttt{)))}}
	\end{array}
\end{array}
\label{eq:translation:iterationPredicate}
\end{equation}

Where $\vartheta = \alpha \cup (\beta -$\textbf{ctx}$)$. Because of the predicate exists in its own scope, any
refferal to the context node in $\alpha$ will not be distracted by adding a new context node in the symbol table
for the predicate. As with the single step expression (rule \ref{eq:translation:singleStep}), any common iterator
variable references will have to be synchronised.

\textbf{\underline{\Large TODO:}} Dette fuker ikke helt\ldots hva skjer om predikatet er et sett? YEYEYE samme
problem som med operatorer og ifz etc\ldots Det vi m\aa~finne ut er hvordan sekvenser skal representeres\ldots.
trenger vi order? JEEEEVLER\ldots\ldots\ldots\ldots\ldots\ldots\ldots  BAJZ


\subsection{FLWOR}
\label{sect:translation:iteration}
As described in \ref{sect:theory:flwor}, the XQuery FLWOR has an iteration semantics. For each item in the
sequence in the \textsf{for} clause (the iteration sequence), the item will be bound to a variable (the iteration
variable) and the expression in the \textsf{return} clause (the iteration body) will be executed.

To represent iteration over a sequence in relational algebra, the MarkXremove method calculates the cartesian
product between the iteration sequence and the result of the iteration body. As the iteration body is able to use
the iteration variable, a step have to be taken to ensure that the right item is used in the right iteration. This
is done by marking each item in the iteration sequence as well as each refferal to the iteration variable with a
number, and removing tuples where the iteration number for the variable does not match up with the iteration
number for the sequence. The translation of a simple \textsf{for \$X in} $\alpha$ \textsf{return} $\beta$ is shown
in rule \ref{eq:translation:simpleIteration}.

\begin{equation}
\centering
\begin{array}{c}
	\frac{\displaystyle \textbf{put(}\textsf{X}\textbf{,}\alpha\textbf{)}\vdash\textsf{X}\in\beta . \vartheta}
	{\displaystyle \textsf{for \$X in }\alpha	\textsf{ return }\beta}
	
	\Longrightarrow 
	\\
	\mbox{} \\
	
	\begin{array}{l}
	\mbox{\texttt{project(fields, }} \vartheta \mbox{\texttt{;}} \\ \quad
	\mbox{\texttt{select(ifThenElse(isNull(Xnumb),true,eq(numb,Xnumb))}} \\ \quad \quad 
	\mbox{\texttt{cross(}} \\ \quad \quad \quad
	\mbox{\texttt{project([numb=counter()];}} \\ \quad \quad \quad \quad
	\alpha \mbox{\texttt{)}} \\ \quad \quad \quad 
	\beta \mbox{\texttt{)))}}
	\end{array}
\end{array}
\label{eq:translation:simpleIteration}
\end{equation}

Where $\vartheta = (\alpha.\vartheta \cup \beta.\vartheta)\, -$ \textsf{X}. In the cases where $\beta$ does not
reffer to the iteration variable (in this case \textsf{X}), the \texttt{select} operator may be omitted.

In the \texttt{select} operator there is a check if the \texttt{-numb} field is \texttt{NULL}. This is becauce a
tuple where this is true is not dependant on which iteration number it is in, and will therefore never be needed
to be removed. \underline{\textbf{\Large TODO:}} jom, elsker slike to be to needed to setninger\ldots

Any variable bound in a \textsf{let} clause does not imply iteration. Consequently, the \textsf{let} clause can be
handled as a simple variable binding (section \ref{sect:translation:variables}). The $\vartheta$ will expose the
cases where a variable bound in a \textsf{let} clause is rebound to a new item each iteration.





The iteration expressions of XQuery comes in the form of FLWORs. But as
previously mentioned, we handle predicates which utilise the context item as an
iteration as well. It 


letclause -> statisk eller bruker iteration variable\ldots

for \$x in expr1 where expr2 return expr3  -->

scope.put(expr1)

project(~xnumb, ~number
    select(isNull(xnumb), true, eq(number, xnumb))             
    //only if \$x is  used in expr3 
    select(isNull(w.xnumb), true, eq(number, w.xnumb))         
    // only if \$x is used in expr2 
        cross(                     
    // alt fra venstre, varrefs venstre og høyre. (ikke velge value fra h\o yre(
            cross(                                             
          //  n\aa r den bare har value) gir enn\aa~ ordentlig kryss?
                project(number= count(), 
                    expr1)
                expr3
        select(xqueryBoolean(value),                                  
            expr2

\subsection{Comparison Operators}
\label{sect:translation:compOps}

\begin{itemize}
  \item husk at det finnes lambda
  \item project ikke select men hvis ikke lambda\ldots s\aa~select? funker det? Har vi finni en optimalisering?
  \item \ldots
  \item fordi noe over vil kanskje ha negativen\ldots f.eks ifthenelse og not()
  \item crazy
\end{itemize}
op $\in$ {< | > | = | <= | >= | != | and }        // and ->
and(xqueryBoolean(l.val), xqueryBoolean(r.val))

\subsection{If then else}
\label{sect:translation:ifThenElse}
if
now

then

else

\subsection{ALTSAMMEN}
\begin{itemize}
  \item hvorfor ikke putte alt vi klarer inne her
  \item er ikkeno poeng i \aa~skille mellom de vi tenkte skikkelig p\aa~ \aa~implementere og de vi tenkte litt
  p\aa\ldots
  \item S\aa fremt vi har en l\o sning putter vi den her\ldots kan heller diskutere senere hvorfor den er litt
  skrinn\ldots har gjort s\aa nn med ting frem til n\aa\ldots
\end{itemize}

\subsection{Examples}
\label{sect:translation:markxremoveExamples}
\begin{itemize}
\item steg for ste
\item litt stort eksempel m predikat sammenligning og for
\item kanskje en liten where
\end{itemize}
