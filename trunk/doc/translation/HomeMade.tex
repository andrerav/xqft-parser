\section{MarkXremove}
\label{sect:translation:markXremove}

One of the greatest challenges in transforming XQuery to relational algebra
lies in preserving the semantics of the iterative FLWOR construct. One
course of action for solving this is a method we have called ``MarkXremove'' --
pronounced ``mark, cross and remove''. The basics of the method is that the
result from the \textit{return} clause will always be crossed (cartesian product
see \ref{sect:theory:crossProduct}) with the sequence bound in the
corresponding \textit{for} clause. Any referal in the \textit{return} clause to a
variable bound in a \textit{for} clause will have to be marked with a number
corresponding to the iteration number the instance of the variable exists in.
After the cross product is calculated, rows not conforming to predicates
calculated in the \textit{return} clause will be removed. One of these is that
the variable instance will have to correspond to the interation number.

In the following sections we will present the MarkXremove method for
translating various aspects of XQuery to relational algebra.

\subsection{Basics}
The algebra will be generated by traversing the abstract syntax tree bottom-up,
left-to-right. After visiting a node the algebra for this node and its children
as well as a set, $\vartheta$, of references made to iteration variables.

It is assumed that a symbol table exists which handles scoping. The functions
\textbf{put(}\textit{X}, $\alpha$\textbf{)} and \textbf{get(}\textit{X}\textbf{)}
will respectively store and fetch algebra trees based on a key \verb!X!. When
moving out of a scope, the symbol table will remove all entries linked to this scope.
\textbf{isIterator(}\textit{X}\textbf{)} will represent a function returning
true if \textit{X} is a iteration variable, false otherwise.

The translator is in the logical context, $\Lambda$, if its current node is a
successor of a boolean operator or within the predicate part of an
\textit{if..then..else} expression. In all other cases the tranlator is in the
default context, $\Delta$. If no context is mentioned in the inference rules
the default context is assumed.

For simplicity all data fields (e.g \verb!dokumentId, scope!) will be refered
to as \verb!fields!, if one field is not explicitly needed.

\subsection{Variables}
When a variable is declared, be it in the form of a \textit{for} clause,
\textit{let} clause or a \textit{declare variable} expression, the right side
of such an expression is transformed into algebra and stored in the symbol
table together with its $\vartheta$. This is done by the previously mentioned
\textbf{put(}\textit{X}, $\alpha$\textbf{)}. Variables declared in a
\textit{for} clause will additionally be flagged as being an iterator variable.

When entering a predicate of a path expression, the algebra corresponding to
the steps up to the predicate will be stored in the symbol table as the
iterator variable \textit{.} (the context node). The context node may
implicitly be used with a relative path expression within the predicate. Figure
\ref{fig:translation:iteratorVariable} shows the translation of using a
iterator variable. The same principles is behind the inference rule for using
the context node within a path expression predicate.

\begin{figure}[h]
\centering
\begin{tabular}{ccc}

		\begin{tabular}{c}
		\textbf{isIterator()}\textit{X}\textbf{)} \\ \hline
		\textit{\$X} \\
		\end{tabular}
	&
		$\Longrightarrow$
	&
		\begin{tabular}{l}
	    	\verb!project([Xnumb = counter(), fields];! \\
	    	\verb!    !\textbf{get(}\textit{X}\textbf{)} \verb!)!
	    \end{tabular} 
	\\
	& 
	& 
		$\vartheta = \vartheta +$\textit{X}
\end{tabular}    
\caption{Refering to an iterator variable}
\label{fig:translation:iteratorVariable}
\end{figure}


----------------------------------------------------------------------------------
\label{sect:method:madslifting}
\begin{itemize}
\item merke bruk av variabler
\item for er alltid = kryss
\item vaske merker mot riktig iterasjon -> ergo er iterasjon virkelig iterasjon
\item blir det noe av det samme for predikater?
\end{itemize}