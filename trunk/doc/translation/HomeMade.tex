\newpage
\section{BAREBAJZ}
\label{sect:translation:mXr}



\subsection{Path Expressions}
\label{sect:translation:mXr:smpPathExpr}
XQuery implements XPath 2.0 path expressions as described in section
\ref{sect:theory:xquery:PathExpressions}. The \textsf{scope} operator of
MQL(section \ref{sect:method:marsOperators}) makes it possible to
filter results based on the scope. The operator does however only support paths
equivalent to path expressions with only \texttt{child} axis steps. Methods to
translate expressions with other types of axis steps will be discussed in
section \ref{sect:discussion:notAxis}.

Figure \ref{fig:translation:pathAST} shows the abstract syntax tree for the
generic child axis and name test only path expression \texttt{/a/\ldots/y/z}. It
should be noted that for the sake of simplicitly the AST node \textbf{AST\_STEPEXPR} is
omitted from the representation. The corresponding translation into MQL of such
expressions can be seen in rule \ref{eq:translation:pathExpr}.


\begin{figure}[h]
\centering
\tikzstyle{astNode}=[circle, draw=blue!70,fill=blue!20,solid,thick, minimum
size=26pt]
\begin{tikzpicture}[grow via three points={one child at (0,-1.5) and two
children at (-1.5,-1.0) and (1.5,-1.0)}]

\node at (0,0) [ellipse,
draw=blue!70,fill=blue!20]{AST\_PATHEXPR\_SGL} 
child{node [astNode] {/}
	child{node [astNode] {/}
		child{node [astNode] {/} 
			child{node [astNode] {a} edge from parent [draw, solid, thin]}
			child{node [astNode] {\ldots} edge from parent [draw, solid, thin]}
			edge from parent [draw,dotted, thick] 
			}
		child{node [astNode] {y}}
		}
	child{node [astNode] {z}}
	};
\end{tikzpicture}
\label{fig:translation:pathAST}
\caption[AST of path expression]{A simplified version of the abstract syntax
tree of a simple path expression}
\end{figure}


\begin{equation}
\centering
\texttt{/a/\ldots/y/z}
\Longrightarrow
\begin{array}{l}
	\mbox{\textsf{scope(/a/\ldots/y;}} \\
	\quad \mbox{\textsf{index(valloc; lookup(\$z))}}
\end{array}
\label{eq:translation:pathExpr}
\end{equation}

Rule \ref{eq:translation:singleStep} shows how a single child axis step can be
translated.

\begin{equation}
\centering
\alpha \textsf{/} \beta
\Longrightarrow
\begin{array}{l}
	\mbox{\textsf{project([r.fields,}} \vartheta \mbox{\textsf{];}} \\ \quad
 	\mbox{\textsf{select(isInScope(r.scope, l.scope);}} \\ \quad \quad
 	\mbox{\textsf{join([documentId], [documentId]; }} 
 	\alpha;\, \beta \mbox{\textsf{)))}}; \\
\end{array}
\label{eq:translation:singleStep}
\end{equation}

Where $\vartheta = \alpha.\vartheta \cup \beta.\vartheta$. If $\alpha.\vartheta \cap \beta.\vartheta \neq
\emptyset$, the algebra will have to be augmented with a \textsf{select} operator removing tuples where the common
variables iteration number is not equal. The synchronisation of iteration numbers may be done either before or
after or in combination with the existing \texttt{select} operator in the rule. This is a general rule, and is
applied whenever two expressions are joined or crossed together.

\subsection{Predicates}
\label{sect:translation:mXr:predicates}
As described in section \ref{sect:theory:xqueryPredicates}, predicates are used to restrict the items returned
from the expression it is assigned to. The predicate expression returns either true/false or an integer value. Rule
\ref{eq:translation:predicate} shows how predicates, which neither implisitly nor explicitly makes use of the
context item, are translated into MQL. 

\marginpar{\underline{\Large TODO} \footnotesize litt feil bruk av $\vdash$
her.. kan det tillates?}
\begin{equation}
\centering
\begin{array}{c}
	\frac{\displaystyle \textbf{put(ctx,}\alpha\textbf{)}\vdash\textbf{ctx}\notin\beta.\vartheta}
	{\displaystyle \alpha\texttt{[}\beta\texttt{]}}

	\Longrightarrow 
	\\
	\mbox{}
	\\
	\begin{array}{l}
		\mbox{\textsf{project([fields = l.fields,}} \vartheta \mbox{\textsf{];}} 
		\\ \quad \mbox{\textsf{select(ifThenElse(isNumber(r.value),}} \\ \quad 
		\qquad\qquad \mbox{\textsf{scopeIndex(scope,r.value),xqBool(r.value));}} \\ \quad\quad
		\mbox{\textsf{cross(}} 
		\alpha \textsf{;}
		\beta \mbox{\textsf{)))}}
	\end{array}
\end{array}
\label{eq:translation:predicate}
\end{equation}


\textsf{isNumber(r.value), scopeIndex(scope, r.value)} and \textsf{xqBool(r.value))} are explained in section
\ref{sect:method:marsAddedOperators}. The use of \textsf{scopeIndex(scope,pred)} may however not be valid in cases
where there are multiple predicates, or when the predicate is assigned to a path expression which utilises some
axes like e.g. \texttt{decendant-or-self}. This will be discussed in section \ref{sect:discussion:predicates}.
With the same limitations rule \ref{eq:translation:iterationPredicate} shows how a predicate which \emph{does}
reffer to the context node (implicitly or explicitly) is translated.

\begin{equation}
\centering
\begin{array}{c}
	\frac{\displaystyle \textbf{put(ctx,}\alpha\textbf{)}\vdash\textbf{ctx}\in\beta.\vartheta}
	{\displaystyle \alpha\texttt{[}\beta\texttt{]}}

	\Longrightarrow 
	\\
	\mbox{}
	\\
	\begin{array}{l}
		\mbox{\textsf{project([fields = l.fields,}} \vartheta \mbox{\textsf{];}} 
		\\ \quad \mbox{\textsf{select(ifThenElse(isNumber(r.value),}} \\ \quad 
		\qquad\qquad \mbox{\textsf{scopeIndex(scope,r.value),xqBool(r.value));}} \\ \quad\quad
		\mbox{\textsf{cross( join?}} \\ \quad\quad\quad
		\mbox{\textsf{project(counter())}}\alpha \textsf{;} \\ \quad\quad\quad
		\beta \mbox{\textsf{)))}}
	\end{array}
\end{array}
\label{eq:translation:iterationPredicate}
\end{equation}

Where $\vartheta = \alpha \cup (\beta -$\textbf{ctx}$)$. Because of the predicate exists in its own scope, any
refferal to the context node in $\alpha$ will not be distracted by adding a new context node in the symbol table
for the predicate. As with the single step expression (rule \ref{eq:translation:singleStep}), any common iterator
variable references will have to be synchronised.

\textbf{\underline{\Large TODO:}} Dette fuker ikke helt\ldots hva skjer om predikatet er et sett? YEYEYE samme
problem som med operatorer og ifz etc\ldots Det vi m\aa~finne ut er hvordan sekvenser skal representeres\ldots.
trenger vi order? JEEEEVLER\ldots\ldots\ldots\ldots\ldots\ldots\ldots  BAJZ


\subsection{FLWOR}
\label{sect:translation:mXr:iteration}
As described in \ref{sect:theory:flwor}, the XQuery FLWOR has an iteration semantics. For each item in the
sequence in the \texttt{for} clause (the iteration sequence), the item will be bound to a variable (the iteration
variable) and the expression in the \texttt{return} clause (the iteration body) will be executed.

To represent iteration over a sequence in relational algebra, the MarkXremove method calculates the cartesian
product between the iteration sequence and the result of the iteration body. As the iteration body is able to use
the iteration variable, a step have to be taken to ensure that the right item is used in the right iteration. This
is done by marking each item in the iteration sequence as well as each refferal to the iteration variable with a
number, and removing tuples where the iteration number for the variable does not match up with the iteration
number for the sequence. The translation of a simple \texttt{for \$X in} $\alpha$ \texttt{return} $\beta$ is shown
in rule \ref{eq:translation:simpleIteration}.

\begin{equation}
\centering
\begin{array}{c}
	\frac{\displaystyle \textbf{put(}\texttt{X}\textbf{,}\alpha\textbf{)}\vdash\texttt{X}\in\beta . \vartheta}
	{\displaystyle \texttt{for \$X in }\alpha	\texttt{ return }\beta}
	
	\Longrightarrow 
	\\
	\mbox{} \\
	
	\begin{array}{l}
	\mbox{\textsf{project(fields, }} \vartheta \mbox{\textsf{;}} \\ \quad
	\mbox{\textsf{select(ifThenElse(isNull(Xnumb),true,eq(numb,Xnumb))}} \\ \quad \quad 
	\mbox{\textsf{cross(}} \\ \quad \quad \quad
	\mbox{\textsf{project([numb=counter()];}} \\ \quad \quad \quad \quad
	\alpha \mbox{\textsf{)}} \\ \quad \quad \quad 
	\beta \mbox{\textsf{)))}}
	\end{array}
\end{array}
\label{eq:translation:simpleIteration}
\end{equation}

Where $\vartheta = (\alpha.\vartheta \cup \beta.\vartheta)\, -$ \texttt{X}. In the cases where $\beta$ does not
reffer to the iteration variable (in this case \texttt{X}), the \textsf{select} operator may be omitted.

In the \textsf{select} operator there is a check if the \textsf{-numb} field is \textsf{NULL}. This is becauce a
tuple where this is true is not dependant on which iteration number it is in, and will therefore never be needed
to be removed. \underline{\textbf{\Large TODO:}} jom, elsker slike to be to
needed to setninger\ldots litt norsk-engelskete det ja, hva med ``will never
need to be removed''? :)

Any variable bound in a \texttt{let} clause does not imply iteration. Consequently, the \texttt{let} clause can be
handled as a simple variable binding (section \ref{sect:translation:mXr:variables}). The $\vartheta$ will expose
the cases where a variable bound in a \texttt{let} clause is rebound to a new item each iteration.



The iteration expressions of XQuery comes in the form of FLWORs. But as
previously mentioned, we handle predicates which utilise the context item as an
iteration as well. It 

