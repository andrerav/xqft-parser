\newpage
\section{BAREBAJZ}
\label{sect:translation:mXr}

\subsection{Predicates}
\label{sect:translation:mXr:predicates}
As described in section \ref{sect:theory:xqueryPredicates}, predicates are used to restrict the items returned
from the expression it is assigned to. The predicate expression returns either true/false or an integer value. Rule
\ref{eq:translation:predicate} shows how predicates, which neither implisitly nor explicitly makes use of the
context item, are translated into MQL. 

\begin{equation}
\centering
\begin{array}{c}
	\frac{\displaystyle \textbf{put(ctx,}\alpha\textbf{)}\vdash\textbf{ctx}\notin\beta.\vartheta}
	{\displaystyle \alpha\texttt{[}\beta\texttt{]}}

	\Longrightarrow 
	\\
	\mbox{}
	\\
	\begin{array}{l}
		\mbox{\textsf{project([fields = l.fields,}} \vartheta \mbox{\textsf{];}} 
		\\ \quad \mbox{\textsf{select(ifThenElse(isNumber(r.value),}} \\ \quad 
		\qquad\qquad \mbox{\textsf{scopeIndex(scope,r.value),xqBool(r.value));}} \\ \quad\quad
		\mbox{\textsf{cross(}} 
		\alpha \textsf{;}
		\beta \mbox{\textsf{)))}}
	\end{array}
\end{array}
\label{eq:translation:predicate}
\end{equation}


\textsf{isNumber(r.value), scopeIndex(scope, r.value)} and \textsf{xqBool(r.value))} are explained in section
\ref{sect:method:marsAddedOperators}. The use of \textsf{scopeIndex(scope,pred)} may however not be valid in cases
where there are multiple predicates, or when the predicate is assigned to a path expression which utilises some
axes like e.g. \texttt{decendant-or-self}. This will be discussed in section \ref{sect:discussion:predicates}.
With the same limitations rule \ref{eq:translation:iterationPredicate} shows how a predicate which \emph{does}
reffer to the context node (implicitly or explicitly) is translated.

\begin{equation}
\centering
\begin{array}{c}
	\frac{\displaystyle \textbf{put(ctx,}\alpha\textbf{)}\vdash\textbf{ctx}\in\beta.\vartheta}
	{\displaystyle \alpha\texttt{[}\beta\texttt{]}}

	\Longrightarrow 
	\\
	\mbox{}
	\\
	\begin{array}{l}
		\mbox{\textsf{project([fields = l.fields,}} \vartheta \mbox{\textsf{];}} 
		\\ \quad \mbox{\textsf{select(ifThenElse(isNumber(r.value),}} \\ \quad 
		\qquad\qquad \mbox{\textsf{scopeIndex(scope,r.value),xqBool(r.value));}} \\ \quad\quad
		\mbox{\textsf{cross( join?}} \\ \quad\quad\quad
		\mbox{\textsf{project(counter())}}\alpha \textsf{;} \\ \quad\quad\quad
		\beta \mbox{\textsf{)))}}
	\end{array}
\end{array}
\label{eq:translation:iterationPredicate}
\end{equation}

Where $\vartheta = \alpha \cup (\beta -$\textbf{ctx}$)$. Because of the predicate exists in its own scope, any
refferal to the context node in $\alpha$ will not be distracted by adding a new context node in the symbol table
for the predicate. As with the single step expression (rule \ref{eq:translation:singleStep}), any common iterator
variable references will have to be synchronised.




