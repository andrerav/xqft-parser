\section{MarkXremove}
\label{sect:translation:markXremove}

One of the greatest challenges in transforming XQuery to relational algebra
lies in preserving the semantics of the iterative FLWOR construct. One
course of action for solving this is a method we have called ``MarkXremove'' --
pronounced ``mark, cross and remove''. The basics of the method is that the
result from the \textit{return} clause will always be crossed (cartesian product
see \ref{sect:theory:crossProduct}) with the sequence bound in the
corresponding \textit{for} clause. Any referal in the \textit{return} clause to a
variable bound in a \textit{for} clause will have to be marked with a number
corresponding to the iteration number the instance of the variable exists in.
After the cross product is calculated, rows not conforming to predicates
calculated in the \textit{return} clause will be removed. One of these is that
the variable instance will have to correspond to the interation number.

In the following sections we will present the MarkXremove method for
translating various aspects of XQuery to relational algebra.

\subsection{Basics}
The algebra will be generated by traversing the abstract syntax tree bottom-up,
left-to-right. After visiting a node the algebra for this node and its children
as well as a set, $\vartheta$, of references made to iterator variables. When
$\vartheta$ is refered to in an MQL, it represents a comma separated list of
the names of the fields holding the iteration number for the iterator
variables. This will be further explained in section
\ref{sect:translation:variables}.

It is assumed that a symbol table exists which handles scoping. The functions
\textbf{put(}\textit{X}, $\alpha$\textbf{)} and \textbf{get(}\textit{X}\textbf{)}
will respectively store and fetch algebra trees based on a key \verb!X!. When
moving out of a scope, the symbol table will remove all entries linked to this scope.

The translator is in the logical context, $\Lambda$, if its current node is a
successor of a boolean operator or within the predicate part of an
\textit{if..then..else} expression. In all other cases the translator is in the
default context, $\Delta$. If no context is mentioned in the inference rules
the default context is assumed.

For simplicity all data fields (e.g \verb!dokumentId, scope!) will be referred
to as \verb!fields!, if one field is not explicitly needed.

\subsection{Path Expressions}
\label{sect:translation:smpPathExpr}
XQuery implements XPath 2.0 path expressions as described in section
\ref{sect:theory:xqueryPathExpressions}. The \texttt{scope} operator of
MQL(section \ref{sect:method:marsOperators}) makes it possible to
filter results based on the scope. The operator does however only support paths
equivalent to path expressions with only \textit{child} axis steps. Methods to
translate expressions with other types of axis steps will be discussed in
section \ref{sect:discussion:notAxis}.

Figure \ref{fig:translation:pathAST} shows the abstract syntax tree for the
generic child-axis-only path expression \textit{/a/\ldots/y/z}. The
corresponding translation into MQL of such expressions can be seen in rule
\ref{eq:translation:pathExpr}.


\begin{figure}[h]
\centering
\tikzstyle{astNode}=[circle, draw=blue!70,fill=blue!20,solid,thick, minimum
size=26pt]
\begin{tikzpicture}[grow via three points={one child at (0,-1.5) and two
children at (-1.5,-1.0) and (1.5,-1.0)}]

\node at (0,0) [ellipse,
draw=blue!70,fill=blue!20]{AST\_PATHEXPR\_SGL} 
child{node [astNode] {/}
	child{node [astNode] {/}
		child{node [astNode] {/} 
			child{node [astNode] {a} edge from parent [draw, solid]}
			child{node [astNode] {\ldots} edge from parent [draw, solid]}
			edge from parent [draw,dotted, thick] 
			}
		child{node [astNode] {y}}
		}
	child{node [astNode] {z}}
	};
\end{tikzpicture}
\label{fig:translation:pathAST}
\caption[AST of path expression]{The abstract syntax tree of a simple path
expression}
\end{figure}


\begin{equation}
\centering
\textit{/a/\ldots/y/z}
\Longrightarrow
\begin{array}{l}
	\mbox{\texttt{scope(/a/\ldots/y;}} \\
	\qquad \mbox{\texttt{index(valloc; lookup(\$z))}}
\end{array}
\label{eq:translation:pathExpr}
\end{equation}


\subsection{Variables}
\label{sect:translation:variables}
When a variable is declared, be it in the form of a \textit{for} clause,
\textit{let} clause or a \textit{declare variable} expression, the right side
of such an expression is transformed into algebra. In the case of the
variable being an iterator variable, the $\vartheta$ of this tree will, as well
as possible references made to other iterator variables, include the variable
to which this tree will be bound. The tree is then stored in the symbol
table by means of the previously mentioned \textbf{put(}\textit{X},
$\alpha$\textbf{)}.

When entering a predicate of a path expression, the algebra corresponding to
the steps up to the predicate will be stored in the symbol table as the
iterator variable \textit{``.''} (the context node). The context node may
implicitly be used with a relative path expression within the predicate. Rule
\ref{eq:translation:iteratorVariable} shows the translation of using a
iterator variable. The same principles is behind the inference rule for using
the context node within a path expression predicate.

\begin{equation}
\centering
\frac{\displaystyle \textit{X} \in \vartheta}{\displaystyle \textit{\$X}}
\Longrightarrow
\begin{array}{l}
	\mbox{\texttt{project([Xnumb = counter(), fields,}} \vartheta
	\mbox{\texttt{];}}
	\\ \qquad
	\mbox{\textbf{get(}\textit{X}\textbf{)} \texttt{)}}
\end{array}
\label{eq:translation:iteratorVariable}
\end{equation}

Rule \ref{eq:translation:iteratorVariable} also shows the introduction of a
-\verb!numb! field. This field contains information about which iteration the
instance of the variable in that row belongs to.


\subsection{Iteration Expressions}
\label{sect:translation:iteration}



----------------------------------------------------------------------------------
\label{sect:method:madslifting}
\begin{itemize}
\item merke bruk av variabler
\item for er alltid = kryss
\item vaske merker mot riktig iterasjon -> ergo er iterasjon virkelig iterasjon
\item blir det noe av det samme for predikater?
\end{itemize}