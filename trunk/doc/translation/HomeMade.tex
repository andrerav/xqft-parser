\section{MarkXremove}
\label{sect:translation:markXremove}

One of the greatest challenges in transforming XQuery to relational algebra
lies in preserving the semantics of the iterative FLWOR construct. One
course of action for solving this is a method we have called ``MarkXremove'' --
pronounced ``mark, cross and remove''. The basis of the method is that the
result from the \textit{return} clause will always be crossed (cartesian product
see \ref{sect:theory:crossProduct}) with the sequence bound in the
corresponding \textit{for} clause. Any referal in the \textit{return} clause to a
variable bound in a \textit{for} clause will have to be marked with a number
corresponding to the iteration number the instance of the variable exists in.
After the cross product is calculated, rows not conforming to predicates
calculated in the \textit{return} clause will be removed. One of these is that
the variable instance will have to correspond to the interation number.

In the following sections we will present the MarkXremove method for
translating various aspects of XQuery to relational algebra.

\subsection{Basics}
The algebra will be generated by traversing the abstract syntax tree bottom-up,
left-to-right. After visiting a node the algebra for this node and its children
as well as a set, $\vartheta$, of references made to iterator variables. When
$\vartheta$ is refered to in an MQL, it represents a comma separated list of
the names of the fields holding the iteration number for the iterator
variables. This will be further explained in section
\ref{sect:translation:variables}.

It is assumed that a symbol table exists which handles scoping. The functions
\textbf{put(}\textit{X}, $\alpha$\textbf{)} and \textbf{get(}\textit{X}\textbf{)}
will respectively store and fetch algebra trees based on a key \verb!X!. When
moving out of a scope, the symbol table will remove all entries linked to this scope.

The translator is in the logical context, $\Lambda$, if its current node is a
successor of a boolean operator or within the predicate part of an
\textit{if..then..else} expression. In all other cases the translator is in the
default context, $\Delta$. If no context is mentioned in the inference rules
the default context is assumed.

For simplicity all data fields (e.g \texttt{dokumentId, scope}) will be
referred to as \verb!fields!, if one field is not explicitly needed.

\subsection{Literals and Numbers}
\label{sect:translation:litAndNumbers}
make(name = ``value'', 1,2,3,) etc

\subsection{Sequencing}
\label{sect:translation:sequencing}
\begin{itemize}
  \item (1,2,3) = 1 union 2 union 3 
  \item skriver om optimisering i diskusjon
  \item hva skjer med rekkef\o lge (henger sammen med nummerpredikat)
  \item noe med schema\ldots virka ikke som thorbj\o rnsen var helt forn\o yd
  med at v\aa r tenkte \texttt{union} dret i schema og helte p\aa~
  \texttt{NULL} verdier indiscriminately
\end{itemize}

\subsection{Path Expressions}
\label{sect:translation:smpPathExpr}
XQuery implements XPath 2.0 path expressions as described in section
\ref{sect:theory:xqueryPathExpressions}. The \texttt{scope} operator of
MQL(section \ref{sect:method:marsOperators}) makes it possible to
filter results based on the scope. The operator does however only support paths
equivalent to path expressions with only \textit{child} axis steps. Methods to
translate expressions with other types of axis steps will be discussed in
section \ref{sect:discussion:notAxis}.

Figure \ref{fig:translation:pathAST} shows the abstract syntax tree for the
generic child-axis-only path expression \textit{/a/\ldots/y/z}. It should be
noted that for the sake of simplicitly the AST node \textbf{AST\_STEPEXPR} is
omitted from the representation. The corresponding translation into MQL of such
expressions can be seen in rule \ref{eq:translation:pathExpr}.


\begin{figure}[h]
\centering
\tikzstyle{astNode}=[circle, draw=blue!70,fill=blue!20,solid,thick, minimum
size=26pt]
\begin{tikzpicture}[grow via three points={one child at (0,-1.5) and two
children at (-1.5,-1.0) and (1.5,-1.0)}]

\node at (0,0) [ellipse,
draw=blue!70,fill=blue!20]{AST\_PATHEXPR\_SGL} 
child{node [astNode] {/}
	child{node [astNode] {/}
		child{node [astNode] {/} 
			child{node [astNode] {a} edge from parent [draw, solid, thin]}
			child{node [astNode] {\ldots} edge from parent [draw, solid, thin]}
			edge from parent [draw,dotted, thick] 
			}
		child{node [astNode] {y}}
		}
	child{node [astNode] {z}}
	};
\end{tikzpicture}
\label{fig:translation:pathAST}
\caption[AST of path expression]{A simplified version of the abstract syntax
tree of a simple path expression}
\end{figure}


\begin{equation}
\centering
\textit{/a/\ldots/y/z}
\Longrightarrow
\begin{array}{l}
	\mbox{\texttt{scope(/a/\ldots/y;}} \\
	\qquad \mbox{\texttt{index(valloc; lookup(\$z))}}
\end{array}
\label{eq:translation:pathExpr}
\end{equation}


\subsection{Variables}
\label{sect:translation:variables}
When a variable is declared, be it in the form of a \textit{for} clause,
\textit{let} clause or a \textit{declare variable} expression, the right side
of such an expression is transformed into algebra. In the case of the
variable being an iterator variable, the $\vartheta$ of this tree will, as well
as possible references made to other iterator variables, include the variable
to which this tree will be bound. The tree is then stored in the symbol
table by means of the previously mentioned \textbf{put(}\textit{X},
$\alpha$\textbf{)}. Rule \ref{eq:translation:variableNotIterator} shows the
translation of the reference of a variable that is not an iterator.

\begin{equation}
\centering
\frac{\displaystyle \textit{X} \notin \vartheta}{\displaystyle \textit{\$X}}
\Longrightarrow
\begin{array}{l}
	\mbox{\textbf{get(}\textit{X}\textbf{)}}
\end{array}
\label{eq:translation:variableNotIterator}
\end{equation}

When entering a predicate of a path expression, the algebra corresponding to
the steps up to the predicate will be stored in the symbol table as the
iterator variable \textit{``.''} (the context item). The context node may
implicitly be used with a relative path expression within the predicate. Rule
\ref{eq:translation:iteratorVariable} shows the translation of using a
iterator variable. The same principles is behind the inference rule for using
the context node within a path expression predicate.

\begin{equation}
\centering
\frac{\displaystyle \textit{X} \in \vartheta}{\displaystyle \textit{\$X}}
\Longrightarrow
\begin{array}{l}
	\mbox{\texttt{project([Xnumb = counter(), fields,}} \vartheta
	\mbox{\texttt{];}}
	\\ \qquad
	\mbox{\textbf{get(}\textit{X}\textbf{)} \texttt{)}}
\end{array}
\label{eq:translation:iteratorVariable}
\end{equation}


Rule \ref{eq:translation:iteratorVariable} also shows the introduction of a
-\verb!numb! field. This field contains information about which iteration the
instance of the variable in that row belongs to.

\subsection{Predicates}
As described in section \ref{sect:theory:xqueryPredicates}, predicates are used
to restrict the items returned from the expression it is assigned to. The
predicate expression returns either true/false or an integer value. Rule
\ref{eq:translation:predicate} shows how predicates, which neither implisitly
nor explicitly makes use of the context item, are translated into MQL.
Translation of predicates which employs the context item are treated as an
interation expression (section \ref{sect:translation:iteration}).

\begin{equation}
\centering
%\begin{array}{c}
	\frac{\displaystyle \textbf{put(ctx,}\alpha\textbf{)}\vdash
	\textbf{ctx}\notin\beta . \vartheta}{\alpha \textit{[}\beta\textit{]}}
%	\\
	\Longrightarrow 
%	\\
	\begin{array}{l}
		\mbox{\texttt{project([fields = l.fields,}} \vartheta \mbox{\texttt{];}} 
		\\ \qquad \mbox{\texttt{select(}\textbf{check}\textit{;}} \\ \qquad \qquad
		\mbox{\texttt{cross(}} \\ \qquad \qquad \qquad
		\alpha \texttt{;}\\ \qquad \qquad \qquad
		\beta \mbox{\texttt{)))}}
	\end{array}
%\end{array}
\label{eq:translation:predicate}
\end{equation}

\underline{\Large TODO} litt feil bruk av $\vdash$ her.. kan det tillates?

To be more easily read, in rule \ref{eq:translation:predicate} \textbf{check}
replaces \texttt{ifThenElse(isNumber(r.value), scopeIndex(scope, r.value),
xqBool(r.value))}. These functions are explained in section
\ref{sect:method:marsAddedOperators}. The use of \texttt{scopeIndex(scope,
pred)} may however not be valid in cases where there are multiple predicates,
or when the predicate is assigned to a path expression which utilises some
axes, e.g. \textit{decendant-or-self}. This will be discussed in section
\ref{sect:discussion:predicates}.


\subsection{Iteration Expressions}
\label{sect:translation:iteration}

for \$x in expr1 where expr2 return expr3  -->

scope.put(expr1)

project(~xnumb, ~number
    select(isNull(xnumb), true, eq(number, xnumb))             
    //only if \$x is  used in expr3 
    select(isNull(w.xnumb), true, eq(number, w.xnumb))         
    // only if \$x is used in expr2 
        cross(                     
    // alt fra venstre, varrefs venstre og h√∏yre. (ikke velge value fra h\o yre(
            cross(                                             
          //  n\aa r den bare har value) gir enn\aa~ ordentlig kryss?
                project(number= count(), 
                    expr1)
                expr3
        select(xqueryBoolean(value),                                  
            expr2

\subsection{Comparison Operators}
\label{sect:translation:compOps}

\begin{itemize}
  \item husk at det finnes lambda
  \item project ikke select
  \item fordi noe over vil kanskje ha negativen\ldots f.eks ifthenelse og not()
  \item crazy
\end{itemize}
op $\in$ {< | > | = | <= | >= | != | and }        // and ->
and(xqueryBoolean(l.val), xqueryBoolean(r.val))

\subsection{If then else}
\label{sect:translation:ifThenElse}
if
now

then

else

----------------------------------------------------------------------------------

\begin{itemize}
\item merke bruk av variabler
\item for er alltid = kryss
\item vaske merker mot riktig iterasjon -> ergo er iterasjon virkelig iterasjon
\item blir det noe av det samme for predikater?
\end{itemize}