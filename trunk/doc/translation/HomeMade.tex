\section{MarkXremove}
\label{sect:translation:markXremove}

One of the greatest challenges in transforming XQuery to relational algebra
lies in preserving the semantics of the iterative FLWOR construct. One
course of action for solving this is a method we have called ``MarkXremove'' --
pronounced ``mark, cross and remove''. The basis of the method is that the
result from the \textit{return} clause will always be crossed (cartesian product
see \ref{sect:theory:crossProduct}) with the sequence bound in the
corresponding \textit{for} clause. Any referal in the \textit{return} clause to a
variable bound in a \textit{for} clause will have to be marked with a number
corresponding to the iteration number the instance of the variable exists in.
After the cross product is calculated, rows not conforming to predicates
calculated in the \textit{return} clause will be removed. One of these is that
the variable instance will have to correspond to the interation number.

In the following sections we will present the MarkXremove method for
translating various aspects of XQuery to relational algebra.

\subsection{Basics}
The algebra will be generated by traversing the abstract syntax tree bottom-up,
left-to-right. After visiting a node the algebra for this node and its children
as well as a set, $\vartheta$, of references made to iterator variables. When
$\vartheta$ is refered to in an MQL, it represents a comma separated list of
the names of the fields holding the iteration number for the iterator
variables. This will be further explained in section
\ref{sect:translation:variables}.

It is assumed that a symbol table exists which handles scoping. The functions
\textbf{put(}\textit{X}, $\alpha$\textbf{)} and \textbf{get(}\textit{X}\textbf{)}
will respectively store and fetch algebra trees based on a key \verb!X!. When
moving out of a scope, the symbol table will remove all entries linked to this scope.

The translator is in the logical context, $\Lambda$, if its current node is a
successor of a boolean operator or within the $\alpha$ part of an
\textit{if($\alpha$) then $\beta$ else $\gamma$} expression. In all other cases
the translator is in the default context, $\Delta$. If no context is mentioned
in the inference rules the default context is assumed.

For simplicity all data fields (e.g \texttt{dokumentId, scope}) will be
referred to as \verb!fields!, if one field is not explicitly needed.

\subsection{Literals and Numbers}
\label{sect:translation:litAndNumbers}
To be able to use litterals and numbers in the algebra processing, they need a
relational representation. A simple way to do this is hold the value in a
created relation with a single field, ``value'' (rule
\ref{eq:translation:literalsAndNumbers} ).

\begin{equation}
\centering
\frac{\alpha \in \left\{ Literals, Numbers \right\} }{\alpha}
\Longrightarrow
\texttt{make(name := "value",} \alpha \texttt{)}
\label{eq:translation:literalsAndNumbers}
\end{equation}

There is however also a need to represent explicitly stated XML-nodes, as well
as differentiate between the number \textit{1} and the string \textit{"1"}.
This, and other issues about representing XQuery types will be treated in
section \ref{sect:discussion:typeSystem}.

Rule \ref{eq:translation:literalsAndNumbers} implies that any sequence of
explicitly stated items will first have to be made as one-tuple relations and
then spliced together. As the \texttt{make} operator supports multiple items, a
better solution would be to collect all items in one MQL operator. Further, if
the item is part of a singleton sequence, there is no need for a representation
in form of an relation, as the item could be made part of the parameters of an
operator (e.g. $\alpha$ \textit{> 1} $\Longrightarrow$
\texttt{select(gt(value, 1) $\alpha$)}). Both these issues will be discussed
further in section \ref{sect:discussion:optimisations}.



\subsection{Sequence Making}
\label{sect:translation:sequencing}
As XQuery sequences can only be one dimensional (section
\ref{sect:theory:xquery}), the creation of a sequence can be translated into a
splice of the relations corresponding to the items constituting the sequence.
This can be seen in rule \ref{eq:translation:sequencing}. 

\begin{equation}
\centering
\texttt{(} \alpha , \beta \texttt{)}
\Longrightarrow
\begin{array}{l}
\mbox{\texttt{union(}} 
\alpha \mbox{\texttt{,}} 
\beta \mbox{\texttt{)}}
\end{array}
\label{eq:translation:sequencing}
\end{equation}

\marginpar{\underline{\Large TODO} \footnotesize B\o r dette flyttes til
method:mars:assumedOperatorz i stedet? Det med NULL verdier i radene m\aa~
ogs\aa~skrives om.. blir mye om det her kanskje ja\ldots}
This method assumes that the \texttt{union} operator accepts relations with
different schemas, and does not remove duplicates (but contrary to disjoint
union, there is no need to differansiate elements by their orgin set in the
resultset). The schema for the result relation can be described as:
\begin{equation*}
schema(\texttt{union(}\alpha, \beta\texttt{)}) = schema(\alpha) \cup
schema(\beta).
\end{equation*}
Where $\cup$ is the ordinary set theory operator. In case this is a
unreasonable task to implement, it can be done manually by the translator with
the help of \texttt{project} operators.

As two fields with different types cannot be spliced together, we presume all
\texttt{value} fields are strings for the time being. This will be further
discussed in section \ref{sect:discussion:typeSystem}.



\subsection{Path Expressions}
\label{sect:translation:smpPathExpr}
XQuery implements XPath 2.0 path expressions as described in section
\ref{sect:theory:xqueryPathExpressions}. The \texttt{scope} operator of
MQL(section \ref{sect:method:marsOperators}) makes it possible to
filter results based on the scope. The operator does however only support paths
equivalent to path expressions with only \textit{child} axis steps. Methods to
translate expressions with other types of axis steps will be discussed in
section \ref{sect:discussion:notAxis}.

Figure \ref{fig:translation:pathAST} shows the abstract syntax tree for the
generic child axis and name test only path expression \textit{/a/\ldots/y/z}. It
should be noted that for the sake of simplicitly the AST node \textbf{AST\_STEPEXPR} is
omitted from the representation. The corresponding translation into MQL of such
expressions can be seen in rule \ref{eq:translation:pathExpr}.


\begin{figure}[h]
\centering
\tikzstyle{astNode}=[circle, draw=blue!70,fill=blue!20,solid,thick, minimum
size=26pt]
\begin{tikzpicture}[grow via three points={one child at (0,-1.5) and two
children at (-1.5,-1.0) and (1.5,-1.0)}]

\node at (0,0) [ellipse,
draw=blue!70,fill=blue!20]{AST\_PATHEXPR\_SGL} 
child{node [astNode] {/}
	child{node [astNode] {/}
		child{node [astNode] {/} 
			child{node [astNode] {a} edge from parent [draw, solid, thin]}
			child{node [astNode] {\ldots} edge from parent [draw, solid, thin]}
			edge from parent [draw,dotted, thick] 
			}
		child{node [astNode] {y}}
		}
	child{node [astNode] {z}}
	};
\end{tikzpicture}
\label{fig:translation:pathAST}
\caption[AST of path expression]{A simplified version of the abstract syntax
tree of a simple path expression}
\end{figure}


\begin{equation}
\centering
\textit{/a/\ldots/y/z}
\Longrightarrow
\begin{array}{l}
	\mbox{\texttt{scope(/a/\ldots/y;}} \\
	\qquad \mbox{\texttt{index(valloc; lookup(\$z))}}
\end{array}
\label{eq:translation:pathExpr}
\end{equation}

Rule

\begin{equation}
\centering
\alpha \texttt{/} \beta
\Longrightarrow
\begin{array}{l}
	\mbox{\texttt{project([fields,)}} \vartheta \mbox{\texttt{];}} \\ \qquad
 	\mbox{\texttt{select(isInScope(l.scope, scopePrefix(\textbf{n}, r.scope));}}
 	\\ \qquad \qquad
 	\mbox{\texttt{join([documentId], [documentId], [fields];}} \alpha ; \beta
 	\mbox{\texttt{)))}};
\end{array}
\label{eq:translation:singleStep}
\end{equation}

\subsection{Variables}
\label{sect:translation:variables}
When a variable is declared, be it in the form of a \textit{for} clause,
\textit{let} clause or a \textit{declare variable} expression, the right side
of such an expression is transformed into algebra. In the case of the
variable being an iterator variable, the $\vartheta$ of this tree will, as well
as possible references made to other iterator variables, include the variable
to which this tree will be bound. The tree is then stored in the symbol
table by means of the previously mentioned \textbf{put(}\textit{X},
$\alpha$\textbf{)}. Rule \ref{eq:translation:variableNotIterator} shows the
translation of the reference of a variable that is not an iterator.

\begin{equation}
\centering
\frac{\displaystyle \textit{X} \notin \vartheta}{\displaystyle \textit{\$X}}
\Longrightarrow
\begin{array}{l}
	\mbox{\textbf{get(}\textit{X}\textbf{)}}
\end{array}
\label{eq:translation:variableNotIterator}
\end{equation}

When entering a predicate of a path expression, the algebra corresponding to
the steps up to the predicate will be stored in the symbol table as the
iterator variable \textit{``.''} (the context item). The context node may
implicitly be used with a relative path expression within the predicate. Rule
\ref{eq:translation:iteratorVariable} shows the translation of using a
iterator variable. The same principles is behind the inference rule for using
the context node within a path expression predicate.

\begin{equation}
\centering
\frac{\displaystyle \textit{X} \in \vartheta}{\displaystyle \textit{\$X}}
\Longrightarrow
\begin{array}{l}
	\mbox{\texttt{project([Xnumb = counter(), fields,}} \vartheta
	\mbox{\texttt{];}}
	\\ \qquad
	\mbox{\textbf{get(}\textit{X}\textbf{)} \texttt{)}}
\end{array}
\label{eq:translation:iteratorVariable}
\end{equation}


Rule \ref{eq:translation:iteratorVariable} also shows the introduction of a
-\verb!numb! field. This field contains information about which iteration the
instance of the variable in that row belongs to.

\subsection{Predicates}
As described in section \ref{sect:theory:xqueryPredicates}, predicates are used
to restrict the items returned from the expression it is assigned to. The
predicate expression returns either true/false or an integer value. Rule
\ref{eq:translation:predicate} shows how predicates, which neither implisitly
nor explicitly makes use of the context item, are translated into MQL.
Translation of predicates which employs the context item are treated as an
interation expression (section \ref{sect:translation:iteration}).

\marginpar{\underline{\Large TODO} \footnotesize litt feil bruk av $\vdash$
her.. kan det tillates?}
\begin{equation}
\centering
%\begin{array}{c}
	\frac{\displaystyle \textbf{put(ctx,}\alpha\textbf{)}\vdash
	\textbf{ctx}\notin\beta . \vartheta}{\alpha \textit{[}\beta\textit{]}}
%	\\
	\Longrightarrow 
%	\\
	\begin{array}{l}
		\mbox{\texttt{project([fields = l.fields,}} \vartheta \mbox{\texttt{];}} 
		\\ \qquad \mbox{\texttt{select(}\textbf{check}\textit{;}} \\ \qquad \qquad
		\mbox{\texttt{cross(}} 
		\alpha \texttt{; }
		\beta \mbox{\texttt{)))}}
	\end{array}
%\end{array}
\label{eq:translation:predicate}
\end{equation}


To be more easily read, in rule \ref{eq:translation:predicate} \textbf{check}
replaces \texttt{ifThenElse(isNumber(r.value), scopeIndex(scope, r.value),
xqBool(r.value))}. These functions are explained in section
\ref{sect:method:marsAddedOperators}. The use of \texttt{scopeIndex(scope,
pred)} may however not be valid in cases where there are multiple predicates,
or when the predicate is assigned to a path expression which utilises some
axes, e.g. \textit{decendant-or-self}. This will be discussed in section
\ref{sect:discussion:predicates}.


\subsection{Iteration Expressions}
\label{sect:translation:iteration}

for \$x in expr1 where expr2 return expr3  -->

scope.put(expr1)

project(~xnumb, ~number
    select(isNull(xnumb), true, eq(number, xnumb))             
    //only if \$x is  used in expr3 
    select(isNull(w.xnumb), true, eq(number, w.xnumb))         
    // only if \$x is used in expr2 
        cross(                     
    // alt fra venstre, varrefs venstre og høyre. (ikke velge value fra h\o yre(
            cross(                                             
          //  n\aa r den bare har value) gir enn\aa~ ordentlig kryss?
                project(number= count(), 
                    expr1)
                expr3
        select(xqueryBoolean(value),                                  
            expr2

\subsection{Comparison Operators}
\label{sect:translation:compOps}

\begin{itemize}
  \item husk at det finnes lambda
  \item project ikke select
  \item fordi noe over vil kanskje ha negativen\ldots f.eks ifthenelse og not()
  \item crazy
\end{itemize}
op $\in$ {< | > | = | <= | >= | != | and }        // and ->
and(xqueryBoolean(l.val), xqueryBoolean(r.val))

\subsection{If then else}
\label{sect:translation:ifThenElse}
if
now

then

else

\subsection{Examples}
\label{sect:translation:markxremoveExamples}
\begin{itemize}
\item steg for ste
\item litt stort eksempel m predikat sammenligning og for
\item kanskje en liten where
\end{itemize}
----------------------------------------------------------------------------------

\begin{itemize}
\item merke bruk av variabler
\item for er alltid = kryss
\item vaske merker mot riktig iterasjon -> ergo er iterasjon virkelig iterasjon
\item blir det noe av det samme for predikater?
\end{itemize}