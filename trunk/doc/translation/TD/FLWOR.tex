\subsection{FLWOR Expressions}
\label{sect:trans:TD:simpleFLWOR}
The \texttt{let} clause does not cause any dependencies, only variable binding, and can therefore be translated
into storing the algebraic version of the expression to be bound in the symbol table:
\begin{equation}
\frac{}{\mbox{\texttt{let \$}}\chi \mbox{\texttt{ := }}e \mbox{\texttt{ \ldots}}}\longmapsto
\mbox{\textbf{put(}}\chi\mbox{\textbf{, r(}}e\mbox{\textbf{))}}
\label{rule:trans:TD:letbind}
\end{equation}
The iterator dependences $e.\vartheta$ is stored along with \textbf{r(}$e$\textbf{)} and will piggyback this
algebra tree if it later fetched from the symbol table. If there is more than one variable binding in the
\texttt{let} clause the rule must be applied once per binding as if one binding were one \texttt{let} clause.

As seen by the exerpt of the W3C XQuery EBNF specification in figure \ref{fig:trans:TD:seqEBNF}, a FLWOR
expression may be structured in infinitely many ways. For simplicity and readablilty the translation of such
expressions will be described in a clause-by-clause matter, as if executed as a postorder traversal of the tree in
figure \ref{fig:trans:TD:flworExecute}. The left children (variable bindings) will not return anything to their
parent and are handled by the rules \ref{rule:trans:TD:forbind} and \ref{rule:trans:TD:letbind}, and the algebra
returned from the right children will be referred to as \textbf{r(}$e_{child}$\textbf{)}. 

A FLWOR expression may have multiple \texttt{for} clauses, and a \texttt{for} clause may have multiple iterator
variable bindings. This means that one FLWOR may consist of many iterators, the semanics of which is described in
section \ref{sect:method:ast_rewrite}. The set of all iterator variables bound in one FLWOR will be reffered to as
$\beta$.

\begin{figure}[h]
\centering
\tikzstyle{optional}= []%[draw=black,dotted,thick, minimum size=26pt]
\tikzstyle{return}= [] %[ellipse,draw=black,solid,thick, minimum size=26pt]

\begin{tikzpicture}[grow via three points={one child at (1.5,-1.0) and two
children at (-1.5,-1.0) and (1.5,-1.0)}]
\node at (0,0) [optional] {[\textbf{let/for clause}]+}
child{node [optional] {[\textbf{binding}]+} edge from parent [draw,dotted, thick]}
	child{node [optional] {[\texttt{order by} $e_{3}$]?}
		child{node [optional] {[\texttt{where} $e_{2}$]?}
			child{node [return] {\texttt{return} $e_{4}$}}
			}
		} 
;
\end{tikzpicture}
\label{fig:trans:TD:flworExecute}
\caption[FLWOR translation order]{Illustration of step-by-step translation of FLWOR.}
\end{figure}

Because the \texttt{let} clause does not imply any iteration, it does not have any consequences for the
translation of FLWOR expresions:
\begin{equation}
\frac{}{\mbox{\textbf{let clause}}}\longmapsto \mbox{\textbf{r(}}e_{child}\mbox{\textbf{)}}
\label{rule:trans:TD:letclause}
\end{equation}

The \texttt{return} clause is evaluated once for each combination of iterations of the FLWOR expression. The
results of these evaluations are concatenated to form the result of the FLWOR expression. If the \texttt{return}
expression is not dependent on some of the iterators, its relational form will not have a representation for each
of these iterators iterations. Because of this the result of the \texttt{return} clause will have to be tainted
with these iterators.
\begin{equation}
\frac{}{\mbox{\texttt{return }}e_{4}}\longmapsto
\mbox{\textbf{t(r(}}e_{4}\mbox{\textbf{), }}\beta\mbox{\textbf{)}}
\label{rule:trans:TD:returnTaint}
\end{equation}
Where the dependencies returned is $\vartheta = e_4.\vartheta \cup \beta$.

From equation \ref{eq:trans:TD:taint} it is clear that a expression allready dependent on $I_{\chi}$ will not be
tainted by this iterator.

Because each FLWOR iterator creates a new sequence, renumbering is needed to calculate the result. No expression in
a sibling or parent scope of the iterator $I_{\chi}$ may be dependent on $I_{\chi}$. Thus, $\chi$ is not part of the
dependencies $I_{\chi}.\vartheta$ returned from the iterator, and the corresponding $\chi{numb}$ attribute must be
removed. For each binding, from right to left, of an iterator variable $\chi$ bound in an \texttt{for} clause,
the following translation is applied: 
\begin{equation}
\frac{}{\mbox{\textbf{for clause binding }}\chi}
\longmapsto
\begin{array}{l}
\mbox{\textsf{numberate(index, [}}\chi\mbox{\textsf{numb, index], [}}\vartheta\mbox{\textsf{];}} \\ \quad
\mbox{\textbf{r(}}e_{child}\mbox{\textbf{)}\textsf{)}}
\end{array}
\label{rule:trans:TD:forReturn}
\end{equation}

Where $\vartheta = e_{child}.\vartheta - \chi$.

The \textsf{numberate} operator will have to partition on the remaining dependencies in $\vartheta$ to seperate
the sequences returned from the iterator for all iterators the result is dependent on, as with the sequence
construction expression.

\begin{myExample}

With the rules for translating \texttt{for} and \texttt{return} clauses, the query of figure
\ref{fig:trans:TD:expandQuery} can be fully evaluated. Expression $e_{1}$ is the \texttt{return} clause expression
of, but is not depentant on $I_{\mbox{\texttt{b}}}$. By rule \ref{rule:trans:TD:returnTaint} $e_{1}$ is tainted,
as shown in figure \ref{fig:trans:TD:final:taint}. To calculate the result of $I_{\mbox{\texttt{b}}}$,
renumbering is required, as the iterator will return a sequence of four items (to items for each of the two
iterations). The rule \ref{rule:trans:TD:forReturn} is applied. This will result in the relation illustrated in
figure \ref{fig:trans:TD:final:rIb}. $I_{\mbox{\texttt{b}}}$ consitutes the \texttt{return} clause of
$I_{\mbox{\texttt{a}}}$, and is dependent on $I_{\mbox{\texttt{a}}}$ because one of its subexpressions is a
referral to \texttt{\$a}. Rule \ref{rule:trans:TD:returnTaint} will therefore not have any effect. A renumbering
with rule \ref{rule:trans:TD:forReturn} finalises the evalution of the query. The final result is shown in figure
\ref{fig:trans:TD:final:rIb}.


\begin{figure}[h]
\centering
\subfigure[\textbf{t(r(}$e_{1}$\textbf{), \{}\texttt{b}\textbf{\})}]{
\begin{tabular}{|c|c|c|c|} \hline
$bnb$ & $anb$ & $idx$ & $val$ \\ \hline
1 & 1 & 1 & 10 \\ \hline
1 & 2 & 1 & 20 \\ \hline
1 & 1 & 2 & \texttt{"no"} \\ \hline
1 & 2 & 2 & \texttt{"no"} \\ \hline
2 & 1 & 1 & 10 \\ \hline
2 & 2 & 1 & 20 \\ \hline
2 & 1 & 2 & \texttt{"no"} \\ \hline
2 & 2 & 2 & \texttt{"no"} \\ \hline
\end{tabular}
\label{fig:trans:TD:final:taint}
}
\qquad
\subfigure[\textbf{r(}$I_{\mbox{\texttt{b}}}$\textbf{)}]{
\begin{tabular}{|c|c|c|} \hline
$anb$ & $idx$ & $val$ \\ \hline
1 & 1 & 10 \\ \hline
1 & 2 & \texttt{"no"} \\ \hline
1 & 3 & 10 \\ \hline
1 & 4 & \texttt{"no"} \\ \hline
2 & 1 & 20 \\ \hline
2 & 2 & \texttt{"no"} \\ \hline
2 & 3 & 20 \\ \hline
2 & 4 & \texttt{"no"} \\ \hline
\end{tabular}
\label{fig:trans:TD:final:rIb}
}
\qquad
\subfigure[\textbf{r(}$I_{\mbox{\texttt{a}}}$\textbf{)}]{
\begin{tabular}{|c|c|} \hline
$idx$ & $val$ \\ \hline
1 & 10 \\ \hline
2 & \texttt{"no"} \\ \hline
3 & 10 \\ \hline
4 & \texttt{"no"} \\ \hline
5 & 20 \\ \hline
6 & \texttt{"no"} \\ \hline
7 & 20 \\ \hline
8 & \texttt{"no"} \\ \hline
\end{tabular}
\label{fig:trans:TD:final:rIa}
}

\caption[Example: resolving for..return]{Applying rule \ref{rule:trans:TD:forReturn} on (a) yields (b). Applying
rule \ref{rule:trans:TD:forReturn} on (b) yields (c). Attribute names are shortened
\label{fig:trans:TD:finalizeExp}}
\end{figure}

\end{myExample}


Where
\begin{itemize}
  \item select
  \item kan miste -numbz, men det g\aa r greit?
\end{itemize}

orderby
\begin{itemize}
  \item vente litt med denne?
\end{itemize}

