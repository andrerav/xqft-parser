\subsection{FLWOR Expressions}
\label{sect:trans:TD:simpleFLWOR}
\textbf{\Large TODO:} Dette kan skrives om til enda mer generelt. S\aa~lenge for-clause biten blir kj\o rt for
hver binding, fra den siste og innover, stemmer det. Vi m\aa~definere et sett som holder alle iteratorvariabler
som blir bundet i denne FLWORen. I return-clausen vil iteratorbodyen bli tainta med dette settet (det skjer ikkeno
om iteratorbody'en allerede er avhengig av alle variablene\ldots)

The \texttt{let} clause does not cause any dependencies, only variable binding, and can therefore be translated
into storing the algebraic version of the expression to be bound in the symbol table:
\begin{equation}
\frac{}{\mbox{\texttt{let \$}}\chi \mbox{\texttt{ := }}e \mbox{\texttt{ \ldots}}}\longmapsto
\mbox{\textbf{put(}}\chi\mbox{\textbf{, r(}}e\mbox{\textbf{))}}
\label{rule:trans:TD:letbind}
\end{equation}
The iterator dependences $e.\vartheta$ is stored along with \textbf{r(}$e$\textbf{)} and will piggyback this
algebra tree if it later fetched from the symbol table. If there is more than one variable binding in the
\texttt{let} clause the rule must be applied once per binding as if one binding were one \texttt{let} clause.

As previously mentioned, multiple variable bindings within one \texttt{for} clause is semanticly equal to
nested FLWOR expressions. Here, the innermost FLWOR will contain the last binding as its \texttt{for} clause and
all other subexpressions of the original FLWOR. Each preceding variable binding correspond to a FLWOR with the
binding as a \texttt{for} clause and the FLWOR corresponding to the succeding binding as its \texttt{return}
clause. Multiple \texttt{for} clauses within one FLWOR expression is to be considered in a similar matter.
Explicit rewriting of these kind of expressions is discussed in section \ref{sect:method:ast_rewrite}.

From the XQuery specification exerpt of figure \ref{fig:trans:TD:seqEBNF}, we see that a FLWOR expression may
appear in many different formats. In this section we will for inference rule readability and simplicty treat these
expressions as if they no more than \emph{one} \texttt{for} clause containing exactly \emph{one} variable binding.
Further, the translation of FLWORs will be described in a clause-by-clause manner, as if executed as a postorder
traversal of the tree in figure \ref{fig:trans:TD:flworExecute}. The left children (variable bindings) will not
return anything to their parent and are handled by the rules \ref{rule:trans:TD:forbind} and
\ref{rule:trans:TD:letbind}, and the algebra returned from the right children will be referred to as
\textbf{r(}$e_{child}$\textbf{)}.

\begin{figure}[h]
\centering
\tikzstyle{optional}= []%[draw=black,dotted,thick, minimum size=26pt]
\tikzstyle{return}= [] %[ellipse,draw=black,solid,thick, minimum size=26pt]

\begin{tikzpicture}[grow via three points={one child at (1.5,-1.0) and two
children at (-1.5,-1.0) and (1.5,-1.0)}]
\node at (0,0) [optional] {[\textbf{let clause}]*}
child{node [optional] {[\textbf{binding}]+} edge from parent [draw,dotted, thick]}
child{node [optional] {[\textbf{for clause}]?}
	child{node [optional] {[\texttt{\$}$\chi$ \texttt{in} $e_{1}$]?} edge from parent [draw,dotted, thick] }
	child{node [optional] {[\textbf{let clause}]*}
		child{node [optional] {[\textbf{binding}]+} edge from parent [draw,dotted, thick] }
		child{node [optional] {[\texttt{order by} $e_{3}$]?}
			child{node [optional] {[\texttt{where} $e_{2}$]?}
				child{node [return] {\texttt{return} $e_{4}$}}
			}
		} 
	}
}
;
\end{tikzpicture}
\label{fig:trans:TD:flworExecute}
\caption[FLWOR translation order]{Illustration of step-by-step translation of FLWOR.}
\end{figure}

Because the \texttt{let} clause does not imply any iteration, it does not have any consequences for the
translation of FLWOR expresions:
\begin{equation}
\frac{}{\mbox{\textbf{let clause}}}\longmapsto \mbox{\textbf{r(}}e_{child}\mbox{\textbf{)}}
\label{rule:trans:TD:letclause}
\end{equation}

If a \texttt{for} clause is part of a FLWOR expresion it an iterator. A \texttt{return} clause which is part of an
iterator is evaluated once for each item in the iterator sequence. The results of these evaluations are
concatenated to form the result of the FLWOR expression. If the \texttt{return} expression is not dependent on the
iterator, its relational form will not vary with the iteration number. In such a case the result of the iterator
body will have to be tainted with the iterator. The \texttt{return} clause of an iterator $I_{\chi}$ can be
translated like this:
\begin{equation}
\frac{I_{\chi}}{\mbox{\texttt{return }}e_{4}}\longmapsto
\mbox{\textbf{t(r(}}e_{4}\mbox{\textbf{), }}\chi\mbox{\textbf{)}}
\label{rule:trans:TD:returnTaint}
\end{equation}
An iterator body dependent on $I_{\chi}$ will allready have a representation for each iteration, and will not be
tainted (ref. equation \ref{eq:trans:TD:taint}).

If the \texttt{return} clause is part of a \texttt{for}-less FLWOR expression no translation is needed.

Because a FLWOR iterator creates a new sequence, renumbering is needed to calculate the result. No expression in a
sibling or parent scope of the iterator $I_{\chi}$ may be dependent on $I_{\chi}$. Thus, $\chi$ is not part of the
dependencies $I_{\chi}.\vartheta$ returned from the iterator, and the corresponding $\chi{numb}$ attribute must be
removed.
\begin{equation}
\frac{I_{\chi}}{\mbox{\textbf{for clause}}}
\longmapsto
\begin{array}{l}
\mbox{\textsf{numberate(index, [}}\chi\mbox{\textsf{numb, index], [}}\vartheta\mbox{\textsf{];}} \\ \quad
\mbox{\textbf{r(}}e_{child}\mbox{\textbf{)}\textsf{)}}
\end{array}
\label{rule:trans:TD:forReturn}
\end{equation}

Where $\vartheta = e_{child}.\vartheta - \chi$.

The \textsf{numberate} operator will have to partition on the remaining dependencies in $\vartheta$ to seperate
the sequences returned from the iterator for all iterators the result is dependent on, as with the sequence
construction expression.

\begin{myExample}
L\o se expanded simpQuery i stedet..

In the query of figure \ref{fig:trans:TD:simpQuery} the return clause is dependent on $I_{\mbox{\texttt{a}}}$
as a consequence of the reference to \texttt{\$a} in the sequence construction expression $e_{1}$. The result of
the FLWOR expresion, and therefore the query, must be a sequence holding four items. This is because for each of
the two iterations of $I_{\mbox{\texttt{a}}}$ two items are returned. Figure \ref{fig:trans:TD:simpl:rall} shows
the relational representation of $e_{1}$. By applying rule \ref{rule:trans:TD:forReturn} on this, we get the
result of the query, as shown in figure \ref{fig:trans:TD:simpRes}.

\begin{figure}[h]
\centering
\begin{tabular}{|c|c|} \hline
$index$ & $value$ \\\hline
1 & 10 \\\hline
3 & 20 \\\hline
2 & \texttt{"no"} \\\hline
4 & \texttt{"no"} \\\hline
\end{tabular}
\caption{The result of the query in figure \ref{fig:trans:TD:simpQuery}}
\label{fig:trans:TD:simpRes}
\end{figure}

\end{myExample}


Where
\begin{itemize}
  \item select
  \item kan miste -numbz, men det g\aa r greit?
\end{itemize}

orderby
\begin{itemize}
  \item vente litt med denne?
\end{itemize}

