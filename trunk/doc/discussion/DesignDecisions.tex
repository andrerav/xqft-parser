% Discussion / Design decisions
\section{Design Decisions}
\label{sect:discussion:designDecisions}

Of the alternatives in section \ref{sect:ambiguousgrammar:ambigTerm}, we ended up, as previously mentioned, on the parser controlled state driven lexer alternative. This strategy depends upon the lexer not generating any tokens before they are needed by the parser, dealt with by our implementation of \verb!UnbufferedCommonTokenStream!, and that most terminal alternatives are augmented with semantic predicates controlling which alternatives are available in which state.

\subsection{Parser Controlled Lexer}
Making the lexer emit one and one token instead of processing the input as a
whole, most probably leads to a slightly prolonged execution time as the
runtime control will be shunted between the parser and lexer multiple times
per query parsed. It is not believed that this will cause too much performance 
problems as input queries are thought to be fairly short (mostly below 100
lines). That this strategy is viable in a real world situation can be shown by
the fact that the eXist XML database (section \ref{sect:stateOfTheArt:eXist}) in
a manner similar to our system employs a parser controlled strategy.
Additionally, the Pathfinder parser (section \ref{sect:soa:pathfinder})
generates one and one token, like in this case.

The option would be to implement a pure state driven lexer. This would let the
lexer operate completely autonomous, though at the cost of a much more complex
control structure than is the case of the parser controlled solution. All in
all this strategy would probably not lead to any significant performance gain,
but rather the opposite. In addition, as mentioned in section
\ref{sect:amiguousgrammar:stateDriven}, we made a prototype with this strategy
for a subset of XQuery, and decided that this would be a quite complicated task
for the full version of the grammar -- a task that would result in a greater
deal of time being consumed by implementation and bug fixing.

Our grammar, by being dependent on our custom token stream, would render
gUnit(section \ref{sect:method:gUnit} and \ref{sect:results:tests:unit}) and
ANTLRWorks (section \ref{sect:method:debugging}) less usable, in some cases to
the point of being completely unusable. This is because these tools both depend
on their own proprietary token stream implementation. The reduction of the unit
testing capabilities were not a big loss however, as they were mended by the
manual coverage tests, which in fact proved to be a simpler and more thorough
way of testing our parser.

Neither was the loss of certain ANTLRWorks functionality; because of its
instability, it never was the grammar editor of choice. Furthermore, the
drawing of syntax diagrams -- a handy way of resolving non-determinisms in the
parser -- is done during grammar compile time, and is therefore still
functional. Finally, by manipulating the ANTLRWorks application with a simple
modification (specifically, overriding the \verb!setTokenStream()! method), it
can still parse input and draw the corresponding parsing tree, though not in a
step-by-step manner.

\subsection{State Driven Lexer}
\label{sect:discussion:stateDriven}
The states of our lexer are implemented by gated semantic predicates and the
\verb!TOKENSWITCH! construct. This may have made our grammar quite complex and
less easily readable. An alternative to this approach would be to write the
lexer by hand. In this way we could have made a much easier state controll
structure, with a more complete division between each states functionality.
But future modifiability would be a problem, as an substantial amount of
refactoring would be necessary for even the simplest change in grammar
semantics.

Using island grammars (section \ref{sect:amiguousgrammar:islandGrammar}) would
render each subgrammar very simple and readable. Simple grammars intuitively
also generates simple recognizers, giving an additional benefit in performace
time. Though a performace overhead would come in form of switching between the
lexers, we belive this is significantly outweighted by the gain by having
completly unambiguous grammars. The catch is that using multiple lexers are not
naitively supported by ANTLR as of yet, and the extensive modifications needed
to make this work reliably would require substantially more time and effort. If
however ANTLR is to include this in the near future, the grammar can be easily
altered to accomodate this.

As there are only a few productions that are available per state, exept for in the \verb!DEFAULT! state, a third option would be a hybrid of island grammars and writing the lexer by hand. In this solution, a lexer rule not a member of this state would be removed from the grammar, and be replaced by corresponding handwritten lexer in the form of a method in the lexer class called by a inline action in the ANTLR grammar. The problem with this option is that much of the lexer specification would not be in form of ANTLR grammar, thus decreasing readability and ease of change. Another issue would be that the manual lexer would have to conform to the ANTLR generated lexer's manner of operation with regards to generating tokens, handling the inputstream and pointers etc., which may not be a trivial task to implement.