\section{Results}
\label{sect:disc:res}
\textbf{\LARGE TODO: {{ANDREAS}}}

\subsection{Translation output}
\label{sect:disc:res:translation_output}
In sections \ref{sect:result:theoretical_algebra} and
\ref{sect:result:implementation_algebra}, a series of XQuery queries were
translated using the novel ``Tainting Dependencies'' (TD) methodology developed
and described in chapter \ref{sect:translation}. In section
\ref{sect:result:theoretical_algebra}, where hand-computed translations were
presented, a series of simplifications were applied (these simplifications were
described in section \ref{sect:trans:TD:simplifications}). However, the
prototype developed in chapter \ref{chapter:implementation} did not implement
any of these simplifications. This was an important point to keep in mind when
later comparing this algebra to that generated by Pathfinder, and is
discussed more thoroughly in the next section.

One characterisation of the algebra generated by TD is that nodes with more
than one parent node are typically located far towards the bottom of the algebra
tree. 

Another characteristic of the algebra is that is seems to maintain a fairly
compact form. This is partly due to the fact that the tainting process does not
affect constant subexpressions, and thus the potential size of the algebra is
reduced significantly. Compare this to loop lifting used by
Pathfinder, where all expressions within a loop body are loop lifted --
as explained in sections \ref{sect:trans:ll:ConstExprs},
\ref{sect:trans:ll:mappingBack}, and \ref{sect:trans:ll:OtherExpr}.

TODO: parallellisering \^ ?

\subsection{Complexity comparison}
\label{sect:disc:res:comparison}
The complexity calculation method (see section \ref{sect:method:complexity} on
page \pageref{sect:method:complexity}) defined by \O ystein Torbj\o rnsen at
FAST was used to compare complexity in the algebra generated by the prototype
implementation to that of Pathfinder. This comparison was
based on three queries (dubbed \emph{Trivial}, \emph{Complex}, and
\emph{Conditional}). For each of these queries, algebra was generated on both
the prototype implementation as well as Pathfinder. Then the described
method of calculating complexity was applied to these trees, and the result was
used to compare the prototype and Pathfinder.

Though an interesting comparison, this is a sparse source of data -- it
is difficult to be conclusive based this data alone. However, with the
exception of the most trivial query, it seems that ``Tanting Dependencies'' (TD)
generates substantially less complex algebra than Pathfinder. As one
may consider TD an enhancement of the loop lifting technique, this should
emerge as a natural consequence.

However, there are some sources of uncertainty for this comparison. It is not
known exactly to which degree simplifications and optimalisations have been
applied to the algebra generated by Pathfinder. In any case, the
algebra generated by TD is not simplified or optimised, and as such puts these
implementations on equal footing. 

It is also known that Pathfinder does \emph{not}:
\begin{itemize}
  \item generate algebra using pure loop lifting as would be expected from
  \cite{pathfinder_mothertongue} and \cite{pathfinder_purelyRelational}
  \item apply all simplifications described in
  \cite{pathfinder_purelyRelational}
\end{itemize}

Furthermore, it is natural to assume that Pathfinder generates algebra
which is tailored for execution on the MonetDB database system (as indicated
in \cite{pathfinder_purelyRelational}).

With regards to performance measurement, and with the lack of availability of a
proper implementation of a MQL processor (as mentioned in section
\ref{sect:method:mql} on page \pageref{sect:method:mql}), it could have been
benefitial to generate algebra using TD for MonetDB, and compare
actual performance of loop lifting vs. TD on this database system. This notion
is further detailed in section \ref{chapter:future}.

Finally, it is important to note that the complexity comparison performed did
not in anyway account for I/O or CPU usage, and the results must not be
interpreted as such. Again, see section \ref{sect:method:complexity} on
page \pageref{sect:method:complexity} for an detailed account of this method.

\subsection{Loop Lift vs Tainting Dependencies}
\label{sect:disc:llvsTD}
This project has studied two approaches for translating XQuery to relational
algebra; loop lifting as implemented by Pathfinder, and ``Tainting
Dependecies'' (TD), which is a novel method developed in this project which
still shares a few common traits with loop lifting. However, the motivation for
the development of TD was the fact that the more expressive MQL algebra allowed
more flexibility in the translation. Furthermore, loop lifting has the
disadvantage of full denormalisation, as noted in
\cite{pathfinder_purelyRelational}: 

\begin{quote}
[..] loop lifting consequently leads to a fully denormalized representation for
$e$ and thus to -- at least potentially -- significant data redundancy
\end{quote}

Another common trait of loop lifting, which is also noted in
\cite{pathfinder_mothertongue} and \cite{pathfinder_purelyRelational}, is that
the algebra trees will quickly grow very large. Consider the example in section 
\ref{sect:trans:ll:example} on page \pageref{sect:trans:ll:example}; here, the
intermediate results grow in size very quickly. In particular, they are
comparatively large seen in the context of the trivial query they are produced
from.

When the algebra trees generated by loop lifting are converted to DAGs, this
trait may not seem so appareant. However, it is easily recognized by the fact
that nodes with more than one parent often are located in the middle and higher
parts of the tree, for example as seen in figure
\ref{fig:result:comparison:conditional_pathfinder_dag} on page
\pageref{fig:result:comparison:conditional_pathfinder_dag}. If this particular
DAG was converted to a tree, it would indeed be substantially larger.

Further, when comparing the rules in loop lifting (described in
\cite{pathfinder_mothertongue}) and TD, it appears that TD will in most cases
produce less operators and less complex trees than loop lifting, as well as
substantially smaller intermediate results. This comparison does not consider
simplifications, however. In some situations, especially for trivial queries,
optimised loop lifting \emph{may} perform better than TD. 

\subsection{Considerations for executing MQL}
The ``Tainting Dependencies'' method produces relatively simplistic algebra
when compared to the full feature set of MQL. In section \ref{sect:method:mql},
only the operators used throughout this project was described. However, this is
only a subset of the features in MQL. This was done with the intent of creating
algebra which can be optimised using common techniques already available.
Introducing new and exotic operators complicates this process, and so this was
avoided. However, in the light of the expressiveness available in MQL, it may
be benefitial to employ a wider array of operators available when constructing
MQL algebra. In any case, this requires further documentation and concrete
performance measurements.