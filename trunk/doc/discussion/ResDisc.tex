\section{Results}
\label{sect:disc:res}
Chapter \ref{chapter:results} presented a serious of algebra trees --
some calculated by hand using Tainted Dependencies, and others generated using
the prototype implementation described in chapter \ref{chapter:implementation}.
Furthermore we compared algebra generated by the prototype with that generated
by Pathfinder. This section will discuss these results in detail.

\subsection{Translation output}
\label{sect:disc:res:translation_output}
In sections \ref{sect:result:theoretical_algebra} and
\ref{sect:result:implementation_algebra}, a series of XQuery queries were
translated using the novel Tainting Dependencies (TD) methodology developed
and described in chapter \ref{sect:translation}. In section
\ref{sect:result:theoretical_algebra}, where hand-computed translations were
presented, a series of simplifications were applied (these simplifications were
described in section \ref{sect:trans:TD:simplifications}). However, the
prototype developed in chapter \ref{chapter:implementation} did not implement
any of these simplifications. This was an important point to keep in mind when
later comparing this algebra to that generated by Pathfinder, and is
discussed more thoroughly in the next section.

One characterisation of the algebra generated by TD is that nodes with more
than one parent node are typically located far towards the bottom of the algebra
tree. 

Another characteristic of the algebra is that is seems to maintain a fairly
compact form. This is partly due to the fact that the tainting process does not
affect constant subexpressions, and thus the potential size of the algebra is
reduced significantly. Compare this to loop lifting used by
Pathfinder, where all expressions within a loop body are loop lifted --
as explained in sections \ref{sect:trans:ll:ConstExprs},
\ref{sect:trans:ll:mappingBack}, and \ref{sect:trans:ll:OtherExpr}.

\subsection{Complexity comparison}
\label{sect:disc:res:comparison}
The complexity calculation method (see section \ref{sect:method:complexity} on
page \pageref{sect:method:complexity}) defined by \O ystein Torbj\o rnsen at
FAST was used to compare complexity in the algebra generated by the prototype
implementation to that of Pathfinder. This comparison was
based on three queries (\emph{Trivial}, \emph{Complex}, and
\emph{Conditional}). For each of these queries, algebra was generated on both
the prototype implementation as well as Pathfinder. Then the described
method of calculating complexity was applied to these trees, and the result was
used to compare the prototype and Pathfinder.

We found that in terms of counting tuple and field creations, TD seems to excel
in large and complex queries. In the case of more trivial queries, loop lifting
and TD seem to perform similarly. Furthermore, in the case of tuple
input/output in join and sort operators, we saw that for the ``complex'' query
example, TD did not produce any joins at all, while loop lifting produced 3
joins for the same expression.

Though an interesting comparison, this is a sparse source of data -- it
is difficult to be conclusive based this data alone. However, with the
exception of the most trivial query, it seems that ``Tanting Dependencies'' (TD)
generates substantially less complex algebra than Pathfinder. As one
may consider TD more specialised method than the general loop lifting
technique, this should emerge as a natural consequence.

However, there are some sources of uncertainty for this comparison. It is not
known exactly to which degree simplifications and optimalisations have been
applied to the algebra generated by Pathfinder. In any case, the
algebra generated by TD is not simplified or optimised, and as such puts these
implementations on equal footing. 

It is also known that Pathfinder does \emph{not}:
\begin{itemize}
  \item generate algebra using pure loop lifting as would be expected from
  \cite{pathfinder_mothertongue} and \cite{pathfinder_purelyRelational} -- this
  is deduced by comparing the output from Pathfinder with the output
  from the rules defined in \cite{pathfinder_mothertongue} and
  \cite{pathfinder_purelyRelational}
  \item apply all simplifications described in
  \cite{pathfinder_purelyRelational} -- again, this is deduced by comparing the
  output from Pathfinder with the supposed output from the simplifications in
  \cite{pathfinder_purelyRelational}
\end{itemize}

Additionally, in section \ref{sect:method:complexity:assumptions} on page
\pageref{sect:method:complexity:assumptions} it was assumed that
the \texttt{Diff} and \texttt{Distinct} operators utilised by Pathfinder both
creates 0 tuples and 0 fields, only relaying the input to output. It is
natural to assume that both of these are in fact costly operators in some
aspects. However, given that \texttt{Diff} computes a difference between
result sets, this does not imply that it creates new tuples and/or fields.
Furthermore, the \texttt{Distinct} operator only removes duplicates, and as
such it should be safe to assume that it does not generate new tuples and/or
fields. This implies that these assumptions may favour Pathfinder, but likely
not in the context of the method for calculation of complexity used here.

Furthermore, it is natural to assume that Pathfinder generates algebra
which is tailored for execution on the MonetDB database system (as indicated
in \cite{pathfinder_purelyRelational}).

With regards to performance measurement, and with the lack of availability of a
proper implementation of a MQL processor (as mentioned in section
\ref{sect:method:mql} on page \pageref{sect:method:mql}), it could have been
of interest to generate algebra using TD modified for MonetDB, and compare
actual performance of loop lifting vs. TD on this database system. This notion
is further detailed in section \ref{chapter:future}.

Finally, it is important to note that the complexity comparison performed did
not in any way account for disk I/O or CPU and memory usage, and the results
must not be interpreted as such. Again, see section \ref{sect:method:complexity} on
page \pageref{sect:method:complexity} for an detailed account of this method.

\subsection{Loop Lifting vs Tainting Dependencies}
\label{sect:disc:llvsTD}
This project has studied two approaches for translating XQuery to relational
algebra; loop lifting as implemented by Pathfinder, and ``Tainting
Dependencies'' (TD), which is a novel method developed in this project which
still shares a few common traits with loop lifting. However, the motivation for
the development of TD was the fact that the more expressive MQL algebra allowed
more flexibility in the translation. Furthermore, loop lifting had the
disadvantage of full denormalisation, as noted in
\cite{pathfinder_purelyRelational}: 

\begin{quote}
[..] loop lifting consequently leads to a fully denormalised representation for
$e$ and thus to -- at least potentially -- significant data redundancy
\end{quote}

And so a major motivation for the development of TD was avoiding this level of
denormalisation.

Another common trait of loop lifting, which is also noted in
\cite{pathfinder_mothertongue} and \cite{pathfinder_purelyRelational}, is that
the algebra trees will quickly grow very large. Consider the example in section 
\ref{sect:trans:ll:example} on page \pageref{sect:trans:ll:example}; here, the
intermediate results grow in size very quickly. In particular, they are
comparatively large seen in the context of the trivial query they are produced
from.

When the algebra trees generated by loop lifting are converted to DAGs, this
trait may not seem so appareant. However, it is easily recognised by the fact
that nodes with more than one parent often are located in the middle and higher
parts of the tree, for example as seen in figure
\ref{fig:result:comparison:conditional_pathfinder_dag} on page
\pageref{fig:result:comparison:conditional_pathfinder_dag}. If this particular
DAG was converted to a tree, it would indeed be substantially larger.

Further, when comparing the rules in loop lifting (described in
\cite{pathfinder_mothertongue}) and TD, it appears that TD will in most cases
produce less operators and less complex trees than loop lifting, as well as
substantially smaller intermediate results. This comparison does not consider
simplifications, however. In some situations, especially for trivial queries,
optimised loop lifting trees \emph{may} perform better than unoptimised TD. 

\subsection{Considerations for executing MQL}
The ``Tainting Dependencies'' method produces relatively simplistic algebra
when compared to the full feature set of MQL. In section \ref{sect:method:mql},
only the operators used throughout this project was described. However, this is
only a subset of the features in MQL. This was done with the intent of creating
algebra which can be optimised using common techniques already available.
Introducing new and exotic operators complicates this process, and so this was
avoided. However, in the light of the expressiveness available in MQL, it may
be benefitial to employ a wider array of operators available when constructing
MQL algebra. In any case, this requires further documentation and concrete
performance measurements.