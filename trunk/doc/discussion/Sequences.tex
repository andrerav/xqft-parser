\section{XQuery Sequences}
\label{sect:disc:singelton}

There is no distinction between an item, that is, a node or an atomic value, and a singleton sequence containing
that item in XQuery. An item is equivalent to a singleton sequence containing that item and vice versa. A sequence
may contain nodes, atomic values, or any mixture of nodes and atomic values. But it may be advantageous for a
translator to differentiate singleton sequences from other sequences. 

As we saw in section \ref{sect:trans:TD:simplifications}, by knowing that all subexpressions return singleton
sequences, the translation of the sequence construction expression may be simplified. If the \texttt{return}
clause expression is a singleton sequence the translation of iterator ordered FLWOR expressions may also be
simplified. If the FLWOR only contains only one iterator and no \texttt{where}-clause the renumbering can be
replaced by a renaming of the $-numb$ field corresponding to the iterator to $index$. Understanding that this
works can be done by considering the rule for translation of iterator ordering (rule \ref{rule:trans:TD:itOrd}).
As the \texttt{return}-clause is a singleton, the $index$ fields will have the constant value 1. $\beta$ will
contain only one $-numb$ attribute, holding information of which iteration the value in $value$ occurs. The
iteration number will then become the $index$ field of the sequence created by the FLWOR.

Some expressions, such as arithmetic expressions, \texttt{order by} expressions and value comparisons, require
their subexpressions or operands to be singleton sequences. This means that a query such as \texttt{(1, 2) + 3}
will raise a type error. By having the knowledge of the cardinality of the sequence returned to such an
expression, the translator may raise the error, and avoid a faulty query being run on the MQL processor.
Evaluating the cardinality of seqences returned from expressions is in many cases a simple task. Some expressions
will always return singletons, such as logical, comparison and aritmetic expressions, iterator variable references
and litterals. The cardinality of sequences constructed of such expressions may also be calculated in the
translator. A proplem arises, however, when dynamic content (not from the query itself) is included. Consider the
following query:

\begin{center}
\begin{tabular}{l}
\texttt{for \$a in doc("persons.xml")//person/} \\
\texttt{order by \$a/surname} \\
\texttt{return \$a}
\end{tabular}
\end{center}

As previously stated, the \texttt{order by} expression only accepts singletons. If the document contains a
\texttt{person} element containing two \texttt{surename} elements the query should fail. The translator does
however not have the ability to evaluate if a type error should be raised or not. The query stated will, without a
check for multiple \texttt{surname} elements per \texttt{person}, result in a sequence where the \texttt{person}
elements containing more than one \texttt{surname} element will occur more than one time. 

The promblem lies in the fact that the query is not a erroneous MQL query, but a erroneous XQuery query. One
solution would be to implement a check in MQL, which would inform the MQL processor of any potential error. This
can be done e.g. by a MQL function \textsf{raiseError()}, which would abort the evaluation of the query and e.g.
throw an exception. As all items in the relational representation of sequences in Tainted Dependencies are marked
with their position within the sequence with the $index$ field. One way to check if an expression $e$ does not
return a singleton sequence can be the following:
\begin{center}
\begin{tabular}{l}
\textsf{select(ifthenelse(eq(index, 1), true, raiseError());} \\ \quad
\textbf{r(}$e$\textbf{)}\textsf{)}
\end{tabular}
\end{center}

The check may of course be omitted if the translator is sure, by the means discussed earlier, $e$ will return a
singleton.

\subsection{Effective Boolean Value - {MADS}}
\label{sect:disc:effBool}
Under certain circumstances it is necessary to find the effective boolean value of a sequence. The effective
boolean value is by W3C defined as follows\cite{w3c00}: 
\begin{quote}
The effective boolean value of a value is defined as the result of applying the \texttt{fn:boolean} function to
the value.
\end{quote}

Where the dynamic semantics of \texttt{fn:boolean(\$arg as item()*) as xs:boolean} are defined as
follows\cite{w3cfuncOps}:

The effective boolean value of a sequence is defined as the
result returned from the XQuery function \texttt{fn:boolean} executed with the sequence as a operand:
\begin{itemize}
  \item If \$arg is the empty sequence, \texttt{fn:boolean} returns \textit{false}.
  \item If \$arg is a sequence whose first item is a node, \texttt{fn:boolean} returns \textit{true}.
  \item If \$arg is a singleton value of type \texttt{xs:boolean} or a derived from \texttt{xs:boolean},
  \texttt{fn:boolean} returns \$arg.
  \item If \$arg is a singleton value of type \texttt{xs:string} or a type derived from \texttt{xs:string},
  \texttt{xs:anyURI} or a type derived from \texttt{xs:anyURI} or \texttt{xs:untypedAtomic}, \texttt{fn:boolean}
  returns \textit{false} if the operand value has zero length; otherwise it returns \textit{true}.
  \item If \$arg is a singleton value of any numeric type or a type derived from a numeric type,
  \texttt{fn:boolean} returns \textit{false} if the operand value is \texttt{NaN} or is numerically equal to zero;
  otherwise it returns \textit{true}.
  \item In all other cases, \texttt{fn:boolean} raises a type error.
\end{itemize}



\textbf{\LARGE TODO: {MADS}}
\begin{itemize}
\item VI M\AA~SJEKKE ATOMIZATION.
\item Effective Boolean Value
\item Kommer til \aa~bli feil n\aa r en sekvens blir brukt som boolean value n\aa~s\aa fremt vi ikke kan groupe\ldots
\item En evt groupingoperator m\aa~slippe igjennom tall\ldots. Evt select index=1, m\aa~se om (1,2,3) er bogus
\item The translator is in the logical context, $\Lambda$, if the AST node it is currently visiting is a successor
of a boolean operator or within the condition part of an \texttt{if..then..else} expression. In all other cases the
translator is in the default context, $\Delta$. If no context is mentioned in the inference rules the default
context is assumed. 
\item test expr i if
\item barna til and og or
\item hva med path expressions med ikketreff?
\end{itemize}

\textbf{\LARGE TODO: {MADS}}
\begin{itemize} 
   \item In some cases, a processor can determine the result of an expression without accessing all the data that
   would be implied by the formal expression semantics. For example, the formal description of filter expressions
   suggests that \$s[1] should be evaluated by examining all the items in sequence \$s, and selecting all those
   that satisfy the predicate position()=1.
\end{itemize}

fra 2.3.4 \cite{w3c00}
\begin{quote}
Consider an expression Q that has an operand (sub-expression) E. In general the value of E is a sequence. At an
intermediate stage during evaluation of the sequence, some of its items will be known and others will be unknown.
If, at such an intermediate stage of evaluation, a processor is able to establish that there are only two possible
outcomes of evaluating Q, namely the value V or an error, then the processor may deliver the result V without
evaluating further items in the operand E. For this purpose, two values are considered to represent the same
outcome if their items are pairwise the same, where nodes are the same if they have the same identity, and values
are the same if they are equal and have exactly the same type.

There is an exception to this rule: If a processor evaluates an operand E (wholly or in part), then it is required
to establish that the actual value of the operand E does not violate any constraints on its cardinality. For
example, the expression \$e eq 0 results in a type error if the value of \$e contains two or more items. A processor
is not allowed to decide, after evaluating the first item in the value of \$e and finding it equal to zero, that the
only possible outcomes are the value true or a type error caused by the cardinality violation. It must establish
that the value of \$e contains no more than one item.
\end{quote}
