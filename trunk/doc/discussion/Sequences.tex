\section{XQuery Sequences}
\label{sect:disc:singelton}

There is no distinction between an item, that is, a node or an atomic value, and a singleton sequence containing
that item in XQuery. An item is equivalent to a singleton sequence containing that item and vice versa. A sequence
may contain nodes, atomic values, or any mixture of nodes and atomic values. But it may be advantageous for a
translator to differentiate singleton sequences from other sequences. 

As we saw in section \ref{sect:trans:TD:simplifications}, by knowing that all subexpressions return singleton
sequences, the translation of the sequence construction expression may be simplified. If the \texttt{return}
clause expression is a singleton sequence the translation of iterator ordered FLWOR expressions may also be
simplified. If the FLWOR only contains only one iterator and no \texttt{where}-clause the renumbering can be
replaced by a renaming of the $-numb$ field corresponding to the iterator to $index$. Understanding that this
works can be done by considering the rule for translation of iterator ordering (rule \ref{rule:trans:TD:itOrd}).
As the \texttt{return}-clause is a singleton, the $index$ fields will have the constant value 1. $\beta$ will
contain only one $-numb$ attribute, holding information of which iteration the value in $value$ occurs. The
iteration number will then become the $index$ field of the sequence created by the FLWOR.

Some expressions, such as arithmetic expressions, \texttt{order by} expressions and value comparisons, require
their subexpressions or operands to be singleton sequences. This means that a query such as \texttt{(1, 2) + 3}
will raise a type error. By having the knowledge of the cardinality of the sequence returned to such an
expression, the translator may raise the error, and avoid a faulty query being run on the MQL processor.
Evaluating the cardinality of seqences returned from expressions is in many cases a simple task. Some expressions
will always return singletons, such as logical, comparison and aritmetic expressions, iterator variable references
and litterals. The cardinality of sequences constructed of such expressions may also be calculated in the
translator. A proplem arises, however, when dynamic content (not from the query itself) is included. Consider the
following query:

\begin{center}
\begin{tabular}{l}
\texttt{for \$a in doc("persons.xml")//person/} \\
\texttt{order by \$a/surname} \\
\texttt{return \$a}
\end{tabular}
\end{center}

As previously stated, the \texttt{order by} expression only accepts singletons. If the document contains a
\texttt{person} element containing two \texttt{surename} elements the query should fail. The translator does
however not have the ability to evaluate if a type error should be raised or not. The query stated will, without a
check for multiple \texttt{surname} elements per \texttt{person}, result in a sequence where the \texttt{person}
elements containing more than one \texttt{surname} element will occur more than one time. 

The promblem lies in the fact that the query is not a erroneous MQL query, but a erroneous XQuery query. One
solution would be to implement a check in MQL, which would inform the MQL processor of any potential error. This
can be done e.g. by a MQL function \textsf{raiseError()}, which would abort the evaluation of the query and e.g.
throw an exception. As all items in the relational representation of sequences in Tainted Dependencies are marked
with their position within the sequence with the $index$ field. One way to check if an expression $e$ does not
return a singleton sequence can be the following:
\begin{center}
\begin{tabular}{l}
\textsf{select(ifthenelse(eq(index, 1), true, raiseError());} \\ \quad
\textbf{r(}$e$\textbf{)}\textsf{)}
\end{tabular}
\end{center}

The check may of course be omitted if the translator is sure, by the means discussed earlier, $e$ will return a
singleton.

\subsection{Effective Boolean Value - {MADS}}
\label{sect:disc:effBool}
Under certain circumstances it is necessary to find the effective boolean value of a sequence. The effective
boolean value is by W3C defined as follows\cite{w3c00}: 
\begin{quote}
The effective boolean value of a value is defined as the result of applying the \texttt{fn:boolean} function to
the value.
\end{quote}

Where the function is declared as \texttt{fn:boolean(\$arg as item()*) as xs:boolean} and the dynamic semantics are
defined as follows\cite{w3cfuncOps}:

\begin{enumerate}
  \item If \texttt{\$arg} is the empty sequence, \texttt{fn:boolean} returns \textit{false}.
  \item If \texttt{\$arg} is a sequence whose first item is a node, \texttt{fn:boolean} returns \textit{true}.
  \item If \texttt{\$arg} is a singleton value of type \texttt{xs:boolean} or a derived from \texttt{xs:boolean},
  \texttt{fn:boolean} returns \$arg.
  \item If \texttt{\$arg} is a singleton value of type \texttt{xs:string} or a type derived from \texttt{xs:string},
  \texttt{xs:anyURI} or a type derived from \texttt{xs:anyURI} or \texttt{xs:untypedAtomic}, \texttt{fn:boolean}
  returns \textit{false} if the operand value has zero length; otherwise it returns \textit{true}.
  \item If \texttt{\$arg} is a singleton value of any numeric type or a type derived from a numeric type,
  \texttt{fn:boolean} returns \textit{false} if the operand value is \textit{NaN} or is numerically equal to zero;
  otherwise it returns \textit{true}.
  \item In all other cases, \texttt{fn:boolean} raises a type error.
\end{enumerate}

In the chapter presenting Tainting Dependencies, chapter \ref{sect:translation}, we solved resolving the effective
boolean value of sequences with the help of an assumed MQL function \textsf{xqBoolean()} and an undefined abstract
function \textbf{B()}. In that chapter we said it was enough to consider it as a grouping function returning one
tuple per unique iteration (as implied by the iterator dependencies). The points 3-5 of the definition of the
effective boolean value are all handled by \textsf{xqBoolean()} without promblems, as they all concern singleton
sequences. Points 2 and 6 togheter, however, creates a interesting situation. They imply that when finding the
effective boolean value of all possible XQuery sequences, all should cause an error, except the sequences where a
node is the first element, regardless of the other items in the sequence.

This means that a simple check as proposed for evaluating the cardinality of operands for e.g. arithmetic
expressions earlier in this section will not do. A possible solution for the \textbf{B()} function would be to run
a \textsf{group}-operator on the relation, grouping on the unique iterations, and run a \textsf{count} and some
aggregator functions selecting the value and type of the first item of each group. Further, the result will then
have to be checked similar to the check proposed earlier.
\begin{center}
\begin{tabular}{l}
\textsf{select(or(eq(type, node), ifthenelse(eq(count,1), true, raiseError());} \\\quad
\textsf{group((}$e.\vartheta$\textsf{), count(), selProj(eq(index,1), value), selProj(eq(index,1), type);}
\\\quad\quad
\textbf{r(}$e$\textbf{)}\textsf{))}
\end{tabular}
\end{center}
Where \textsf{selProj(}$pred$, $field$\textsf{)} is a kind of selection and projection hybrid, selecting field
$field$ if predicate $pred$ is \textit{true}. Such a aggregator function may however seem strange, and there is
nothing similar implemented in the MQL processor.

An alternative can be to utilise the \textsf{groupby} operator. The semantics of this operator is the same as for
the \textsf{group}-operator, except that the input relation is unchanged and returned as the output. Further, the
result of the grouping is returned as a separate, named relation (``result set'' in MQL lingo). The
\textsf{resultset} operator with the name as its parameter will fetch this named result:

\begin{center}
\begin{tabular}{l}
\textsf{select(and(eq(index,1), or(eq(type,node), ifthenelse(eq(count,1), true, raiseError())))} \\ \quad 
\textsf{hhjoin([}$e.\vartheta$\textsf{], [}$e.\vartheta$\textsf{], [l.value, r.count];} \\ \quad\quad
\textsf{groupby(countrelation, (}$e.\vartheta$\textsf{), count();} \\ \quad\quad\quad
\textbf{r(}$e$\textbf{)}\textsf{);} \\ \quad\quad
\textsf{resultset(countrelation)))}
\end{tabular}
\end{center}

Both solutions assume a typesystem where a field $type$ holds the type of the item represented in the tuple. The
last proposal of a implementation of the \textbf{B()} function only uses operators and functions allready
implemented in the MQL processor. A disadvantage with this solution, however, is that it will probably be more
resource-demanding as it consists of both a grouping and a join.

\textbf{\LARGE TODO: {MADS}}
\begin{itemize}


\item The translator is in the logical context, $\Lambda$, if the AST node it is currently visiting is a successor
of a boolean operator or within the condition part of an \texttt{if..then..else} expression. In all other cases the
translator is in the default context, $\Delta$. If no context is mentioned in the inference rules the default
context is assumed. 
\item test expr i if
\item barna til and og or
\item hva med path expressions med ikketreff? 
\item og andre ting -> slik som or: \$i/maybe or \$i/always, denne vil forsvinne\ldots =/=/ 
\end{itemize}

