% Method / Testing
\section{Testing}
\label{sect:method:testing}
To improve quality insurance in this projects, it was decided to systematically
write tests for new features as well as perform coverage testing for comparison
with existing implementations. This section will outline the various test
methods used in this project. Also see section \ref{sect:results:tests}, where
the test results are presented.

\subsection{gUnit}
\label{sect:method:gUnit}
Unit testing can be a powerful tool for asserting functionality and can be a
helpful aid in debugging and prevention of regression errors.  For unit testing the
grammar specification, gUnit \cite{gunit00} was employed. This tool uses a
syntax similar to Antlr itself, however instead of defining productions, one
defines a set of inputs for some rule, as well as the expected result. Consider
this example:

\begin{Verbatim}
gunit XQFT;
@header{package no.ntnu.xqft.parse;}

piTarget: // Test piTarget rule

    // Any case permutation of 'XML' must fail
    "Xml" FAIL
    "XMl" FAIL
    "XML" FAIL
    "XmL" FAIL
\end{Verbatim}

This is a complete input file for gUnit, and will automatically discover the
classes XQFTLexer and XQFTParser in the package no.ntnu.xqft.parse. gUnit will
then proceed to invoke the lexer with ``Xml'', ``XMl'', ``XML'', and ``XmL'' as
input, and pass the lexer to an instance of XQFTParser and execute the production
piTarget. For all these inputs, it will assert that the parser emits an error
(i.e it must fail to pass the test).

In case of a test where the parser should not fail, the syntax is as follows:
\begin{Verbatim}
forClause:
	"for $a in document(\"abc.xml\")/a/b/text()" OK
\end{Verbatim}
Here gUnit will assert that the parser will not fail for the given inpu (i.e it
must not fail to pass the test).

gUnit is also capable of parsing abstract syntax trees built by the generated
parser, but this feature has not been used in this project.

\subsection{jUnit}
In addition to the gUnit tests for the grammar, jUnit was used to write unit tests for
the additional classes needed for this parser. In particular, the classes
related to scoping and symbol tables. Here is one example, asserting that the
setParent() method in the scope class works as expected:
\begin{Verbatim}
    @Test
    public void testSetParent() {
        this.scope = new Scope();
        Scope tmp = new Scope();
        this.scope.setParent(tmp);
        assertEquals(this.scope.getParent(), tmp);
    }
\end{Verbatim}

\subsection{Manual Coverage Tests}
Finally, we employed manual tests for running the complete XQuery Test Suite\cite{w3c05}
as a benchmark for XQuery compliance. Specifically, we simplified this approach
into counting any test query accepted by the parser as passed. Since the parser
does not generate any results from queries, it was impossible to run a
comparison to the given expected results.

The test suite consists of a total of 12584 different queries with a
corresponding set of expected output. These tests span a large amount of XQuery
functionality. Out of these tests, a total of 10363 tests are applicable for
this project. These tests are categorized as scenarios: \emph{standard}, 
\emph{parse-error}, and \emph{trivial}. The remaining tests are only possible to
perform in run time, and are thus not applicable for this parser at this time.