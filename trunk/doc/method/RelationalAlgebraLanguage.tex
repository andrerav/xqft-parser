\section{Target Relational Algebra Language}
\label{sect:method:mql}
The target algebra for this project is a dialect of relational algebra (see
section \ref{sect:theory:relAlg}) developed by FAST Search \& Transfer. The
language is dubbed MQL (Mars Query Language). This section will describe the
operators of this language as well as the indexes they operate on, and will
demonstrate some important traits of this language with a few examples. 

TODO: kanskje ordne en referanse til FAST p\aa~en eller annen m\aa~te slik at
sensoren kan ordne seg en kopi av mql-dokumentet. Ogs\aa~nevne at greiene var
konfidensielle.

\subsection{General concepts}
\label{sect:method:mql:indexes}
\label{sect:method:mql:concepts}
All queries for MQL are written as strings with a syntax reminiscient of Lisp
dialects. An example query can be seen in figure \ref{figure:mql:op_example}.

\marginpar{\underline{\Large TODO} \footnotesize Valocc er en hypotetisk index, kan sikkert presisere det} 
Data is stored in \textit{indexes} rather than in DOM trees. Naturally, this is a prerequisite for efficient
execution of relational algebra on the data. There are two basic index types: \textit{occurence} indexes and
\textit{value} indexes. In the case of an occurence index, a lookup for a term will map the term to the occurences
of this term. In a \textit{value} index, a key (for example document id) is associated to one or more
\textit{values} in the document collection. Lookups in \textit{value} indexes can be combined with lookups in
\textit{occurence} indexes to add data to the result set for the user.

The schema of the indexes determins the fields/columns in the result sets from
a lookup, but typically these three fields will be included on a lookup of a
term in the \textit{occurence} index:
\begin{itemize}
  \item Document ID: Internal identifier for the document in which the term
  occurs
  \item Position: The term position in the document (counted by terms, not
  characters or nodes)
  \item Scope: the context of the occurence, e.g \texttt{/a/b}. Note that the
  scope also contains metadata about the \textit{instance} of the scope
\end{itemize}


\subsection{Language syntax}
The syntax of MQL (Mars Query Language) is, as mentioned above, reminiscent of
Lisp dialects. Consider the example in figure \ref{figure:mql:op_example}. This
example will lookup the term ``c'' in the scope \texttt{/a/b} in the index
\textit{valocc}\footnote{The index \textit{valocc} is a hypothetical index
which is simply thought to be a combined lookup in an \textit{occurence}
index and a \textit{value} index}.

\begin{figure}[!h]
\centering
\begin{Verbatim}
index(valocc; 
  scope(/a/b;
    lookup(c)));
\end{Verbatim}
\caption{Simple MQL example}
\label{figure:mql:op_example}
\end{figure}

The syntax for MQL can be described in a condensed form using EBNF notation as
can be seen in figure \ref{figure:mql:ebnf}
\begin{figure}[!h]
\centering
\begin{Verbatim}
OPERATORNAME  ::= IDENTIFIER
OPERATOR      ::= OPERATORNAME "(" PARAMETERLIST? 
                  (";" OPERATORLIST)? ")"
OPERATORLIST  ::= OPERATOR ( "," OPERATOR )*
\end{Verbatim}
\caption{Simplified MQL EBNF}
\label{figure:mql:ebnf}
\end{figure}

Note that \texttt{PARAMETERLIST} has no definition. This production will be
described for each operator, if applicable.

Also note that parameters and child operators are separated by a semicolon. For
example, in the MQL expression \texttt{index(valocc;lookup(hairdresser))} the
\texttt{index()} operator is given one parameter (\texttt{valocc}) and one
child operator (\texttt{lookup(hairdresser)}).

\subsection{Operators}
\label{sect:method:marsOperators}
\subsubsection{Lookup}
\label{sect:method:marsOperators:lookup}
The \texttt{lookup()} operator performs a lookup in the default index (if none
other defined by an \texttt{index()} operator, see
\ref{sect:method:marsOperators:index}). The result set returned from this
operator contains all occurences of the given term, if any. This operator will
use the last index specified by the \texttt{index()} operator, otherwise the
default index. See figure \ref{figure:mql:op_example} for an example of usage. 

\subsubsection{Scope}
\label{sect:method:marsOperators:scope}
The \texttt{scope()} operator accepts one parameter and one child operator. Informally, the
result set from the child operator is filtered to match the first parameter, which is a
scope given on a form similar to a XPath expression. See figure
\ref{figure:mql:op_example} for an example of usage. 

\subsubsection{Index}
\label{sect:method:marsOperators:index}
This operator modifies the behaviour of the child operator such that any lookup
will use the specified index. See figure \ref{figure:mql:op_example} for an
example of usage where the child operators will operate on the index
\textit{valocc}.

\subsubsection{Project}
\label{sect:method:marsOperators:project}
The \texttt{project()} operator lends its name and semantics from the project operator known from basic relational
algebra (section \ref{sect:theory:relAlg:projection}), as well as the rename operator (section
\ref{sect:theory:relAlg:rename}). The \texttt{project()} operator has a more complex syntax described in EBNF
notation in figure \ref{figure:mql:ebnf:project_ebnf}.

\begin{figure}[!h]
\centering
\begin{Verbatim}
RESULTFIELD  ::= IDENTIFIER
ARGUMENTS    ::= ARGUMENTDEF ( "," ARGUMENTDEF )*
ARGUMENTDEF  ::= ( RESULTFIELD "=" )? ARGUMENT
RETAIN_PARAM ::= "retain:=" BOOLEAN
OPERATOR     ::= "project" "(" (RETAIN_PARAM ",")? 
                 ARGUMENTS ";" OPERATOR ")"
\end{Verbatim}
\caption{Project operator EBNF}
\label{figure:mql:ebnf:project_ebnf}
\end{figure}
Consider the trivial example in \ref{figure:mql:project_example} which is an
extension of the example in figure \ref{figure:mql:op_example}. This will
project the result set on the field \texttt{DocumentID}, and rename it to
\texttt{id}. 

\begin{figure}[!h]
\centering
\begin{Verbatim}
project(id=DocumentID;
  index(valocc; 
    scope(/a/b;
      lookup(c))));
\end{Verbatim}
\caption{Simple MQL \texttt{project()} example}
\label{figure:mql:project_example}
\end{figure}

Note that it is also possible to execute functions and apply constant values to
the projection. The example in figure \ref{figure:mql:project_example2} may
produce an output similar to that of figure
\ref{figure:mql:project_example2_result}.

\begin{figure}[!h]
\centering
\begin{Verbatim}
project(id=DocumentID, cid=max(100,DocumentID), one="1");
  index(valocc;
    scope(/a/b;
      lookup(c))));
\end{Verbatim}
\caption{Simple MQL \texttt{project()} example with inline function call 
and an applied constant field}
\label{figure:mql:project_example2}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tabular}{|c | c | c |}
\hline
$id$ & $cid$ & $one$ \\ \hline
45 & 100 & 1 \\ \hline
103 & 103 & 1 \\ \hline
90 & 100 & 1 \\ \hline
33 & 100 & 1 \\ \hline
289 & 289 & 1 \\ \hline
\end{tabular}
\caption{Hypothetical result of query in figure
\ref{figure:mql:project_example2}}
\label{figure:mql:project_example2_result}
\end{figure}

\subsubsection{Select}
The \texttt{select()} operator filters tuples from the child operator based on
boolean function predicates. Consider the example in figure
\ref{figure:mql:select_example}, where eq() compares the two parameters and
returns \textit{true} if the parameters are equal. A hypothetical result (based
on the example for \texttt{project()}) can be seen in figure
\ref{figure:mql:select_example_result}.

\begin{figure}[!h]
\centering
\begin{Verbatim}
select(eq(100, cid);
  project(id=DocumentID, cid=max(100,DocumentID), one="1");
    index(valocc;
      scope(/a/b;
        lookup(c)))));
\end{Verbatim}
\caption{Simple MQL \texttt{select()} example}
\label{figure:mql:select_example}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tabular}{|c | c | c |}
\hline
$id$ & $cid$ & $one$ \\ \hline
45 & 100 & 1 \\ \hline
90 & 100 & 1 \\ \hline
33 & 100 & 1 \\ \hline
\end{tabular}
\caption{Hypothetical result of query in figure
\ref{figure:mql:select_example}}
\label{figure:mql:select_example_result}
\end{figure}

\subsubsection{Join}
A join operator (one of \texttt{hhjoin()}, \texttt{hljoin()}, or
\texttt{mergejoin()}) performs an equi-join operation as described in section
\ref{sect:theory:relAlg:equiAndThetaJoin}. In the case of a
\texttt{mergejoin()}, the input result set must be sorted. The complete syntax
for any of the join operations can be described with EBNF notation as can be
seen in figure \ref{figure:mql:ebnf:join}.
\begin{figure}[!h]
\centering
\begin{Verbatim}
JOINFIELD    ::= ("left." | "right.")? FIELDNAME
PROJECTFIELD ::= (FIELDNAME "=")? JOINFIELD
PROJECTLIST  ::= PROJECTFIELD ("," PROJECTFIELD)*
JOINNAME     ::= "hhjoin" | "hljoin" | "mergejoin"
OPERATOR     ::= JOINNAME "(" "[" FIELDLIST "]" "," 
                 "[" FIELDLIST "]" "," "[" PROJECTLIST "]"
                  ("," "left" | "right" | "full")? ";"
                  OPERATOR "," OPERATOR ")"
\end{Verbatim}
\caption{Join operator EBNF}
\label{figure:mql:ebnf:join}
\end{figure}
A trivial usage example of the \texttt{mergejoin()} operator can be seen in
figure \ref{figure:mql:mergejoin_example}, where the result sets from two
hypothetical child operators \texttt{Query1()} and \texttt{Query2()} is joined
on their document ids, and the result is projected on the
fields \textit{DocumentID} and \textit{Position}.

\begin{figure}[!h]
\centering
\begin{Verbatim}
mergejoin([DocumentID], [DocumentID], [DocumentID, Position]; 
  Query1(..),
  Query2(..))
\end{Verbatim}
\caption{Simple MQL \texttt{mergejoin()} example}
\label{figure:mql:mergejoin_example}
\end{figure}


\subsubsection{Make}
The \texttt{make()} operator is used to synthesize result sets from the given
(constant) arguments. Field names can be specified, but are not required. The
default field names are \textit{field0}, \textit{field1}, \ldots,
\textit{fieldN}, where \textit{N} is the number of fields. The example in
figure \ref{figure:mql:make_example1} will produce the output seen in figure
\ref{figure:mql:make_example1_result}

\begin{figure}[!h]
\centering
\begin{Verbatim}
make(1,2,3)
\end{Verbatim}
\caption{Trivial MQL \texttt{make()} example}
\label{figure:mql:make_example1}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tabular}{|c | c | c |}
\hline
$field0$ & $field1$ & $field2$ \\ \hline
1 & 2 & 3 \\ \hline
\end{tabular}
\caption{Hypothetical result of query in figure
\ref{figure:mql:make_example1}}
\label{figure:mql:make_example1_result}
\end{figure}

A more complex example can be seen in \ref{figure:mql:make_example2}, where
field names are specified, and several tuples are synthesized. The
corresponding result is shown in figure \ref{figure:mql:make_example2_result}.

\begin{figure}[!h]
\centering
\begin{Verbatim}
make(name:=["A","B","C"], [1,4], [2,5] [3,6])
\end{Verbatim}
\caption{MQL \texttt{make()} example}
\label{figure:mql:make_example2}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tabular}{|c | c | c |}
\hline
$A$ & $B$ & $C$ \\ \hline
1 & 2 & 3 \\ \hline
4 & 5 & 6 \\ \hline
\end{tabular}
\caption{Hypothetical result of query in figure
\ref{figure:mql:make_example2}}
\label{figure:mql:make_example2_result}
\end{figure}

\subsubsection{Group}

\begin{figure}[h]
\begin{Verbatim}
OPERATOR ::= "group" "(" GROUPINGFIELDS ["," AGGREGATORS ] ";" OPERATOR ")"
\end{Verbatim}
\label{figure:mql:groupEBNF}
\caption{Group operator EBNF}
\end{figure}

The notation of the \texttt{group()} operator can be seen in the EBNF sepecification of figure
\ref{figure:mql:groupEBNF}. The operator will group tuples with the same value for the fields specified in
\texttt{GROUPINGFIELDS}, and create one tuple per group. Fields not specified in the operator will not be a part
of the result relation. \texttt{AGGREGATORS} may be used to specify aggregator functions to be run within each
group. The result of an aggregator will be added as a field for the result tuple corresponding to the group it
operated on.

\begin{figure}[h]
\begin{Verbatim}
group((cid), max(id), count(one); Query1)
\end{Verbatim}
\caption{Simple MQL \texttt{group()} example}
\label{figure:mql:groupEx}
\end{figure}

If \texttt{Query1} evaluates to the relation shown in figure \ref{figure:mql:project_example2_result}, the query
of figure \ref{figure:mql:groupEx} will result in the relation of figure HAHAHA.

\begin{figure}[h]
\begin{tabular}{|c|c|c|} \hline
$cid$ & $max$ & $count$ \\ \hline
100 & 90 & 3 \\ \hline
103 & 103 & 1 \\ \hline
289 & 289 & 1 \\ \hline
\end{tabular}
\end{figure}



\subsection{Assumed functionality}
\label{sect:method:marsAddedOperators}

\underline{\LARGE TODO:} idiv($e_1$, $e_2$) -> integer division
TODO: skrive en liten innledning her om hvorfor vi assumer ting.

\subsubsection{isInScope (scope comparison)}
This function (not operator) accepts two arguments which must be scope fields
from index lookups (as described in section \ref{sect:method:mql:indexes}).
This boolean function returns \textit{true} if the first argument has an equal
but deeper path than the second argument, otherwise \textit{false}. This
function is designed to be used in conjunction with the \texttt{select()}
operator as a boolean predicate. See figure \ref{figure:mql:isinscope_example}
for an example of usage.

TODO: eksempelet er kanskje litt jalla

\begin{figure}[!h]
\centering
\begin{Verbatim}
select(isInScope(lscope, rscope);
  mergejoin([DocumentID],[DocumentID], 
            [DocumentID, lscope = left.Scope, rscope = right.Scope];
    lookup(engineer),
    lookup(nurse)))
\end{Verbatim}
\caption{Example of assumed isInScope() functionality}
\label{figure:mql:isinscope_example}
\end{figure}

\subsubsection{xqBoolean/boolean truth value coercion}
This function (not operator) accepts one argument and determines its
\textit{truth value}. XQuery truth values were described in
section \ref{sect:theory:xquery:basics}.

\begin{figure}[!h]
\centering
\begin{Verbatim}
project(truthVal=xqBoolean(B); 
  make(name:=["A","B","C"], [1,4], [0,5] [3,6]))
\end{Verbatim}
\caption{Example of xqBoolean() usage}
\label{figure:mql:xqboolean_example}
\end{figure}

\begin{figure}[!h]
\centering
\mbox{
\subfigure[Input for example in figure
\ref{figure:mql:xqboolean_example}]{
\begin{tabular}{|c | c | c |}
\hline
A & B & C \\ \hline
1 & 0 & 3 \\ \hline
4 & 5 & 6 \\ \hline
\end{tabular}
\label{figure:mql:xqboolean_example_input}
}
\quad
\subfigure[Output from example in figure
\ref{figure:mql:xqboolean_example}]{
\begin{tabular}{| c |}
\hline
truthVal \\ \hline
\textit{false} \\ \hline
\textit{true} \\ \hline
\end{tabular}
\label{figure:mql:xqboolean_example_output}
}
}
\caption{Input/output result sets}
\end{figure}

The semantics of this function is captured in the example in figure
\ref{figure:mql:xqboolean_example}. For the input result set produced by the
\textit{make()} operator in figure \ref{figure:mql:xqboolean_example_input},
the output result in figure \ref{figure:mql:xqboolean_example_output} is
produced. The example converts the integer 5 to \textit{true} and the integer 0
to \textit{false}. 

\subsubsection{Numberation/sequence generator}
\marginpar{\underline{\Large TODO} \scriptsize Dette h\o rtes litt s\ae rt ut. Den group'er p\aa~partitionList,
sorterer p\aa~sortList og s\aa~nummererer. Den er den samme som det st\aa r om i LoopLifttingene, bare at den kan ta flere
partition felter} 
This operator should generate a sequence field from the input result set, optionally restart the
sequence based on field partitioning, and optionally sort the output. The operator accepts three parameters and one child operator; the
three parameters are:
\begin{itemize}
  \item A field name for the generated sequence
  \item An optional list of fields to sort by
  \item An optional list of fields for partitioning
\end{itemize}
The syntax for this operator can be defined in EBNF notation as seen in figure
\ref{figure:mql:numberate_ebnf}.
\begin{figure}[!h]
\begin{center}
\begin{Verbatim}
FIELD         ::= IDENTIFIER
SORTLIST      ::= "[" FIELD ("," FIELD)* "]"
PARTITIONLIST ::= "[" FIELD ("," FIELD)* "]"
OPERATOR      ::= "numberate" "(" FIELD ("," SORTLIST)? 
                  ("," PARTITIONLIST)?  ";" OPERATOR ")"
\end{Verbatim}
  \caption{EBNF definition for the \texttt{numberate()} operator}
  \label{figure:mql:numberate_ebnf}
\end{center}
\end{figure}

\begin{figure}[!h]
\begin{center}
\begin{Verbatim}
numberate(Seq, [A,B], [A];
  make(name:=["A","B"]; [1,1,1,2,2,2], [a,b,c,a,b,c]))
\end{Verbatim}
  \caption{Trivial example of \texttt{numberate()} usage}
  \label{figure:mql:numberate_example}
\end{center}
\end{figure}

\begin{figure}[!h]
\centering
\mbox{
\subfigure[Input]{
\begin{tabular}{| c | c |}
\hline
A & B \\ \hline
1 & a \\ \hline
1 & b \\ \hline
1 & c \\ \hline
2 & a \\ \hline
2 & b \\ \hline
2 & c \\ \hline
\end{tabular}
\label{figure:mql:numberate_example_input}
}
\quad
\subfigure[Output]{
\begin{tabular}{| c | c | c |}
\hline
Seq & A & B \\ \hline
1 & 1 & a \\ \hline
2 & 1 & b \\ \hline
3 & 1 & c \\ \hline
1 & 2 & a \\ \hline
2 & 2 & b \\ \hline
3 & 2 & c \\ \hline
\end{tabular}
\label{figure:mql:numberate_example_output}
}
}
\caption{Input/output result sets}
\end{figure}
The example in figure \ref{figure:mql:numberate_example} illustrates the
behaviour of this operator. In the output result set seen in figure
\ref{figure:mql:numberate_example_output}, a column \texttt{Seq} has been
added, with a sequence which is restarted for each new value of \texttt{A}.
Also note that the input result set is sorted on A then B.

\subsubsection{Union/disjoint union}
The \texttt{union()} operator accepts relations with different schemas, and
does not remove duplicates (disjoint union). The schema for the result relation
can be described as:
\begin{equation*}
schema(\texttt{union(}\alpha, \beta\texttt{)}) = schema(\alpha) \cup
schema(\beta).
\end{equation*}
Alternatively, implementation of these semantics can be done manually by
the translator with the help of \texttt{project()} operators. Specifically,
this can be done by adding fields to the two sets to ensure uniqueness and then
perform a regular union.

hvilke operatorer/ funksjoner har vi lagt til / forutsatt?
\begin{itemize}
  	\item funksjonen \verb!isInScope(a, b)! if a has an equal but deeper path than
		b -> true (same element required) 
	\item isNumber(pred) -> fordi vi ikke har polymorphic type attributes\ldots typesystem igjen\ldots Skal vi
	g\aa~ut ifra at vi har polymorphic type attributes? Og si at type m\aa~bli ordna p\aa~en eller annen m\aa te..
	\item xqBoolean(pred) tom streng, null og teksten ``false''(p\aa~grunn av skrint typesystem) gir \textbf{false}
	\item scopeIndex(scope, pred)\ldots Trenger kanskje ikke allikevel\ldots Vet ikke enn\aa

	\item union
		\begin{itemize}
			  \item noe med schema\ldots virka ikke som thorbj\o rnsen var helt forn\o yd
				  med at v\aa r tenkte \texttt{union} dret i schema og helte p\aa~
				  \texttt{NULL} verdier indiscriminately
			\item This method assumes that the \texttt{union} operator accepts relations with
different schemas, and does not remove duplicates (disjoint union (hva skjer med markering av origin-relation?)).
The schema for the result relation can be described as:
\begin{equation*}
schema(\texttt{union(}\alpha, \beta\texttt{)}) = schema(\alpha) \cup
schema(\beta).
\end{equation*}
Provided this is a
unreasonable task to implement, it can be done manually by the translator with
the help of \texttt{project} operators.		
        \end{itemize}	
\end{itemize}
