\section{STATE}

\subsection{Converting grammar to proper casing}
The ANTLR parser generator can generate parsers and lexers from a single grammar
file. The distinction between terminals and non-terminals is simply a matter of
convention, where terminals are assumed to start with \emph{uppercase} letters,
and non-terminals are assumed to start with \emph{lowercase} letters.

In the grammar specified by the W3C, all the productions (terminals and
non-terminals) all start with uppercase letters. Initially this caused some
confusion, because this grammar naturally generated a very big lexer and a very
small and non-functional parser.

This was mitigated by converting non-terminal productions to start with
lowercase letters.

\subsection{Rewriting the W3C 'dash' operator}
This operator is not supported in Antlr, so it was necessary to rewrite
these productions using \emph{semantic predicates} (see section \ref{sect:antlr:semantic_preds}) where
necessary.

\underline{\textbf{\LARGE //TODO:}} se over dette igjen: /* Thankfully,
in the original specification, the usage of the dash operator was rather sparse
and only used in trivial productions.*/

An example of rewriting the dash operator using semantic predicates:
\begin{verbatim}
// Original production
piTarget : Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'));

// Rewritten production using a semantic predicate
piTarget : n=Name { !$n.getText().equalsIgnoreCase("XML") }?;
\end{verbatim}
The original production can be interpreted as ``piTarget can be a Name, but not
`XML', regardless of character casing''. The syntactic predicate will imitate
this behaviour using the method equalsIgnoreCase(). As can be seen from this
example, a semantic predicate is simply any kind of boolean Java expression.
This is a flexible solution, because the boolean expression can be wrapped in a
method with boolean return type, which for example then can be placed inside a
@members { } clause in the grammar file, or even as a static method in an
external class. This makes it possible to add complex grammar logic without
disturbing grammar brevity, if necessary.

\subsection{Grammar LL(1) conformity}
The grammar specification given by W3C is in a very compact and non-verbose
form, annoted with links to certain constraints and issues that need to be kept
in mind by anyone seeking to write a parser for XQuery and XPath. Here we will
list these constraints and briefly explain their implications for the parser.

\underline{\textbf{\LARGE //TODO:}} W3C spesifikasjonen holder ikke LL(1)

\subsection{Reserved keywords}

\underline{\textbf{\LARGE //TODO:}} dette maa flyttes eller skrives om.

A particular feature in XQuery is the lack of reserved keywords. This creates a
series of problems when a lexer based on the verbatim grammar specification from
the W3C is trying to recognize tokens. The culprit is the ambiguously defined
terminal symbols. Some of the base character tokens intersect with each other
and makes it hard if not impossible for the lexer to distinguish two different
tokens composed of different token fragments with intersecting characters.

One possible solution to this problem was to eliminate ambiguities in the lexer.
This approach was tried by finding and removing duplicate characters from token
fragments, and then generalizing the tokens and adding semantic predicates to
check for illegal and/or missing characters.

\underline{\textbf{\LARGE //ODOT:}} vaar parser har enna reserved keywords, flytte dette til future work?



\subsection{Nested comments}
XQuery allows nested comments, for example:
\begin{verbatim}
(: this is a comment (: this comment is nested :) :)
\end{verbatim}
This is a classic problem in compiler construction, however it can be solved
using standard Antlr syntax, without resorting to custom functions/methods for
consuming input and keeping track of nesting. The original EBNF as specified by
W3C is as follows:
\begin{verbatim}
Comment ::= "(:" (CommentContents | Comment)* ":)"
\end{verbatim}
At first glance, this seems uncomplicated and straight forward, but this grammar
needs to be rewritten to be accepted by an LL parser. A suggestion for a 
solution to this problem was initially found on the Antlr mailing
list\footnote{http://www.antlr.org:8080/pipermail/antlr-interest/2005-July/012967.html},
and we based our implementation on such an approach. This lexer rule will
correctly detect and allow nested comments, and hide them from the parser:
\begin{verbatim}	
Comment : LXQCOMMENTSi 
          (Comment | (COLONSi ~RPARSi)=>COLONSi 
          | (LPARSi ~COLONSi)=>LPARSi 
          | ~(LPARSi | COLONSi | IkkeChar))* 
          RXQCOMMENTSi {$channel=HIDDEN;};
\end{verbatim}

\underline{\textbf{\LARGE //TODO:}} oppdater eksempelet over (NotChar) og semantisk predikat