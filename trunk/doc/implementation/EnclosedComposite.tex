\section{Enclosed Composite Lexer Productions}
\label{sect:rewriteGrammar:enclosedComposite}
The XQuery grammar specifies some non-terminal constructs enclosed by unique symbols, such as \verb!DirPIConstructor! shown in figure \ref{fig:pitarget} These rules often contain tokens that overlap with other terminals, so a benefit is gained from moving the productions to the lexer. However, this means that there will only be generated one token by such a rule. Meaning, if a later step in the parser wants to extract only parts of the construct, it would have to do so manually. 

Our solution to this is to make it possible for lexer productions to emit more than one token. In this way, ambiguities would be solved in the lexer, and the parser would still have access to all terminals it requires.

\begin{figure}[h!]
\begin{Verbatim}
DirPIConstructor ::= "<?" PITarget (S DirPIContents)? "?>"
DirPIContents    ::= (Char* - (Char* '?>' Char*))
\end{Verbatim}
\label{fig:pitarget}
\caption[An enclosed production]{\texttt{DirPIConstructor} is an uniquely enclosed production. \texttt{S} denotes whitespace.}
\end{figure}

In addition to \verb!DirPIConstructor!, the grammar specifies other non-terminals with an enclosed content: \verb!Pragma!,  \verb!DirCommentConstructor! (XML comment) and \verb!CDataSection!. \verb!Comment! (XQuery comment) has the special property of being able to be nested, but because it is a terminal itself it does not need to generate more than one token.

\subsection{Emiting More Than One Token Per Production}
\label{sect:implementation:emittingMoreTokens}
As can be seen in figure \ref{fig:nextToken}, by default an ANTLR generated
lexer will only emit one token per lexer production. To be able to handle
multiple token emissions, we introduced a buffer in the lexer out of which the
parser input \verb!TokenStream! could fetch tokens. By overriding the methods
\verb!nextToken()! and \verb!emit(Token t)! we accomodated for this.  


As seen in figure \ref{fig:emitToken}, our implemented \verb!emit(Token t)!
will put the token \verb!t! in the buffer and set the \verb!token! variable of the lexer to \verb!t!, to block it from emitting unwanted tokens (see \verb!if(token == NULL)! in figure \ref{fig:nextToken}).
\begin{figure}[h!]
\begin{Verbatim}
public void emit(Token token){
  this.token = token;
  tokens.add(token);
}
\end{Verbatim}
\caption[The overridden \texttt{emit(Token t)}]{The implementation of the overriden method \texttt{emit(Token token)}}
\label{fig:emitToken}
\end{figure}

The \verb!nextToken()! method is modified to pick tokens from the buffer, that is, if there are any there. If there are not, it will ask the lexer to make one as before, and return the first one generated. This is shown in figure \ref{fig:newNextToken}. To be able to use the token generating capabilities of \verb!emit()! we also introduced a method \verb!prepareSubToken()! which ensures that the token will contain correct information about its position.

\begin{figure}[h!]
\begin{Verbatim}
public Token nextToken(){
  if(tokens.size() > 0)
    return tokens.remove(0);
  super.nextToken();
  if(tokens.size()==0 )
    return Token.EOF_TOKEN;
  return tokens.remove(0);
}
\end{Verbatim}
\caption[The overridden \texttt{nextToken()}]{The implementation of the overriden method \texttt{nextToken()}}
\label{fig:newNextToken}
\end{figure}


\subsection{PI, Pragma, XMLComment and CDATA Sections}

\begin{figure}[h!]
\begin{Verbatim}
DirPIConstructor : {prepareSubToken();}
                   LPISi                 {type=LPISi; emit();}
                   {prepareSubToken();}
                   PiTarget           {type=PiTarget; emit();}
                   (S
                     {prepareSubToken();}
                     d=DirPiContents
                     {if(d!=null){type=DirPiContents; emit();} 
                     } 
                   )?
                   {prepareSubToken();}
                   RPISi                 {type=RPISi; emit();}
                   ;
    fragment LPISi           : '<?';
    fragment DirPiContents   : (
                                 {(input.LA(2)!='>')}?=>
                                 QUESTIONSi 
                                 | ~(NotChar | QUESTIONSi)
                               )*;
    fragment RPISi           : '?>';
\end{Verbatim}
\caption[\texttt{DirPIConstructor} emitting subtokens]{The implementation of \texttt{DirPIConstructor} with subtoken emitting capabilities.}
\label{fig:pragmaLEX}
\end{figure}

As previously mentioned, the XML markup features processing instructions, pragmas, comments and CDATA sections contain terminals which allowed content overlap significantly with other terminals. However, these terminals are enclosed in unique symbols, making it possible to declare the non-terminal rules which refer to them as lexer productions. And with the subtoken emitting functionality described in the last section, the parser will still be able to distinguish the terminals. 

We implemented \verb!DirPIConstructor! as shown in figure \ref{fig:pragmaLEX}. As explained in section \ref{sect:antlr:lexer}, ANTLR will generate a method \verb!mDirPIConstructor! from this production. This implies that all actions added will be performed somewhere within \verb!"predict type"! of figure \ref{fig:nextToken}. There will, however, not be generated any \verb!DirPIConstructor! token because of our overridden \verb!emit(Token t)!.

Because the \verb!DirPIContents! part is optional, the lexer has to check if it is there before emitting such a token. This rule is, as seen in the figure, implemented non-greedy with the help of a gated semantic predicate. Thus it will stop matching characters as soon as it sees the end of the processing instruction -- \verb!?>!. \verb!S! denotes whitespace and will not be emitted as it is not surrounded by \verb!prepareSubToken()! and \verb!emit()!.

\subsection{Nested XQuery Comments}
XQuery allows nested comments, for example:
\begin{Verbatim}
(: this is a comment (: this comment is nested :) :)
\end{Verbatim}
This is a classic problem in compiler construction, however it can be solved using standard ANTLR syntax, without resorting to custom functions/methods for consuming input and keeping track of nesting. The original EBNF as specified by W3C is as follows:
\begin{Verbatim}
Comment ::= "(:" (CommentContents | Comment)* ":)"
\end{Verbatim}
At first glance, this seems uncomplicated and straight forward, but this
grammar needs to be rewritten to be accepted by an LL parser. A suggestion for a solution to a similar problem was initially found on the ANTLR mailing list\footnote{http://www.antlr.org:8080/pipermail/antlr-interest/2005-July/012967.html}, and we loosely based our implementation on this approach. Figure \ref{fig:nestedComment} shows the lexer rule that will correctly detect and allow nested comments, and hide them from the parser.
\begin{figure}[h!]
\begin{Verbatim}
Comment   : LXQCOMMENTSi 
           ({(input.LA(1)=='(' && input.LA(2)==':')}?Comment 
           | {input.LA(2)!=')'}?=>COLONSi
           | {input.LA(2)!=':'}?=>LPARSi
           | ~(LPARSi | COLONSi | NotChar))*
            RXQCOMMENTSi; {$channel=HIDDEN;}
    fragment LXQCOMMENTSi     : '(:';
    fragment RXQCOMMENTSi     : ':)';
\end{Verbatim}
\label{fig:nestedComment}
\caption[The implementation of nested comments]{The implementation of nested comments.}
\end{figure}

In this figure the disambiguating semantic predicate on the second line can be understood as ``if it looks like a comment, it is a comment". The gated semantic predicates on the third and fourth line guards the production from being greedy, i.e. they hide the posibility of matching a \verb!:! if it is followed by a \verb!)!, and hide \verb!(! if it is followed by a \verb!:!. By using \verb!$channel=HIDDEN!, ANTLR will put this token in an different virtual channel than the default one, making it invisible for the parser unless explicitly asked for. 

