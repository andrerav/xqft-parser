\section{Reducing Lookahead}
\label{sect:implementation:reduceLookahead}
To be sure that the lexer's state always is the right one according to the context, the lexer's lead over the parser in the input stream should be held to a minimum. Remember, the parser looks ahead with the tokens generated by the lexer, meaning the latter will always be ahead or on the same level as the former.

A LL parser is often expressed as being LL($k$), where $k$ is a positive integer defining the number of tokens lookahead the parser utilizes at a maximum. ANTLR supports a grammar option \verb!k! analogous with the $k$ in LL($k$). By not using this option, and using the W3C specification only including the changes mentioned earlier in this chapter and accomodating for the extra-grammatical constraints we will discuss in \ref{sect:implementation:extraGrammatical}, ANTLR will generate an LL(16) parser. Even with the \verb!k! of the grammar defined to a finite value, syntactic and semantic predicates can be used to look further than $k$ tokens ahead. 

Setting \verb!k! to $1$ creates too many non-determinisms for us to mend for in a timely fashion for this project, leading us to implement a LL(2) parser. The first step in achieving this was extensive left factoring of all productions applicable. An example of this is seen in figure \ref{fig:w3cUnfactored} which shows the orginal productions as specified by W3C, and in figure \ref{fig:antlrFactored} which shows the corresponding productions as they appear in our ANTLR grammar after left factoring. It is worth noticing that a parser matching \verb!Prolog! as defined by W3C needs at least 2, and at most 3 tokens lookahead to differentiate the alternatives.

\begin{figure}[h!]
\begin{Verbatim}
Prolog              ::= ((...| Setter |...) ";")* 
                        ((...| FunctionDecl |...) ";")*
Setter              ::= BoundarySpaceDecl | DefaultCollationDecl 
                      | EmptyOrderDecl |...
BoundarySpaceDecl   ::= "declare" "boundary-space" ...
DefaultCollationDecl::= "declare" "default" "collation" ...
EmptyOrderDecl      ::= "declare" "default" "order" ...
FunctionDecl        ::= "declare" "function" ...
\end{Verbatim}
\label{fig:w3cUnfactored}
\caption[\texttt{Prolog} as defined by W3C]{A simplified representation of \texttt{Prolog} as defined by W3C.}
\end{figure}

\begin{figure}[h!]
\begin{Verbatim}
prolog @init{boolean start = true;}
                    :(
                       (...
                        |DECLARE (
                           setter {start}?
                          |functionDecl {start=false;}
                          |...)
                       )
                     SEMICOLONSi )* ;
setter              : DEFAULT (
                        ...
                        | defaultCollationDecl
                        | emptyOrderDecl )
                    | boundarySpaceDecl
                    | ... ;
emptyOrderDecl      : ORDER ...;
boundarySpaceDecl   : BOUNDARYSPACE ...;
defaultCollationDecl: COLLATION ...;
functionDecl        : FUNCTION ...;
\end{Verbatim}
\label{fig:antlrFactored}
\caption[\texttt{Prolog} left factored.]{A simplified representation of a left factored \texttt{Prolog} as it is implemented in our ANTLR grammar.}
\end{figure}

The boolean variable \verb!start! in our version of \verb!prolog! is employed to make sure that e.g. a \verb!emptyOrderDecl! appear before a \verb!funtionDecl! in the parsed query, as required by the W3C specification. If this is not the case, \verb!setter!'s subsequent validating semantic predicate will fail and throw an exception. This had to be done to allow productions such as \verb!functionDecl! to be brought into the left factoring.

Other productions with non-determinisms were not solvable with left factoring when lookahead is resticted to 2 tokens. These ambiuities became especially apparent when we converted the grammar to one without reserved keywords, and were solved by our terminal/non-terminal implementation of \verb!qName! as reviewed in section \ref{sect:rewritegrammar:keywordNCName}, or by augmenting the productions with syntactic predicates as we will see in the next section.
