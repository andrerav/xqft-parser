\chapter{Conclusion}
\label{chapter:conclusion}

In the course of this project we have investigated the current state of XQuery
implementations (with and without full-text extensions) as well as XQuery as a
language. In addition we have examinated and evaluated multiple parser
generators suitable for a project based on our requirements, and finally chose
ANTLR. Features of interest as well as limitations of this parser generator
were also documented.

The reason for choosing ANTLR was firstly because it utilizes a grammar
specification syntactically close to the EBNF W3C makes use of. In addition,
the parser generator supports various types of predicates and automatic
abstract syntax tree generation -- features which are convenient when
creating more than a non-trivial recognizer.   

Rewriting the XQuery full-text specification to conform to ANTLR grammar syntax
and semantics proved to be a non-trivial task. This is because the
specification contains ambiguous terminals. An LL lexer capable of handling
these must be aware of the context the incoming characters. We evaluated a
number of different approaches to this.

After implementing a prototype state driven lexer for a subset of XQuery, we
discovered that only a few states would be needed to solve the non-determinism.
Additionally we found that by making the parser communicate the state to the
lexer, the implementation would be less complex. To make this work we had to
implement functionality in the lexer to generate tokens one by one, overriding
the default manner of operation. A great deal of the terminal ambiguities were
solved by this parser controlled state driven strategy. The remainding problems
were solved by converting some non-terminals to enclosed composite terminals.  

Because of the chosen lexer strategy, a goal was to reduce required parser
lookahead. A low lookahead combined with XQuery's property of being free of 
reserved keywords created a number of non-determinsisms. These were solved by
left factoring and augmenting the grammar with predicates guiding the parser. 

Using grammar rewrite rules and rewrite operators, the parser produces an AST
well suited for further data flow analysis and transformation. The AST can be
structured at will, simply by changing the rewrite rules and regenerating and
recompiling the parser.   

A simplistic system for scoping and symbol tables was developed and implemented
in the parser by adding action code to the grammar file. This system would be
more useful and extendable if it was re-implemented to operate on an AST
instead of inlining it in the generated parser. This would also make it
possible to integrate scoping and symbol table with a future type inference
system.     

We implemented a test harness for executing detailed compliance tests based on
the official XQuery test suite\cite{w3c05}. These tests are meant for XQuery
1.0 and not the full-text extension. It is believed, however, that they are a
good indicator of the degree of compliance with the W3C specification. The parser
failed on 84 of the 12478 test queries applicable. The causes of the failed
tests are accounted for, and possible solutions are presented. 

As as response to the task description, this project fulfills the requirements
stated. We have developed a XQuery parser in Java under a BSD license. It
accommodates for the full-text extensions specified by W3C. The parser is
capable of generating abstract syntax trees and has a XQuery test suite test
compliance of 99.3\%\footnote{As noted and emphasized in
section\ref{sect:discussion:coverageResults}, these results are not immediately
comparable with officially published results from the W3C}.
