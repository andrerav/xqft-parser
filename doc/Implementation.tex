\chapter{Implementation}
\label{chapter:implementation}

The main part of implementing the parser was to rewrite the EBNF provided by
W3C in \cite{w3c01} to conform to ANTLR's syntax and semantics. Because of the
ambiguous terminals described in section \ref{sect:ambiguousgrammar:ambigTerm}
this was not a trivial task. In the following chapter we will explain this
was solved. Further, we will detail how we reduced the required parser
lookahead and implemented a parser that mangages a language without reserved
keywords. Finally, we will explain how we augmented the grammar to output a
usable AST, and how we implemented scoping and symbol tables.

\input{implementation/AntlrSyntax}
\input{implementation/DiffNCNameKeyword}
\input{implementation/ParserControlled}
\input{implementation/EnclosedComposite}
\input{implementation/ReduceLookahead}
\input{implementation/ReservedKeywords}
\input{implementation/ExtraGrammatical}
\input{implementation/CreateAST}
\input{implementation/ScopingAndSymbol}
\input{implementation/ErrorHandling}
\input{implementation/CoverageTests}

\section{Summary}
In this chapter we have explain how we adapted the W3C
XQuery Full-text specification to ANTLR syntax and semantics. We adapted and
modified the specification rather than creating our own from scratch. Otherwise
we risked missing out essential latent meaning as well as keeping to planned
time frames, as discussed further in section \ref{sect:discussion:adaptW3C}.    

By choosing to implement an ``parser controlled state driven'' lexer, almost all
terminal productions  had to be completly rewritten, and also lead to the
introduction of the \verb!TOKENSWITCH! construct. This could be avoided by
implementing e.g. a "scan-while-parse" type lexer, but such a lexers
corresponding parser would have been much more complex and would handle a much
bigger load than that of our implementation. A more viable alternative would be
the "island grammars" strategy, but since ANTLR does not support this natively we
rejected this alternative. In section \ref{sect:discussion:designDecisions} we
further discuss and evaluate our choice of lexer strategy.

We also implemented enclosed composite lexer productions which removed a great
deal of terminal ambiguities by moving the whole referring non-terminal rule
into the lexer. The container tokens were introduced to lessen the strain on
the parser.

The lexer strategy we have chosen depends on the required parser lookahead to
be held low. Because of this we employed different means of lowering it such as
left factoring and augmenting productions with syntactic predicates. An ideal
parser would have $k=1$, but as we will discuss in section
\ref{sect:discussion:lookahead}, this is not possible for the current version
of XQuery.

W3C specifies some extra-grammatical constraints for XQuery full-text. Our parser
complies with a majority of these, however, there are still some
unconformities, as discussed in section \ref{sect:future:knownBugs}.  

We have utilized AST rewrite rules and operators to make
ANTLR generate a complete AST shaped after these rules and operators. We also
examined several XQuery constructs such as FLWOR and path expressions and how
the AST could be generated for these.

Further we have implemented symbol tables and scoping by adding simple action
code to the grammar and constructing classes for representing scopes, symbol
tables and symbols. We discovered that it was simple to add the inline action 
code in the grammar to extend the parser with these features, however it may
seem like this is affecting readability and clarity of the grammar. In the next
chapters this issue will be further examined and discussed.

As we now have seen how the parser was implemented, in the next chapter we will
ses how it performs, in particular with regards to coverage test results, AST
output, and error handling.