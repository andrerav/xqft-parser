\subsection{FLWOR Expressions}
\label{sect:trans:TD:simpleFLWOR}
The \texttt{let} clause does not cause any dependencies, only variable binding, and can therefore be translated
into storing the algebraic version of the expression to be bound in the symbol table:
\begin{equation}
\frac{}{\mbox{\texttt{let \$}}\chi \mbox{\texttt{ := }}e \mbox{\texttt{ \ldots}}}\longmapsto
\mbox{\textbf{put(}}\chi\mbox{\textbf{, r(}}e\mbox{\textbf{))}}
\label{rule:trans:TD:letbind}
\end{equation}
The iterator dependences $e.\vartheta$ is stored along with \textbf{r(}$e$\textbf{)} and will piggyback this
algebra tree if it later fetched from the symbol table. If there is more than one variable binding in the
\texttt{let} clause the rule must be applied once per binding as if one binding were one \texttt{let} clause.

As seen by the exerpt of the W3C XQuery EBNF specification in figure \ref{fig:trans:TD:seqEBNF}, a FLWOR
expression may be structured in infinitely many ways. For simplicity and readablilty the translation of such
expressions will be described in a clause-by-clause matter, as if executed as a postorder traversal of the tree in
figure \ref{fig:trans:TD:flworExecute}. The left children (variable bindings) will not return anything to their
parent and are handled by the rules \ref{rule:trans:TD:forbind} and \ref{rule:trans:TD:letbind}, and the algebra
returned from the right children will be referred to as \textbf{r(}$e_{C}$\textbf{)}. 

A FLWOR expression may have multiple \texttt{for} clauses, and a \texttt{for} clause may have multiple iterator
variable bindings. This means that one FLWOR may consist of many iterators, the semanics of which is described in
section \ref{sect:method:ast_rewrite}. The set of all iterator variables bound in one FLWOR will be reffered to as
$\beta$.

\begin{figure}[h]
\centering
\tikzstyle{optional}= []%[draw=black,dotted,thick, minimum size=26pt]
\tikzstyle{return}= [] %[ellipse,draw=black,solid,thick, minimum size=26pt]

\begin{tikzpicture}[grow via three points={one child at (1.5,-1.0) and two
children at (-1.5,-1.0) and (1.5,-1.0)}]
\node at (0,0) [optional] {[\textbf{let/for clause}]+}
child{node [optional] {[\textbf{binding}]+} edge from parent [draw,dotted, thick]}
	child{node [optional] {[\texttt{order by} $e_{3}$]?}
		child{node [optional] {[\texttt{where} $e_{2}$]?}
			child{node [return] {\texttt{return} $e_{4}$}}
			}
		} 
;
\end{tikzpicture}
\label{fig:trans:TD:flworExecute}
\caption[FLWOR translation order]{Illustration of step-by-step translation of FLWOR.}
\end{figure}

\subsubsection{Return Clause}
The \texttt{return} clause is evaluated once for each combination of iterations of the FLWOR expression. The
results of these evaluations are concatenated to form the result of the FLWOR expression. If the \texttt{return}
expression is not dependent on some of the iterators, its relational form will not have a representation for each
of these iterators iterations. Because of this the result of the \texttt{return} clause will have to be tainted
with these iterators.
\begin{equation}
\frac{}{\mbox{\texttt{return }}e_{4}}\longmapsto
\mbox{\textbf{t(r(}}e_{4}\mbox{\textbf{), }}\beta\mbox{\textbf{)}}
\label{rule:trans:TD:returnTaint}
\end{equation}
Where the dependencies returned is $\vartheta = e_4.\vartheta \cup \beta$.

From equation \ref{eq:trans:TD:taint} it is clear that a expression allready dependent on $I_{\chi}$ will not be
tainted by this iterator.

\subsubsection{Let Clause}
Because the \texttt{let} clause does not imply any iteration, it does not have any consequences for the
translation of FLWOR expresions:
\begin{equation}
\frac{}{\mbox{\textbf{let clause}}}\longmapsto \mbox{\textbf{r(}}e_{C}\mbox{\textbf{)}}
\label{rule:trans:TD:letclause}
\end{equation}

\subsubsection{For Clause}
Because each FLWOR iterator creates a new sequence, renumbering is needed to calculate the result. No expression in
a sibling or parent scope of the iterator $I_{\chi}$ may be dependent on $I_{\chi}$. Thus, $\chi$ is not part of the
dependencies $I_{\chi}.\vartheta$ returned from the iterator, and the corresponding $\chi{numb}$ attribute must be
removed. For each binding, from right to left, of an iterator variable $\chi$ bound in an \texttt{for} clause,
the following translation is applied: 
\begin{equation}
\frac{}{\chi\mbox{\textbf{ bound in for clause }}}
\longmapsto
\begin{array}{l}
\mbox{\textsf{numberate(index, [}}\chi\mbox{\textsf{numb, index], [}}\vartheta\mbox{\textsf{];}} \\ \quad
\mbox{\textbf{r(}}e_{C}\mbox{\textbf{)}\textsf{)}}
\end{array}
\label{rule:trans:TD:forReturn}
\end{equation}

Where $\vartheta = e_{C}.\vartheta - \chi$.

The \textsf{numberate} operator will have to partition on the remaining dependencies in $\vartheta$ to seperate
the sequences returned from the iterator for all iterators the result is dependent on, as described in section
\ref{sect:trans:TD:implic}.

\begin{myExample}

With the rules for translating \texttt{for} and \texttt{return} clauses, the query of figure
\ref{fig:trans:TD:expandQuery} can be fully evaluated. Expression $e_{1}$ is the \texttt{return} clause expression
of, but is not depentant on $I_{\mbox{\texttt{b}}}$. By rule \ref{rule:trans:TD:returnTaint} $e_{1}$ is tainted,
as shown in figure \ref{fig:trans:TD:final:taint}. To calculate the result of $I_{\mbox{\texttt{b}}}$,
renumbering is required, as the iterator will return a sequence of four items (to items for each of the two
iterations). The rule \ref{rule:trans:TD:forReturn} is applied. This will result in the relation illustrated in
figure \ref{fig:trans:TD:final:rIb}. $I_{\mbox{\texttt{b}}}$ consitutes the \texttt{return} clause of
$I_{\mbox{\texttt{a}}}$, and is dependent on $I_{\mbox{\texttt{a}}}$ because one of its subexpressions is a
referral to \texttt{\$a}. Rule \ref{rule:trans:TD:returnTaint} will therefore not have any effect. A renumbering
with rule \ref{rule:trans:TD:forReturn} finalises the evalution of the query. The final result is shown in figure
\ref{fig:trans:TD:final:rIb}.


\begin{figure}[h]
\centering
\subfigure[\textbf{t(r(}$e_{1}$\textbf{), \{}\texttt{b}\textbf{\})}]{
\begin{tabular}{|c|c|c|c|} \hline
$bnb$ & $anb$ & $idx$ & $val$ \\ \hline
1 & 1 & 1 & 10 \\ \hline
1 & 2 & 1 & 20 \\ \hline
1 & 1 & 2 & \texttt{"no"} \\ \hline
1 & 2 & 2 & \texttt{"no"} \\ \hline
2 & 1 & 1 & 10 \\ \hline
2 & 2 & 1 & 20 \\ \hline
2 & 1 & 2 & \texttt{"no"} \\ \hline
2 & 2 & 2 & \texttt{"no"} \\ \hline
\end{tabular}
\label{fig:trans:TD:final:taint}
}
\qquad
\subfigure[\textbf{r(}$I_{\mbox{\texttt{b}}}$\textbf{)}]{
\begin{tabular}{|c|c|c|} \hline
$anb$ & $idx$ & $val$ \\ \hline
1 & 1 & 10 \\ \hline
1 & 2 & \texttt{"no"} \\ \hline
1 & 3 & 10 \\ \hline
1 & 4 & \texttt{"no"} \\ \hline
2 & 1 & 20 \\ \hline
2 & 2 & \texttt{"no"} \\ \hline
2 & 3 & 20 \\ \hline
2 & 4 & \texttt{"no"} \\ \hline
\end{tabular}
\label{fig:trans:TD:final:rIb}
}
\qquad
\subfigure[\textbf{r(}$I_{\mbox{\texttt{a}}}$\textbf{)}]{
\begin{tabular}{|c|c|} \hline
$idx$ & $val$ \\ \hline
1 & 10 \\ \hline
2 & \texttt{"no"} \\ \hline
3 & 10 \\ \hline
4 & \texttt{"no"} \\ \hline
5 & 20 \\ \hline
6 & \texttt{"no"} \\ \hline
7 & 20 \\ \hline
8 & \texttt{"no"} \\ \hline
\end{tabular}
\label{fig:trans:TD:final:rIa}
}

\caption[Example: resolving for..return]{Applying rule \ref{rule:trans:TD:forReturn} on (a) yields (b). Applying
rule \ref{rule:trans:TD:forReturn} on (b) yields (c). Attribute names are shortened
\label{fig:trans:TD:finalizeExp}}
\end{figure}

\end{myExample}

\subsubsection{Where Clause}
The W3C describes the FLWOR expression as generating a tuple stream which contains one tuple for each combination
of values bound in the expression\cite{w3c00}. In this view, the optional \texttt{where} clause serves a filter for
these tuples. The expression in the \texttt{where} clause is evaluated once for tuple. If the boolean value of this
expression is $true$, the tuple is retained, if the boolean value is $false$ the tuple is discarded.

The \texttt{where} clause can be evaluated by only selecting the cases where the \texttt{where} expression is true.
The result of this will be joined with the result of the \texttt{return} clause. If the result from the
\texttt{return} clause and the \texttt{where} expression has no common iterator dependencies, the equi-join will
have to be replaced by a cartesian product, as discussed in \ref{sect:trans:TD:implic}.

\begin{equation}
\frac{}{\mbox{\texttt{where }}e_2}\longmapsto
\begin{array}{l}
\mbox{\textsf{hhjoin([l.}}(e_{C}.\vartheta \cap e_2.\vartheta)\mbox{\textsf{], [r.}}(e_{2}.\vartheta \cap
e_{C}.\vartheta)\mbox{\textsf{], [l.value, }} \vartheta\mbox{\textsf{];}} \\ \quad
\mbox{\textbf{r(}}e_{C}\mbox{\textbf{)}} \\ \quad
\mbox{\textsf{select(xqBoolean(value)}} \\ \quad \quad
\mbox{\textbf{r(}}e_{2}\mbox{\textbf{)}\textsf{))}}
\end{array}
\label{rule:trans:TD:where}
\end{equation}

Where $\vartheta = e_{C} \cup e_{2}$.

By employing the \textsf{select} operator before the joining of the two relations the number of tuples needed to
be read to execute the join will be minimized. Further, as the \textsf{hhjoin} operator allows for declaring which
attributes to be projected, there is no need for a seperate \textsf{project} operator.

\begin{myExample}
Consider the XQuery query of figure \ref{fig:trans:TD:whereQuery}. The evaluation of $e_{1}$ is very similar to
the evaluation of $e_{1}$ of example \ref{ex:trans:TD:simpleSeq}, and the is shown in figure
\ref{fig:trans:TD:where:re1}. The \texttt{where} clause contains a comparison expression, which will be discussed
later. Figure \ref{fig:trans:TD:where:whereE} shows the result relation of the \texttt{where} expression.

\begin{figure}[h]
\centering
\begin{equation*}
\begin{array}{l}
\mbox{\texttt{for \$a in (10,20)}} \\
\mbox{\texttt{where \$a > 15}} \\
\mbox{\texttt{return}} \underbrace{\mbox{\texttt{(\$a, 14)}}}_{e_{1}}
\end{array}
\end{equation*}
\caption{A FLWOR expression with a \texttt{where} clause \label{fig:trans:TD:whereQuery}}
\end{figure}

\begin{figure}[h]
\centering
\subfigure[\textbf{r(}$e_{1}$\textbf{)}]{
\begin{tabular}{|c|c|c|} \hline
$anb$ & $idx$ & $val$ \\ \hline
1 & 1 & 10 \\ \hline
1 & 2 & 14  \\ \hline
2 & 1 & 20 \\ \hline
2 & 2 & 14  \\ \hline
\end{tabular}
\label{fig:trans:TD:where:re1}
}
\qquad
\subfigure[\textbf{r(}\texttt{\$a > 15}\textbf{)}]{
\begin{tabular}{|c|c|c|} \hline
$anb$ & $idx$ & $val$ \\ \hline
1 & 1 & $false$ \\ \hline
2 & 1 & $true$ \\ \hline
\end{tabular}
\label{fig:trans:TD:where:whereE}
}
\qquad
\subfigure[]{
\begin{tabular}{|c|c|c|} \hline
$anb$ & $idx$ & $val$ \\ \hline
2 & 1 & 20 \\ \hline
2 & 2 & 14  \\ \hline
\end{tabular}
\label{fig:trans:TD:where:intr}
}

\caption[Example: Evaluation of where clause]{Applying rule \ref{rule:trans:TD:where} on (a) and (b)
yields (c). Attribute names are shortened. \label{fig:trans:TD:whereClause}}
\end{figure}
During the evaluation of the FLWOR, the tuples in the \texttt{where} expression relation where $value$ ($val$ in
figure) is not $true$ will be removed. The result is a relation with a single tuple where $anumb$ holds the value
$2$. This result is then joined with the $e_1$ relation on $anumb$, as shown in figure
\ref{fig:trans:TD:where:intr}. Rule \ref{rule:trans:TD:forReturn} will have to be applied to complete the
evaluation of the query.
\end{myExample}


\subsubsection{Order By Clause}
\begin{itemize}
  \item join, renumbering (numberate fjerner felter ergo: ingen project)
\end{itemize}

