\section{Loop Lifting}
\label{sect:translation:loop_lifting}
Loop lifting is a method of translating XQuery iteration expressions into relational algebra. The method was
developed by Torsten Grust and Jens Teubner and originally presented in \cite{pathfinder_mothertongue}. It is a
part of the Pathfinder project\cite{pathfinderHome} (see section \ref{sect:theory:pathfinder}).

In this section we will present Loop Lifting mainly based on the two articles \cite{pathfinder_mothertongue} and
\cite{pathfinder_purelyRelational}. The articles present the method for a subset of XQuery Core (Pathfinder
rewrites queries to Core, see section \ref{sect:theory:pathfinder}), of which we will only present the elements
relevant in a comparison between Loop Lifting and \underline{\textbf{\Large TODO:}} ``insertName''. Thus, the
translation of path expressions and XML-element construction will not be handled, as pathfinder's XML-tree
representation(section \ref{sect:theory:pathfinder}) is incompatible with Mars.

\begin{itemize}
  \item forutsetter det \aa~ jobbe p\aa~ DAGz?
\end{itemize}

\subsection{Operators}
\label{sect:translation:ll:Operators}
Loop-lifting utilises a set of relational algebra operators, out of which the ones used in this chapter is
presented in table \ref{tab:translation:llOperators}.
\begin{table}[h]
\centering
\begin{tabular}{l|l} 
$\pi_{a_{1}:b_{1},\ldots,a_{n}:b_{n}}$ 	& projection and renaming	\\ 	\hline
$\sigma_{a}$					   		& selection             	\\ 	\hline
$\dot\cup$ 							& disjoint union			\\	\hline
$\times$								& cartesian product			\\	\hline
$\bowtie_{a=b}$							& equi-join					\\ 	\hline
$\varrho_{b:(a_{1},\ldots,a_{n})/p}$	& numbering operator		\\	\hline
$\circledcirc_{b:(a_{1},\ldots,a_{n})}$	& $n$-ary arithmetic/comparison operator $\circ$ \\ \hline
\scriptsize \begin{tabular}{c|c} $a$& $b$\\\hline\end{tabular} & literal table
\end{tabular}
\caption[of the Pathfinder relational algebra]{Operators of the Pathfinder relational algebra. $a$, $b$ and $p$
represents attributes}
\label{tab:translation:llOperators}
\end{table}

Most of the operators are quite standard, and can easily be understood by comparing with the operators from
section \ref{sect:theory:relAlg} and \ref{sect:method:marsOperators}.

The selection operator ($\sigma_{a}$) selects tuples where attribute $a \ne 0$. Only a very restricted selection
is used, written $\sigma_{a}$, which only returns tuples satisfying $a \neq 0$.  Considering the numbering
operator, $p$ denotes the partitioning attribute, $(a_{1},\ldots,a_{n}$ the attributes to be sorted on and $b$ is
an added attribute holding the result of the
numbering. {\scriptsize{\begin{tabular}{c|c}$a$&$b$\\\hline\end{tabular}}}  represents the creation
of a relation with attributes $a$ and $b$.

Operator $\circledcirc_{b:(a_{1},\ldots,a_{n})}$ will evaluate the arithmetic/comparison expression $a_{1} \circ
\ldots \circ a_{n}$ and place the result in $b$. Where $\circ \in \left\{ +,- , <, =, \ldots  \right\} $.


\subsection{Basics}
\label{sect:translation:ll:Basics}
XQuery expressions evaluate to finite, ordered sequences of items. As a sequences are one-dimensional, it can be
represented by a single relation where each tuple encodes a sequence item. The order of the sequence is
maintained by an attribute \textit{pos}. The value of the item is held in an attribute \textit{item}. A sequence
such as \texttt{('a', 'b', 'c')} will be represented relationally like this:

\begin{center}
\begin{tabular}{|c|c|}\hline
\textit{pos}	& \textit{item} 	\\ \hline
1				& \texttt{'a'}		\\ \hline
2				& \texttt{'b'}		\\ \hline
3				& \texttt{'c'}		\\ \hline
\end{tabular}
\end{center}

For the rest of this chapter about Pathfinder's loop lifting, variables, expressions and scopes is denoted like
this (ref. section \ref{sect:theory:xquery:Flwor}):
\[
s \left\{
\begin{array}{l}
\qquad \qquad \quad \vdots \\
\mbox{\texttt{for \$}}v_{0}\mbox{\texttt{ in }} e_{0} \mbox{\texttt{ return}} \\
\quad s_{0} \left\{ e_{0}' \right. \\
\qquad \qquad \quad \vdots
\end{array}
\right.
\]

More generally, a scope $s_{x \cdot y}$ identifies the $y$th child scope of scope $x$, $x \in \left\{
\mathbb{N}\right\}, y \in \left\{ \mathbb{N} \right\}$. Expression $e_{x\cdot y}$ evaluates to an iterator sequence
and is bound to the variable $v_{x \cdot y}$. $e_{x \cdot y}'$ constitutes the coresponding iterator body, and $I_{x \cdot y}$ the whole iterator expression.

$q_{x}(e)$ is used to denote the relational representation of expression $e$ in scope $s_{x}$.


\subsection{Constant Subexpressions}
\label{sect:translation:ll:ConstExprs}

For a iterator expression $i_{x}$ with $n$ iterations there exists a relation $loop_{x}$, consisting of a
single column, \textit{iter}, with values 1,2,\ldots,$n$. In the outermost scope, $loop$ has a single tuple with
value 1.

A constant value $c$ in scope $s_{x}$ is \textit{lifted} is lifted like this:
\begin{equation}
q_{x}(c) =  loop_{x} \times \mbox{\scriptsize \begin{tabular}{c|c} \textit{pos}&\textit{item} \\
\hline 1 & \textit{c}
\end{tabular}}
\label{eq:ll:constLoopLift}
\end{equation}

A tuple ($iter,pos,item$) in a loop lifted relation for subexpression $e_{x}'$ can be understood as that during the
$iter$th iteration, the item in position $pos$ in $e_{x}'$ has the value $item$.

\subsection{Bound Variables}
\label{sect:translation:ll:boundVar}

A variable is bound
An iterator sequence expression $e_{x \cdot y}$ is evaulated in scope $s_{x}$. This sequence is then iterated over
and each item is successively bound to the iterator variable $v_{x \cdot y}$. The evaluation of $e_{x \cdot y}'$
is in scope $s_{x \cdot y}$ and utilises these bindings. 

Considering this, a representation of $v_{x \cdot y}$ in scope $s_{x \cdot y}$ may therefore be calculated by
retaining the values of $q_{x}(e_{x \cdot y})$, introducing a $iter$ attribute with consecutive numbers and
holding the $pos$ attribute to the constant value 1. In terms of algebra, the representation of $v_{x \cdot y}$ is
computed like this:
\begin{equation}
q_{x \cdot y}(\mbox{\texttt{\$}}v_{x \cdot y}) = \mbox{\scriptsize \begin{tabular}{c} $pos$ \\\hline 1
\end{tabular}} \times \pi_{iter:inner,item}(\varrho_{inner:(iter,pos)}(q_{x}(e_{x \cdot y})))
\label{eq:ll:qx_vxy}
\end{equation}
The introduction of the $inner$ attribute is used to denote evaluation of the loop in scope $s_{x \cdot y}$. The
$iter$ attribute of $q_{x}(e_{x \cdot y})$ can be viewed as an atttribute $outer$, as it denotes the iterations in
the outer loop of scope $s_{x}$.

Loop lifting requires maintenance of a $loop$ relation ensuring independent iterations. The iterator body in
scope $s_{x \cdot y}$ needs to be evaluated once for each binding of the iterator variable $v_{x \cdot y}$.
Thus, the $loop$ relation needs to be redifined based on $q_{x \cdot y}(v_{x \cdot y})$:
\begin{equation}
loop_{x \cdot y} = \pi_{iter}(q_{x \cdot y}(v_{x \cdot y}))
\label{eq:ll:loopx}
\end{equation}


\subsection{Free Variables}
\label{sect:translation:ll:freeVar}

XQuery expressions may use any iterator variable bound in enclosing scopes. That is, $v_{x}$ bound in
scope $s_{x}$ may also be referred to within any of its child scopes. When looking at one of these child scopes,
$s_{x \cdot y}$, by itself, the variable $v_{x \cdot y}$ appears to be a free variable.

Vision a iterator expresion $I_{x \cdot y}$ within another iterator expression $I_{x}$, both with iterator
sequences of length two. If $v_{x}$ is referred to within scope $s_{x \cdot y}$, from $s_{x \cdot y}$'s point of
view, $v_{x}$ is free. For each binding of $v_{x}$ in the \textit{outer} iteration expression, two
evaluations of the \textit{inner} iteration expresion occur. A relation capturing the relationship between number
of iterations of these two iterator expressions can be defined like this:
\begin{center}
\begin{tabular}{|c|c|}\hline
\textit{outer}	& \textit{inner} 	\\ \hline
1				& 1		\\ \hline
1				& 2		\\ \hline
2				& 3		\\ \hline
2				& 4		\\ \hline
\end{tabular}
\end{center}
Where a tuple $(outer, inner)$ is read as for the $inner$th iteration of the inner iterator expression, the outer
iterator expression is in its $outer$th iteration. This relation is called $map_{x, x\cdot y}$ as it maps
representations between scopes $s_{x}$ and $s_{x \cdot y}$. It can be calculated like this:
\begin{equation}
map_{x, x\cdot y} = \pi_{outer:iter,inner}(\varrho_{inner:(iter,pos)}(q_{x}(e_{x \cdot y})))
\label{eq:ll:mapx_xy}
\end{equation}

With this relationship defined it is now possible to represent the free variable $v_{x}$ in the scope $s_{x \cdot
y}$ with the help of an equi-join:
\begin{equation}
q_{x \cdot y}(\mbox{\texttt{\$}}v_{x}) = \pi_{iter:inner, pos,
item}(q_{x}\left(\mbox{\texttt{\$}}v_{x})\bowtie_{iter=outer} map_{x, x \cdot y}\right)
\label{eq:ll:qxy_vx}
\end{equation}

\subsection{Mapping Back}
\label{sect:translation:ll:mappingBack}

All steps and equations so far have been helpful to represent sequences and variables in a lower scope. But the
result of a query will have to be in form of its representation in the outermost scope $s$. So a way to represent
an expression $e_{x,y}'$ in its scope's parent scope $s_{x}$ is needed. Once again the $map$ relation may be of
use, combined with an equi-join:
\begin{equation}
q_{x}(e_{x \cdot y}') =
\begin{array}{l}
 \pi_{iter:outer, pos:pos1, item}(\\ \qquad\varrho_{pos1:(iter,pos)/outer}(q_{x \cdot
y}(e_{x \cdot y}')\bowtie_{iter = inner}map_{x, x \cdot y}))
\end{array}
\label{eq:ll:qx_exymark}
\end{equation}


\subsection{Other Expression Types}
\label{sect:translation:ll:OtherExpr}

The sequence construction \texttt{(}$e_{1}$\texttt{, }$e_{2}$\texttt{)} is essentially a disjont union of the
relational representations of the expressions, that is, $q_{x}(e_{1})$ and $q_{x}(e_{2})$. By temporarily adding a
attribute $ord$ to these relations before a renumbering of the result with $\varrho$, the proper ordering of the
sequence is aquired. Construction of sequences can therefore be expressed like this:
\begin{equation}
q_{x}(\mbox{\texttt{(}}e_{1}\mbox{\texttt{,}}e_{2}\mbox{\texttt{)}})=
\begin{array}{l}


\pi_{iter,pos:pos1,item}
\left( \right.\\ \qquad

\varrho_{pos1:(ord,pos)/iter}
	\left( \right. \\ \qquad \qquad
	\left. \left.
		\left(
		\frac{ord}{1} \times q_{x}(e_{1})
		\right)
		\dot\cup
		\left(
		\frac{ord}{1} \times q_{x}(e_{2})
		\right)		
	\right)
\right)
\end{array}
\label{eq:ll:secuence}
\end{equation}

The $\circledcirc$ operator meets the demand of evaluating comparison and arithmetic operations on atomic values.
Given two XQuery values $e_{1}$ and $e_{2}$ in multiple iterations, with relational representations as before,
the expression $e_{1}$ \texttt{ + } $e_{2}$ can be translated by first joining $q_{x}(e_{1})$ and $q_{x}(e_{2})$
on their iterations $iter$. Then, for each tuple, store the sum of the values of both of the $item$ attributes,
before cleaning up the resulting relation with a project. Expressed as an equation, the sum expression looks like
this:
\begin{equation}
q_{x}(e_{1} \mbox{\texttt{ + }} e_{2}) =
\begin{array}{l}
\pi_{iter,pos,item:res}\left(\right. \\ \qquad
\oplus_{res:(item,item')}
\left( \right. \\ \qquad \qquad

	q_{x}(e_{1})
	\bowtie_{iter = iter'}
	 \\ \qquad \qquad \qquad
	\left.\left(\pi_{iter':iter, item':item}(q_{x}(e_{2}))
	\right)
\right)
\end{array}
\label{eq:ll:sumexpr}
\end{equation}

\subsection{Example}
\label{sect:translation:ll:example}
haha

\subsection{Optimisations}
\label{sect:translation:ll:Optimisations}
\begin{itemize}
  \item peep hole plan simplification
  \item dette kan fort bli dr\o yt\ldots v\ae re litt forsiktige her tror jeg
\end{itemize}

