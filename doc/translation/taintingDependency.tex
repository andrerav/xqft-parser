\newpage
\section{Tainting Dependencies}
\label{sect:trans:taintingDependencies}

\begin{itemize}
  \item \textbf{\LARGE TODO:} det er en newpage p\aa~denne siden
  \item INTRO for teh wind
  \item har vokst ut av MarkXRemove
  \item Tainting dependencies (TD)
  \item og mer text
\end{itemize}

\subsection{Inference Rule Language Explanation}
\label{sect:trans:TD:langExpl}
\underline{\textbf{\LARGE TODO:}} Skal jeg bruke greske bokstaver i stedet for tekstlig marsgreie n\aa r jeg
skriver regler?

During this chapter we will present some inference rules. In this section we will explain the various
typographical representations.

\begin{table}[h]
\begin{tabular}{l|l}

  $\longmapsto$  			& Translates into \\
  $\vartheta$ 			& A set of iteration variable references \\
  \textsf{sans serif} 	& MQL expressions \\
  \texttt{monospaced} 	& XQuery expressions \\
  $e,\ldots,e_{n}$		  	& Generic expressions \\
  $\chi, \Upsilon$		& Generic variable names \\
  $I_{\chi}$			& The iterator expression which declares $\chi$ \\
  \textbf{bold} 		& Operations done during the generation of the algebra \\
  \textbf{r(}$e$\textbf{)} & A function transforming the expression $e$ into relational algebra \\
  $\Delta$ 				& The default context \\
  $\Lambda$ 			& The logical/boolean context \\
  
\end{tabular}
\caption{Explanation of inference rule symbols}
\label{tab:trans:td:langExpl}
\end{table}

Inference rules are generally in this format:
\begin{equation*}
\frac{\mbox{\textbf{cxt}}\vdash cond}{e}\longmapsto \mbox{\textbf{r(}}e\mbox{\textbf{)}}
\end{equation*}

This should be read as: in the context of \textbf{cxt}, if condition $cond$ is satisfied, the XQuery expression
$e$ will be translated into \textbf{r(}$e$\textbf{)}.

The translator is in the logical context, $\Lambda$, if the AST node it is currently visiting is a successor of a
boolean operator or within the condition part of an \texttt{if..then..else} expression. In all other cases the
translator is in the default context, $\Delta$. If no context is mentioned in the inference rules the default
context is assumed.

\subsection{Basics}
\label{sect:trans:TD:basics}
The method assumes left-to-right traversal of the assymetric syntax tree. In most cases the traversal is
postorder, meaning a subtree can be evaluated independently from its ancestors -- the exception being the logical
context set by boolean operators. The relational algebra will thus be generated bottom-up. In addition to the
evaluated subtree, a node must be able to inform its parent node about its variable dependencies ($\vartheta$),
which we will discuss later.

One XQuery sequence is represented as one relation and one XQuery item is represented as one tuple. This is sound,
as all XQuery items are sequences, and all sequences are one-dimensional (section
\ref{sect:theory:xquery:basics}). As we mentioned in section \ref{sect:trans:MarkXRemove}, the MarkXRemove method
did actually not consider the ordering of items in sequences at all. In Tainting Dependencies, however, we have
introduced an attribute $index$ holding the intra sequence number of the item. Consider the XQuery sequence
\texttt{('a','b',}$\ldots$\texttt{,'z')}. With this attribute, the relational representation will be as follwing:

\begin{center}
\begin{tabular}{|c|c|} \hline
$index$ & $value$ \\\hline
1		& \texttt{'a'} \\\hline
2		& \texttt{'b'} \\\hline
$\ldots$& $\ldots$ \\\hline
$n$		& \texttt{'z'} \\\hline
\end{tabular}
\end{center}


As can be seen, the item value is stored in the $value$ attribute. For the course of this chapter we will, for the
sake of simplicity, treat $value$ as a polymorphic type attribute. This simplification has minimal consequences
for the method and the way XQuery expressions are translated. XQuery types and relational representation of such
will is handled in section \ref{sect:disc:typeSystem}. \marginpar{\textbf{\LARGE TODO:} noen andre steder?.}

Also for simplicity, the $documentId$, $pos$ and $scope$ attributes have been left out of the
fields specified in \textsf{project} operators. If the \textsf{project} operator is applied to the result of a
join or cartesian product, these fields will follow the $value$ attribute. That is, if $r.value$ is projected,
then so is $r.documentId$, etc\ldots if applicable.

Tainting Dependencies utilises a symbol table for storing of variables declared. The table has two functions:
\begin{itemize}
  \item \textbf{put(}$\chi$\textbf{, }\textbf{r(}$e$\textbf{))} -- will store the
  algebraic version of the expression bound to the variable \texttt{\$}$\chi$ with $\chi$ as the key.  
  \item \textbf{get(}$\chi$\textbf{)} -- will do a lookup in the table based on the name of the variable
  \texttt{\$}$\chi$ and return the algebraic version of the expression linked to it.
\end{itemize}
The symbol table handles scoping according to XQuery semantics (section \ref{sect:theory:xquery:Flwor}), meaning
the translator will always be able to find the right declared variable based on which node in the AST the
translator is visiting.

\subsection{Iterator Variable Dependency}
\label{sect:trans:TD:dependency}

The concept of iterator variable dependency form the basis of the Tainting Dependency method. Such dependency is
defined as follows:

\noindent
\begin{myDefinition}
An XQuery expression $e$ is \textbf{dependant} on an iterator variable \texttt{\$}$\chi$, if in the corresponding
abstract syntax tree there exists a upwards path from a reference to \texttt{\$}$\chi$ to $I_{\chi}$ via $e$.
\label{def:iterVarDep}
\end{myDefinition}

Consider the example subexpression of figure \ref{fig:trans:td:varDep}, where \texttt{\$x} and \texttt{\$y} both
are iterator variables. Here, the expresion $e_{1}$ is dependent on both variables, but expression $e_{2}$ is only
dependent on the variable \texttt{\$x}.

\begin{figure}[h]
\centering
\tikzstyle{astNode}=[circle, draw=blue!70,fill=blue!20,solid,thick, minimum
size=26pt]
\begin{tikzpicture}[grow via three points={one child at (0,-1.5) and two
children at (-1.5,-1.0) and (1.5,-1.0)}]
\draw[loosely dotted, thick] (0,0) -- (0,-1);
\node at (0,-1) [astNode, label=above left:$e_{1}$ ] {\texttt{and}} 
child{node [astNode, label=above left:$e_{2}$] {\texttt{+}}
	child{node [astNode] {\texttt{\$x}}}
	child{node [astNode] {\texttt{3}}}
 }
child{node [astNode] {\texttt{\$y}}}
 ;
\end{tikzpicture}
\label{fig:trans:td:varDep}
\caption[Iterator variable dependency]{Iterator variable dependency}
\end{figure}

The iterator variable dependencies of an expression $e$ are part of the set $e.\vartheta$. As mentioned earlier,
an AST node must be able to inform its parent about the node's dependencies as well as the algebra generated. This
can be done by for an expression $e$ letting $e.\vartheta$ piggyback the \textbf{r(}$e$\textbf{)} returned.
\marginpar{\textbf{\Large TODO} klarer ikke skrive setninger\ldots}. The variable dependencies for an expression
$e$ with the subexpressions $e_{1},\ldots,e_{n}$ can be described as following:
\begin{equation*}
e.\vartheta = e_{1}.\vartheta\cup\ldots\cup e_{n}.\vartheta
\end{equation*}

The dependancy on the variable \texttt{\$}$\chi$ manifest itself relationally by the attribute $\chi$$numb$. The
value of $\chi$$numb$ is the iteration number of $I_{\chi}$, that is, for a tuple ($\chi$$numb$, $value$) the value
$value$ will appear in the $\chi$$numb$th iteration of $I_{\chi}$.

When an iterator variable \texttt{\$}$\chi$ is declared it is assigned a $\chi$$numb$ by renaming the $index$
field of corresponding iterator sequence $\chi$$numb$. Which leads us to the inference rule for translating the
(optional) \texttt{for} clause of a FLWOR expression:
\begin{equation}
\frac{}{\mbox{\texttt{for \$}}\chi \mbox{\texttt{ in }} e \mbox{\texttt{\ldots}}}\longmapsto
\begin{array}{l}
\mbox{\textbf{put(}}\chi\mbox{\textbf{, }} \\ \qquad
\mbox{\textsf{project(}}\chi\mbox{\textsf{numb = index, value;}} \\ \qquad \qquad
\mbox{\textbf{r(}}e\mbox{\textbf{))}}
\end{array}
\label{eq:trans:td:forclause}
\end{equation}
Where the dependancies piggybacking the \textsf{project} operator can be expressed as:
$\vartheta = e.\vartheta \cup \chi$.

From definition \ref{def:iterVarDep} it can be seen that $\chi$ is not part of the set of dependancies the iterator
$I_{\chi}$ returns its parent. This is in fact the only case a variable is removed from a dependency set.
Because of this, we must be careful not to incidentally remove a $\chi$$numb$ attribute from a relation by means
of a \textsf{project} operator. When we in this chapter write $\vartheta$ enclosed in MQL syntax it is to be
interpreted as a comma seperated list of all the attributes linked to the dependencies in the set $\vartheta$.

\subsection{Tainting Dependencies}
\label{sect:trans:TD:tainting}
\begin{itemize}
  \item hvis \textbf{en} av items er avhengig\ldots
  \item betyr jo at settet er avhengig av iterasjon-> posisjon og ting, fordi den skal brukes til noe
  \item definisjon
  \item vis hvordan tainting foreg\aa r ->
  \item Forced Dependency Tainting\ldots hvis man kommer til 
\end{itemize}

\subsection{Sequence Building}
\label{sect:trans:TD:seqBuild}
\begin{itemize}
  \item hvordan bygge sekvenser
  \item forst enkelt
  \item s\aa~med tainting
\end{itemize}

\subsection{Simple FLWORs}
\label{sect:trans:TD:simpleFLWOR}
\begin{itemize}
  \item bare for e1 in e2 return e3
  \item ta where og order by senere\ldots
\end{itemize}

\subsection{other Th1ngz:}
\begin{itemize}
  \item hva om alle steps har sin funksjon?
\end{itemize}


\subsection{Optimisations}
\label{sect:trans:optimisations}
\begin{itemize}
  \item skal vi ha det her, eller i discussion?
  \item kanskje begge deler\ldots. Her kommer en liste som kan bygges p\aa~etterhvert iallefall:
	  \begin{itemize}
	    \item suprIndx kan doppes n\aa r bare atomiske (singelton er vel bedre begrep)
	    \item for kan bli -> project , ved singelton return
	    \item singeltons trenger ikke index
	  \end{itemize} 
\end{itemize}