\newpage
\section{Tainting Dependencies}
\label{sect:trans:taintingDependencies}

\begin{itemize}
  \item \textbf{\LARGE TODO:} det er en newpage p\aa~denne siden
  \item INTRO for teh wind
  \item har vokst ut av MarkXRemove
  \item Tainting dependencies (TD)
  \item og mer text
\end{itemize}

\subsection{Inference Rule Language Explanation}
\label{sect:trans:TD:langExpl}
\underline{\textbf{\LARGE TODO:}} Skal jeg bruke greske bokstaver i stedet for tekstlig marsgreie n\aa r jeg
skriver regler?

During this chapter we will present some inference rules. In this section we will explain the various
typographical representations.

\begin{table}[h]
\begin{tabular}{l|l}

  $\longmapsto$  			& Translates into \\
  $\vartheta$ 				& A set of iteration variable references \\
  \textsf{sans serif} 		& MQL expressions \\
  \texttt{monospaced} 		& XQuery expressions \\
  $e,\ldots,e_{n}$			& Generic expressions \\
  $\chi,\ldots,\chi_{n}$	& Generic variable names \\
  $I_{\chi}$				& The iterator expression which declares $\chi$ \\
  \textbf{bold} 			& Operations done during the generation of the algebra \\
  \textbf{r(}$e$\textbf{)} 	& Returns the relational algebraic representation of $e$   \\
  \textbf{t(}\textbf{r(}$e$\textbf{)}\textbf{,}$\vartheta'$\textbf{)} & Returns \textbf{r(}$e$\textbf{)} tainted
  with the dependencies $\vartheta'$ \\
  $\Delta$ 					&  The default context \\ 
  $\Lambda$ 				& The logical/boolean context \\
  
\end{tabular}
\caption{Explanation of inference rule symbols}
\label{tab:trans:td:langExpl}
\end{table}

Inference rules are generally in this format:
\begin{equation*}
\frac{\mbox{\textbf{cxt}}\vdash cond}{e}\longmapsto \mbox{\textbf{r(}}e\mbox{\textbf{)}}
\end{equation*}

This should be read as: in the context of \textbf{cxt}, if condition $cond$ is satisfied, the XQuery expression
$e$ will be translated into \textbf{r(}$e$\textbf{)}.

The translator is in the logical context, $\Lambda$, if the AST node it is currently visiting is a successor of a
boolean operator or within the condition part of an \texttt{if..then..else} expression. In all other cases the
translator is in the default context, $\Delta$. If no context is mentioned in the inference rules the default
context is assumed.

\subsection{Basics}
\label{sect:trans:TD:basics}
The method assumes left-to-right traversal of the assymetric syntax tree. In most cases the traversal is
postorder, meaning a subtree can be evaluated independently from its ancestors -- the exception being the logical
context set by boolean operators. The relational algebra will thus be generated bottom-up. In addition to the
evaluated subtree, a node must be able to inform its parent node about its variable dependencies ($\vartheta$),
which we will discuss later.

One XQuery sequence is represented as one relation and one XQuery item is represented as one tuple. This is sound,
as all XQuery items are sequences, and all sequences are one-dimensional (section
\ref{sect:theory:xquery:basics}). As we mentioned in section \ref{sect:trans:MarkXRemove}, the MarkXRemove method
did actually not consider the ordering of items in sequences at all. In Tainting Dependencies, however, we have
introduced an attribute $index$ holding the intra sequence number of the item. Consider the XQuery sequence
\texttt{('a','b',}$\ldots$\texttt{,'z')}. With this attribute, the relational representation will be as follwing:

\begin{center}
\begin{tabular}{|c|c|} \hline
$index$ & $value$ \\\hline
1		& \texttt{'a'} \\\hline
2		& \texttt{'b'} \\\hline
$\ldots$& $\ldots$ \\\hline
$n$		& \texttt{'z'} \\\hline
\end{tabular}
\end{center}


As can be seen, the item value is stored in the $value$ attribute. For the course of this chapter we will, for the
sake of simplicity, treat $value$ as a polymorphic type attribute. This simplification has minimal consequences
for the method and the way XQuery expressions are translated. XQuery types and relational representation of such
will is handled in section \ref{sect:disc:typeSystem}. \marginpar{\textbf{\LARGE TODO:} noen andre steder?.}

Also for simplicity, the $documentId$, $pos$ and $scope$ attributes have been left out of the
fields specified in \textsf{project} operators. If the \textsf{project} operator is applied to the result of a
join or cartesian product, these fields will follow the $value$ attribute. That is, if $r.value$ is projected,
then so is $r.documentId$, etc\ldots if applicable.

Tainting Dependencies utilises a symbol table for storing of variables declared. The table has two functions:
\begin{itemize}
  \item \textbf{put(}$\chi$\textbf{, }\textbf{r(}$e$\textbf{))} -- will store the
  algebraic version of the expression bound to the variable \texttt{\$}$\chi$ with $\chi$ as the key.  
  \item \textbf{get(}$\chi$\textbf{)} -- will do a lookup in the table based on the name of the variable
  \texttt{\$}$\chi$ and return the algebraic version of the expression linked to it.
\end{itemize}
The symbol table handles scoping according to XQuery semantics (section \ref{sect:theory:xquery:Flwor}), meaning
the translator will always be able to find the right declared variable based on which node in the AST the
translator is visiting.

\subsection{Iterator Dependency Inheritance}
\label{sect:trans:TD:dependency}

The concept of iterator dependency form the basis of the Tainting Dependency method. Such dependency is
defined as follows:

\noindent
\begin{myDefinition}
An XQuery expression $e$ is \textbf{dependant} on an iterator $I_{\chi}$ if $e$ occurs within the iterator body of
$I_{\chi}$ and if the evaluation of $e$ depends on the iteration number of $I_{\chi}$.
\label{def:iterVarDep}
\end{myDefinition}

An variable reference to an iterator variable \texttt{\$}$\chi$ is by this definition dependent on the iterator
$I_{\chi}$. Intuitively, an expression which subexpression is dependent on an iterator $I_{\chi}$ is also
dependent on this iterator -- we say the dependency is inherited. Consider the example subexpression of figure
\ref{fig:trans:td:varDep}, where \texttt{\$x} and \texttt{\$y} both are iterator variables. Here, the expresion
$e_{1}$ is dependent the two iterators $I_{\mbox{\texttt{x}}}$ and $I_{\mbox{\texttt{y}}}$, while expression
$e_{2}$ is only dependent on $I_{\mbox{\texttt{x}}}$.

\begin{figure}[h]
\centering
\tikzstyle{astNode}=[circle, draw=blue!70,fill=blue!20,solid,thick, minimum
size=26pt]
\begin{tikzpicture}[grow via three points={one child at (0,-1.5) and two
children at (-1.5,-1.0) and (1.5,-1.0)}]
\draw[loosely dotted, thick] (0,0) -- (0,-1);
\node at (0,-1) [astNode, label=above left:$e_{1}$ ] {\texttt{and}} 
child{node [astNode, label=above left:$e_{2}$] {\texttt{+}}
	child{node [astNode] {\texttt{\$x}}}
	child{node [astNode] {\texttt{3}}}
 }
child{node [astNode] {\texttt{\$y}}}
 ;
\end{tikzpicture}
\label{fig:trans:td:varDep}
\caption[Iterator variable dependency]{Iterator variable dependency}
\end{figure}

The iterator dependencies of an expression $e$ are part of the set $e.\vartheta$. As mentioned earlier,
an AST node must be able to inform its parent about the node's dependencies as well as the algebra generated. For
an expression $e$ this can be done by letting $e.\vartheta$ piggyback the \textbf{r(}$e$\textbf{)} returned. The
variable dependencies for an expression $e$ with the subexpressions $e_{1},\ldots,e_{n}$ can be described as
following:
\begin{equation*}
e.\vartheta = e_{1}.\vartheta\cup\ldots\cup e_{n}.\vartheta
\end{equation*}

The dependancy on the iterator $I_{\chi}$ manifest itself relationally by the attribute $\chi$$numb$. The value of
$\chi$$numb$ is the iteration number of $I_{\chi}$, that is, for a tuple ($\chi$$numb$, $value$) the value $value$
will appear in the $\chi$$numb$th iteration of $I_{\chi}$.

When an iterator variable \texttt{\$}$\chi$ is declared it is assigned a $\chi$$numb$ by renaming the $index$
field of the corresponding iterator sequence $\chi$$numb$. Which leads us to the inference rule for translating the
(optional) \texttt{for} clause of a FLWOR expression:
\begin{equation}
\frac{}{\mbox{\texttt{for \$}}\chi \mbox{\texttt{ in }} e \mbox{\texttt{\ldots}}}\longmapsto
\begin{array}{l}
\mbox{\textbf{put(}}\chi\mbox{\textbf{, }} \\ \quad
\mbox{\textsf{project(}}\chi\mbox{\textsf{numb = index, index=1, value;}} \\ \quad \quad
\mbox{\textbf{r(}}e\mbox{\textbf{)}\textsf{)}\textbf{)}}
\end{array}
\label{rule:trans:td:forclause}
\end{equation}
Where the dependancies piggybacking the \textsf{project} operator can be expressed as:
$\vartheta = e.\vartheta \cup \chi$.

For a \texttt{for} clause with multiple variable bindings the rule must be applied once per binding as if there
is one flwor expression per binding, and the $n$th binding is a flwor expression in the $(n-1)$th bindings
return clause. This is in accordance with the XQuery semantics, and is one of the rewrite rules into XQuery core
(see section \ref{sect:theory:xquery:XQcore}).

From definition \ref{def:iterVarDep} it can be seen that $\chi$ is not part of the set of dependancies the iterator
$I_{\chi}$ returns its parent. This is in fact the only case a variable is removed from a dependency set. Because
of this, we must be careful not to incidentally remove a $\chi$$numb$ attribute from a relation by means of a
\textsf{project} operator. 

When we in this chapter write $\vartheta$ enclosed in MQL syntax it is to be interpreted as a comma seperated list
of all the attributes linked to the dependencies in the set $\vartheta$. As an example, the dependency set
$\vartheta = \left\{\mbox{\texttt{x}},\mbox{\texttt{y}},\mbox{\texttt{z}}\right\}$, is read as \textsf{xnumb,
ynumb, znumb} in an MQL environment.

XQuery variable reference expressions, be it iterator, \texttt{let} or \texttt{declare} variables, are translated
to relational algebra quite simply by fetching the tree linked to the variable name in the symbol table:
\begin{equation}
\frac{}{\mbox{\texttt{\$}}\chi}\longmapsto
\mbox{\textbf{get(}}\chi\mbox{\textbf{)}}
\end{equation}


\subsection{Iterator Dependency Tainting}
\label{sect:trans:TD:tainting}

The iterator body of an iterator with a iterator sequence with length $n$ will have to executed $n$ times. This
can be done by e.g. evaluating the cartesian product between the body or the sequence, as with the MarkXRemove
method. To avoid any denormalised intermediate results, an ideal solution would be to always calculate such
products after all other evaluations of the query is done. Consider the following simple example of the query $e$:

\begin{center}
\begin{tabular}{l}
\texttt{for \$a in (1, 2) return} \\ \qquad
\texttt{for \$b in (3, 4) return} \\ \qquad \qquad
\texttt{5 + 6}
\end{tabular}
\end{center}

For this query the result can be calculated like this:
\noindent
\begin{center}
\textbf{r(}$e$\textbf{)}$=$\textbf{r(}\texttt{(1, 2)}\textbf{)}$\times$\textbf{r(}\texttt{(3,
4)}\textbf{)}$\times$\textbf{r(}\texttt{5 + 6}\textbf{)}.
\end{center}
\noindent

But such a simple solution is not adequate if there is a reference to an iterator variable somewhere within the
iterator body. This was managed by MarkXRemove by implementing inheritance of iterator dependencies, similar to
the concept discussed in section \ref{sect:trans:TD:dependency}, and replacing the cartesian product operator with
something like a natural join operator (section \ref{sect:trans:mxr:basics}).

But MarkXRemove has shorcommings when it comes to evaluating expressions where a sequence constructed with at
least one iterator dependent expression is a subexpression. Tainting Dependencies mend for this by requiring that
all items constituting the result of an iterator dependent expression are iterator dependent. To fulfill til
requirement, dependency tainting is introduced.

\noindent
\begin{myDefinition}
Iterator dependency \textbf{Tainting} is to impose a representation of one expression for each iteration of the
iterators another expression is dependent on.
\end{myDefinition}

During sequence construction, expressions explicitly taint all other expressions part of the construction with
their dependencies. Consider this subexpression:
\begin{center}
\begin{tabular}{l}
\quad \;\, $\vdots$  \\
\texttt{(}$e_{1}$\texttt{, }$e_{2}$\texttt{)}\\
\quad \;\, $\vdots$  
\end{tabular}
\end{center}
Where $e_{1}.\vartheta = \left\{\chi_{1}\right\}$ and $e_{2}.\vartheta = \emptyset$. Here $e_{2}$ will be tainted
by $e_{1}$'s dependency on $\chi_{1}$, but as $e_{2}$ have no dependencies, $e_{1}$ will not be tainted. The
tainting process is carried out by calculating the cartesian product of $e_{2}$ and the $\chi_{1}$$numb$ column of
\texttt{\$}$\chi_{1}$ stored in the symbol table.

More generally, for an sequence constructing expression $e$, \texttt{(}$e_{1}$\texttt{, \ldots, }$e_{n}$\texttt{)},
tainting of an subexpression $e_{i}$ can be expressed like this: \marginpar{\underline{\textbf{\Large TODO:}}
\scriptsize noe \aa~utsette p\aa~bruken av $\Pi$ ?}
\begin{center}
\begin{equation}
\begin{array}{l}
e.\vartheta = e_{1}.\vartheta \cup \ldots \cup e_{n}.\vartheta = \left\{\chi_{1},\ldots\chi_{m}\right\} \\
i \in \left\{1,\ldots,n\right\} \\
\mbox{\textbf{t(r(}}e_{i}\mbox{\textbf{),}}e.\vartheta\mbox{\textbf{)}} = 
\mbox{\textbf{r(}}e_{i}\mbox{\textbf{)}} \times {\displaystyle \prod_{\chi_{j} \in (e.\vartheta -
e_{i}.\vartheta)}} \mbox{\textsf{project(}}\chi_{j}numb\mbox{\textsf{;
}\textbf{get(}}\chi_{j}\mbox{\textbf{)}\textsf{)}}
\end{array}
\label{eq:trans:TD:taint}
\end{equation}
\end{center}

\subsection{Litterals}
\label{sect:trans:TD:litteral}

The XQuery Full Text specification\cite{w3c01} defines a number of literals as seen in figure
\ref{fig:trans:TD:litEBNF}. A \texttt{StringLiteral} is a text string enclosed in apostrophes or quotation marks,
and the numeric literals are similar to numeric types from other programming languages. 

\begin{figure}[h]
\begin{Verbatim}
[85] Literal        ::= NumericLiteral|StringLiteral
[86] NumericLiteral ::= IntegerLiteral|DecimalLiteral|DoubleLiteral
\end{Verbatim}
\caption[Literals in XQuery]{Definition of literals in XQuery Full Text}
\label{fig:trans:TD:litEBNF}
\end{figure}

To be able to include such expressions in evaluation of relational algebra, they need a relational representation.
As we in this chapter assume $value$ is a polymorphic type attribute, with the help of the \textsf{make} operator
translation of literals is done in the following way:

\begin{equation}
\frac{e \in \left\{Literals\right\}}{e}\longmapsto
\mbox{\textsf{make(name:=["index","value"], [1, }}e\mbox{\textsf{])}}
\label{rule:trans:TD:literal}
\end{equation}

This is an general way to translate literals, but there exists quite a few simplifications. Most importantly when
constructing sequences entirely composed of literals, as we will discuss in section
\ref{sect:trans:TD:optimisations}.

\subsection{Sequence Construction}
\label{sect:trans:TD:seqBuild}

A sequence in XQuery can be built with the comma operator --\texttt{,}. But this operator is the XQuery operator
with the lowest precedence, therefore, in most cases a sequence construction expression will be enclosed in
paratheses. This is to solve parser ambiguities, which can be seen in the exerpt of the W3C XQuery Full Text EBNF
specification\cite{w3c01} in figure \ref{fig:trans:TD:seqEBNF}. An \texttt{ExprSingle} can solely consist of a
\texttt{ParenthesizedExpr} via a series of productions omitted from the figure. Also note a \texttt{ExprSingle}
can be a \texttt{FLWORExpr}.

\begin{figure}[h]
\begin{Verbatim}
[33] FLWORExpr         ::= (ForClause | LetClause)+ WhereClause? 
                               OrderByClause? "return" ExprSingle
[45] IfExpr            ::= "if" "(" Expr ")" "then" ExprSingle 
                               "else" ExprSingle
[31] Expr              ::= ExprSingle ("," ExprSingle)*
[89] ParenthesizedExpr ::= "(" Expr? ")"
\end{Verbatim}
\caption[Exerpt from W3C XQuery EBNF]{Exerpt from W3C XQuery EBNF showing sequence construction}
\label{fig:trans:TD:seqEBNF}
\end{figure}

As also can be seen from the figure the for clause of a FLWOR expression, as many other expressions, accepts an
\texttt{ExprSingle}. If a sequence is to be constructed in the for clause, it will have to be parenthesised. 

With the concept of tainting and iterator dependencies explained, we are now ready to introduce the translation of
an XQuery sequence construction expression:

\begin{equation}
\frac{}{e_{1}\mbox{\texttt{, \ldots, }}e_{n}}\longmapsto
\begin{array}{l}
\mbox{\textsf{numberate(index, [sprIdx, index], [}}\vartheta\mbox{\textsf{];}} \\ \quad
\mbox{\textsf{union(}} \\ \quad \quad
\mbox{\textsf{project(sprIdx=1, index, value; }} \\ \quad \quad \quad
\mbox{\textbf{t(r(}}e_{1}\mbox{\textbf{), }}\vartheta\mbox{\textbf{)}\textsf{);}} \\ \quad \quad
\qquad\vdots\\ \quad \quad
\mbox{\textsf{project(sprIdx=}\textit{n}\textsf{, index, value; }} \\ \quad \quad \quad
\mbox{\textbf{t(r(}}e_{n}\mbox{\textbf{), }}\vartheta\mbox{\textbf{)}\textsf{)))}}
\end{array}
\label{rule:trans:TD:seqConstr}
\end{equation}
Where $\vartheta=e_{1}.\vartheta \cup \ldots \cup e_{n}.\vartheta$.

The basis of a sequence construction is the \textsf{union} operator -- as with MarkXRemove. But because we in
Tainted Dependencies have introduced the explicit ordering of items with the $index$ attribute, additional
operations have been added. Each item in the sequences returned from the subexpressions is equipped with a
temporary field $sprIdx$ (superindex) holding the relative position of each subexpression. Based on the
positioning defined by $sprIdx$ and $index$ the \textsf{numberate} operator can now renumberate the resulting
sequence. The numbering must partition on the fields corresponding to the dependencies in $\vartheta$, to separate
the different sequences constructed for all dependent iterations.

\noindent
\begin{myExample}
Consider the simple XQuery query:
\begin{equation*}
\begin{array}{l}
\mbox{\texttt{for \$a in (10,20)}} \\ \quad
\mbox{\texttt{return }} \underbrace{ \mbox{\texttt{(\$a, "no")}} }_{e_{1}}
\end{array}
\end{equation*}

Here \textbf{r(}\texttt{\$a}\textbf{)} will taint \textbf{r(}\texttt{"no"}\textbf{)} with its dependency on the
iterator $I_{a}$, the result of which is shown in figure \ref{fig:trans:TD:simpl:ryes}. Further, we can see that
for each iteration of $I_{a}$ the return clause will return a sequence of two items. Having in mind that $anumb$
($anb$ in figure) holds the iteration number of $I_{a}$, this can be seen in figure \ref{fig:trans:TD:simpl:rall}.

\begin{figure}[!h]
\centering
\subfigure[\textbf{r(}\texttt{\$a}\textbf{)}]{
\begin{tabular}{|c|c|c|} \hline
$anb$ & $idx$ & $val$ \\ \hline
1 & 1 & 10 \\ \hline
2 & 1 & 20 \\ \hline
\end{tabular}
\label{fig:trans:TD:simpl:ra}
}
\qquad
\subfigure[\textbf{t(r(}\texttt{"no"}\textbf{),}\textbf{r(}\texttt{\$a}\textbf{)}$.\vartheta$\textbf{)}]{
\begin{tabular}{|c|c|c|} \hline
$anb$ & $idx$ & $val$ \\ \hline
1 & 1 & \texttt{"no"} \\ \hline
2 & 1 & \texttt{"no"} \\ \hline
\end{tabular}
\label{fig:trans:TD:simpl:ryes}
}
\qquad
\subfigure[\textbf{r(}\texttt{(\$a, "no")}\textbf{)}]{
\begin{tabular}{|c|c|c|} \hline
$anb$ & $idx$ & $val$ \\ \hline
1 & 1 & 10 \\ \hline
2 & 1 & 20 \\ \hline
1 & 2 & \texttt{"no"} \\ \hline
2 & 2 & \texttt{"no"} \\ \hline
\end{tabular}
\label{fig:trans:TD:simpl:rall}
}

\caption[Example: constructing a sequence]{Applying translation rule \ref{rule:trans:TD:seqConstr} on (a) and (b)
yields (c). Attribute names are shortened \label{fig:trans:TD:simpleSeq}}
\end{figure}

The sequence constructing rule also holds even if the subexpressions of the soon-to-be sequence are within the
body of an iterator the sequence is not dependant on. Expanding the last example query we get:
\begin{equation*}
\begin{array}{l}
\mbox{\texttt{for \$a in (10,20)}} \\ \quad
\mbox{\texttt{for \$b in (50,75)}} \\ \quad \quad
\mbox{\texttt{return }} \underbrace{ \mbox{\texttt{(\$a, "no")}} }_{e_{1}}
\end{array}
\end{equation*}

Notice the innermost return clause expression, $e_{1}$, is identical to $e_{1}$ in the previous query. Here, the
result of the sequence construction will still be the relation shown in figure \ref{fig:trans:TD:simpl:rall},
because $e_{1}.\vartheta=\left\{a\right\}$ -- also as before. $e_{1}$ is not aware of the iterator $I_{b}$ -- and
does not need to be either, as the result of $e_{1}$ is independent of which iteration number $I_{b}$ is in.

\end{myExample}


\subsection{FLWOR Expressions}
\label{sect:trans:TD:simpleFLWOR}
From the XQuery specification exerpt of figure \ref{fig:trans:TD:seqEBNF}, we see that a flwor expression may
appear in many different formats. In this section we will break the expression down in more manageable pieces and
show the translation of the different aspects.

Described in \ref{sect:theory:xquery:Flwor}, with a \texttt{for} clause the XQuery flwor expression has an
iteration semantics. For each item in the sequence in the \texttt{for} clause (the iteration sequence), the item
will be bound to a variable (the iteration variable) and the expression in the \texttt{return} clause (the
iteration body) will be executed. The \texttt{let} clause does however not imply any iteration, only variable
binding, and can therefore be translated into storing the algebraic version of the expression to be bound in the
symbol table:
\begin{equation}
\frac{}{\mbox{\texttt{let \$}}\chi \mbox{\texttt{ := }}e \mbox{\texttt{ \ldots}}}\longmapsto
\mbox{\textbf{put(}}\chi\mbox{\textbf{, r(}}e\mbox{\textbf{))}}
\label{rule:trans:TD:let}
\end{equation}
The iterator dependences $\vartheta$ of $e$ is stored along with \textbf{r(}$e$\textbf{)} and will piggyback this
algebra tree if it later fetched from the symbol table. If there is more than one variable binding in the
\texttt{let} clause the rule must be applied once per binding as if one binding were one \texttt{let} clause.

Binding of variables in the \texttt{for} clause is shown in rule \ref{rule:trans:td:forclause} in section
\ref{sect:trans:TD:dependency}.

Because of tainting and iterator dependency inheritance, an iterator body expression dependent on $I_{\chi}$ will
have a representation for each iteration of the iterator.

\begin{itemize}
  \item bare for e1 in e2 return e3
  \item where
  \item order (enkel) kan v\ae re spr\o
\end{itemize}

\subsection{Arithmetic Expressions}
\label{sect:trans:TD:atrith}
\begin{itemize}
  \item arithmetic operators (+, -, \%,\ldots)
  \item idiv mod div
  \item unary expr -/+
\end{itemize}

\subsection{Comparative Expressions}
\label{sect:trans:TD:compArit}
\begin{itemize}
  \item value comparators (eq, ne, lt\ldots)
  \item general comparators (>, <, = \ldots)
  \item project ikke select, men hvis ikke lambda\ldots s\aa~select? funker det? Har vi finni en optimalisering?
  \item fordi noe over vil kanskje ha negativen\ldots f.eks ifthenelse og not()  \item 
\end{itemize}

\subsection{Logical Operator Expressions}
\label{sect:trans:TD:logical}
\begin{itemize}
  \item and
  \item or
\end{itemize}

\subsection{Path Expressions}
\label{sect:trans:TD:pathExprs}
\begin{itemize}
  \item axes
  \item samling av child axes /a/b/c/d -> ikke e1/e2
  \item i logical context -> outer join
\end{itemize}

\subsection{Predicates}
\label{sect:trans:TD:predicates}
\begin{itemize}
  \item isNumber() ifThenElse xqBoolean()
  \item contextnode p\aa~boks\ldots trengs dette alltid? Strengt tatt.. veldig vanskelig \aa~vite n\aa r man
  garantert ikke trenger den iallefall\ldots
\end{itemize}

\subsection{Conditional Expressions}
\label{sect:trans:TD:ifThenElse}
\begin{itemize}
  \item if(e1) then else
  \item e1 er i logical context..
\end{itemize}

\subsection{Full Text Expressions}
\label{sect:trans:TD:fulltext}
\begin{itemize}
  \item lookup.. passe p\aa~ contextnode
\end{itemize}

\subsection{other Th1ngz:}
\begin{itemize}
  \item node comparisons\ldots\ldots tviler p\aa~at vi f\aa r til dette glatt\ldots
  \item constructors\ldots element, CDATA, attribute etc etc
\end{itemize}


\subsection{Optimisations}
\label{sect:trans:TD:optimisations}
\begin{itemize}
  \item sekvenser:
	  \begin{itemize}
	    \item suprIndx kan doppes n\aa r bare singelton
	    \item singeltons trenger ikke index
      \end{itemize} 
  \item Litterals: 
		\begin{itemize}
          \item implies that any sequence of
				explicitly stated items will first have to be made as one-tuple relations and
				then spliced together. As the \textsf{make} operator supports multiple items, a
					better solution would be to collect all items in one MQL operator. Further, if
					the item is part of a singleton sequence, there is no need for a representation
					in form of an relation, as the item could be made part of the parameters of an
					operator (e.g. $\alpha$ \texttt{> 1} $\Longrightarrow$
					\textsf{select(gt(value, 1) $\alpha$)}).   
        \end{itemize}
  \item FLWOR:
  	\begin{itemize}
        \item  kan bli -> project , ved singelton return
      \end{itemize}         
\end{itemize}