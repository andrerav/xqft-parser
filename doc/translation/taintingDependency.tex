\newpage
\section{Tainting Dependencies}
\label{sect:trans:taintingDependencies}

\begin{itemize}
  \item \textbf{\LARGE TODO:} det er en newpage p\aa~denne siden
  \item INTRO for teh wind
  \item har vokst ut av MarkXRemove
  \item Tainting dependencies (TD)
  \item og mer text
\end{itemize}

\subsection{Inference Rule Language Explanation}
\label{sect:trans:TD:langExpl}
\underline{\textbf{\LARGE TODO:}} Skal jeg bruke greske bokstaver i stedet for tekstlig marsgreie n\aa r jeg
skriver regler?

During this chapter we will present some inference rules. In this section we will explain the various
typographical representations.

\begin{table}[h]
\begin{tabular}{l|l}

  $\longmapsto$  			& Translates into \\
  $\vartheta$ 				& A set of iteration variable references \\
  \textsf{sans serif} 		& MQL expressions \\
  \texttt{monospaced} 		& XQuery expressions \\
  $e,\ldots,e_{n}$			& Generic expressions \\
  $\chi,\ldots,\chi_{n}$	& Generic variable names \\
  $I_{\chi}$				& The iterator expression which declares $\chi$ \\
  \textbf{bold} 			& Operations done during the generation of the algebra \\
  \textbf{r(}$e$\textbf{)} 	& Returns the relational algebraic representation of $e$   \\
  \textbf{t(}\textbf{r(}$e$\textbf{)}\textbf{,}$\vartheta'$\textbf{)} & Returns \textbf{r(}$e$\textbf{)} tainted
  with the dependencies $\vartheta'$ \\
  $\Delta$ 					&  The default context \\ 
  $\Lambda$ 				& The logical/boolean context \\
  
\end{tabular}
\caption{Explanation of inference rule symbols}
\label{tab:trans:td:langExpl}
\end{table}

Inference rules are generally in this format:
\begin{equation*}
\frac{\mbox{\textbf{cxt}}\vdash cond}{e}\longmapsto \mbox{\textbf{r(}}e\mbox{\textbf{)}}
\end{equation*}

This should be read as: in the context of \textbf{cxt}, if condition $cond$ is satisfied, the XQuery expression
$e$ will be translated into \textbf{r(}$e$\textbf{)}.

The translator is in the logical context, $\Lambda$, if the AST node it is currently visiting is a successor of a
boolean operator or within the condition part of an \texttt{if..then..else} expression. In all other cases the
translator is in the default context, $\Delta$. If no context is mentioned in the inference rules the default
context is assumed.

\input{translation/TD/BasicsDepTaint.tex}
\input{translation/TD/LitAndSequence.tex}
\input{translation/TD/FLWOR.tex}

\subsection{Arithmetic Expressions}
\label{sect:trans:TD:atrith}
\begin{itemize}
  \item arithmetic operators (+, -, \%,\ldots)
  \item idiv mod div
  \item unary expr -/+
\end{itemize}

\subsection{Comparative Expressions}
\label{sect:trans:TD:compArit}
\begin{itemize}
  \item value comparators (eq, ne, lt\ldots)
  \item general comparators (>, <, = \ldots)
  \item project ikke select, men hvis ikke lambda\ldots s\aa~select? funker det? Har vi finni en optimalisering?
  \item fordi noe over vil kanskje ha negativen\ldots f.eks ifthenelse og not()  \item 
\end{itemize}

\subsection{Logical Operator Expressions}
\label{sect:trans:TD:logical}
\begin{itemize}
  \item and
  \item or
\end{itemize}

\subsection{Path Expressions}
\label{sect:trans:TD:pathExprs}
\begin{itemize}
  \item axes
  \item samling av child axes /a/b/c/d -> ikke e1/e2
  \item i logical context -> outer join
\end{itemize}

\subsection{Predicates}
\label{sect:trans:TD:predicates}
\begin{itemize}
  \item isNumber() ifThenElse xqBoolean()
  \item contextnode p\aa~boks\ldots trengs dette alltid? Strengt tatt.. veldig vanskelig \aa~vite n\aa r man
  garantert ikke trenger den iallefall\ldots
\end{itemize}

\subsection{Conditional Expressions}
\label{sect:trans:TD:ifThenElse}
\begin{itemize}
  \item if(e1) then else
  \item e1 er i logical context..
\end{itemize}

\subsection{Full Text Expressions}
\label{sect:trans:TD:fulltext}
\begin{itemize}
  \item lookup.. passe p\aa~ contextnode
\end{itemize}

\subsection{other Th1ngz:}
\begin{itemize}
  \item node comparisons\ldots\ldots tviler p\aa~at vi f\aa r til dette glatt\ldots
  \item constructors\ldots element, CDATA, attribute etc etc
\end{itemize}


\subsection{Optimisations}
\label{sect:trans:TD:optimisations}
\begin{itemize}
  \item sekvenser:
	  \begin{itemize}
	    \item suprIndx kan doppes n\aa r bare singelton
	    \item singeltons trenger ikke index
      \end{itemize} 
  \item Litterals: 
		\begin{itemize}
          \item implies that any sequence of
				explicitly stated items will first have to be made as one-tuple relations and
				then spliced together. As the \textsf{make} operator supports multiple items, a
					better solution would be to collect all items in one MQL operator. Further, if
					the item is part of a singleton sequence, there is no need for a representation
					in form of an relation, as the item could be made part of the parameters of an
					operator (e.g. $\alpha$ \texttt{> 1} $\Longrightarrow$
					\textsf{select(gt(value, 1) $\alpha$)}).   
        \end{itemize}
  \item FLWOR:
  	\begin{itemize}
        \item  kan bli -> project , ved singelton return
    	  \item order by kan puttes inn i for-regelen egentlig (kanskje?)
      \end{itemize}         
\end{itemize}