\newpage
\section{Tainting Dependencies}
\label{sect:trans:taintingDependencies}

\begin{itemize}
  \item \textbf{\LARGE TODO:} det er en newpage p\aa~denne siden
  \item INTRO for teh wind
  \item har vokst ut av MarkXRemove
  \item Tainting dependencies (TD)
  \item og mer text
\end{itemize}

\subsection{Inference Rule Language Explanation}
\label{sect:trans:TD:langExpl}
\underline{\textbf{\LARGE TODO:}} Skal jeg bruke greske bokstaver i stedet for tekstlig marsgreie n\aa r jeg
skriver regler?

During this chapter we will present some inference rules. In this section we will explain the various
typographical representations.

\begin{table}[h]
\begin{tabular}{l|l}

  $\longmapsto$  			& Translates into \\
  $\vartheta$ 			& A set of iteration variable references \\
  \textsf{sans serif} 	& MQL expressions \\
  \texttt{monospaced} 	& XQuery expressions \\
  $e,\ldots,e_{n}$		  	& Generic expressions \\
  $\chi, \Upsilon$		& Generic variable names \\
  $I_{\chi}$			& The iterator expression which declares $\chi$ \\
  \textbf{bold} 		& Operations done during the generation of the algebra \\
  \textbf{r(}$e$\textbf{)} & A function transforming the expression $e$ into relational algebra \\
  $\Delta$ 				& The default context \\
  $\Lambda$ 			& The logical/boolean context \\
  
\end{tabular}
\caption{Explanation of inference rule symbols}
\label{tab:trans:td:langExpl}
\end{table}

Inference rules are generally in this format:
\begin{equation*}
\frac{\mbox{\textbf{cxt}}\vdash cond}{e}\longmapsto \mbox{\textbf{r(}}e\mbox{\textbf{)}}
\end{equation*}

This should be read as: in the context of \textbf{cxt}, if condition $cond$ is satisfied, the XQuery expression
$e$ will be translated into \textbf{r(}$e$\textbf{)}.

The translator is in the logical context, $\Lambda$, if the AST node it is currently visiting is a successor of a
boolean operator or within the condition part of an \texttt{if..then..else} expression. In all other cases the
translator is in the default context, $\Delta$. If no context is mentioned in the inference rules the default
context is assumed.

\subsection{Basics}
\label{sect:trans:TD:basics}
The method assumes left-to-right traversal of the assymetric syntax tree. In most cases the traversal is
postorder, meaning a subtree can be evaluated independently from its ancestors. The exception being the logical
context set by boolean operators. In addition to the evaluated subtree, a node must be able to inform its parent
node about its variable dependencies ($\vartheta$), which we will discuss later.

One XQuery sequence is represented as one relation and one XQuery item is represented as one tuple. This is sound,
as all XQuery items are sequences, and all sequences are one-dimensional (section
\ref{sect:theory:xquery:basics}). As we mentioned in section \ref{sect:trans:MarkXRemove}, the MarkXRemove method
did actually not consider the ordering of items in sequences at all. In Tainting Dependencies, however, we have
introduced an attribute $index$ holding the intra sequence number of the item. Consider the XQuery sequence
\texttt{('a','b',}$\ldots$\texttt{,'z')}. With this attribute, the relational representation will be as follwing:

\begin{center}
\begin{tabular}{|c|c|} \hline
$index$ & $value$ \\\hline
1		& \texttt{'a'} \\\hline
2		& \texttt{'b'} \\\hline
$\ldots$& $\ldots$ \\\hline
$n$		& \texttt{'z'} \\\hline
\end{tabular}
\end{center}


As can be seen, the item value is stored in the $value$ attribute. For the course of this chapter we will, for the
sake of simplicity, treat $value$ as a polymorphic type attribute. This simplification has minimal consequences
for the method and the way XQuery expressions are translated. XQuery types and relational representation of such
will is handled in section \ref{sect:disc:typeSystem}. \marginpar{\textbf{\LARGE TODO:} noen andre steder?.}

Also for simplicity, the $documentId$, $pos$ and $scope$ attributes have been left out of the
fields specified in \textsf{project} operators. If the \textsf{project} operator is applied to the result of a
join or cartesian product, these fields will follow the $value$ attribute. That is, if $r.value$ is projected,
then so is $r.documentId$, etc\ldots if applicable.

Tainting Dependencies utilises a symbol table for storing of variables declared. The table has two functions:
\begin{itemize}
  \item \textbf{put(}$\chi$\textbf{, }\textbf{r(}$e$\textbf{))} -- will store the
  algebraic version of the expression bound to the variable \texttt{\$}$\chi$ with $\chi$ as the key.  
  \item \textbf{get(}$\chi$\textbf{)} -- will do a lookup in the table based on the name of the variable
  \texttt{\$}$\chi$ and return the algebraic version of the expression linked to it.
\end{itemize}
The symbol table handles scoping according to XQuery semantics (section \ref{sect:theory:xquery:Flwor}), meaning
the translator will always be able to find the right declared variable based on which node in the AST the
translator is visiting.

\subsection{Iterator Variable Dependency}
\label{sect:trans:TD:dependency}

The concept of iterator variable dependency form the basis of the Tainting Dependency method. Such dependency is
defined as follows:
\mbox{} \\
\begin{myDefinition}
An XQuery expression $e$ is \textbf{dependant} on an iterator variable \texttt{\$}$\chi$ if is dependant on the
value of \texttt{\$}$\chi$.
\end{myDefinition}

Consider the following example where \texttt{\$x} and \texttt{\$y} both are iterator variables:
\begin{center}
\begin{equation*}
\begin{array}{l}
\qquad \qquad \vdots \\
\mbox{\texttt{if(\$x = 2) then}} \\ \qquad
	\mbox{\texttt{\$y}} \\ 
\mbox{\texttt{else}} \\ \qquad 
	e_{1} \\
\qquad \qquad \vdots
\end{array}
\end{equation*}
\end{center}

Here, the expression $e_{1}$ is \textit{not} dependant on the variabe \texttt{\$y}, but \textit{is}, however,
dependant on \texttt{\$x}.

\underline{\textbf{\Large TODO:}} Hva skjer med it variable dependency vs iterator dependency?

\begin{itemize}
  \item $\chi$numb and the likes
  \item definisjon
  \item m\aa~f\o lge settene p\aa~en eller annen m\aa te.. varRefs
  \item det betyr at den er avhengig av iterasjon
  \item gi eksempel
\end{itemize}

\subsection{Tainting Dependencies}
\label{sect:trans:TD:tainting}
\begin{itemize}
  \item hvis \textbf{en} av items er avhengig\ldots
  \item betyr jo at settet er avhengig av iterasjon-> posisjon og ting, fordi den skal brukes til noe
  \item definisjon
  \item vis hvordan tainting foreg\aa r ->
  \item Forced Dependency Tainting\ldots hvis man kommer til 
\end{itemize}

\subsection{Sequence Building}
\label{sect:trans:TD:seqBuild}
\begin{itemize}
  \item hvordan bygge sekvenser
  \item forst enkelt
  \item s\aa~med tainting
\end{itemize}

\subsection{Simple FLWORs}
\label{sect:trans:TD:simpleFLWOR}
\begin{itemize}
  \item bare for e1 in e2 return e3
  \item ta where og order by senere\ldots
\end{itemize}

\subsection{Optimisations}
\label{sect:trans:optimisations}
\begin{itemize}
  \item skal vi ha det her, eller i discussion?
  \item kanskje begge deler\ldots. Her kommer en liste som kan bygges p\aa~etterhvert iallefall:
	  \begin{itemize}
	    \item suprIndx kan doppes n\aa r bare atomiske (singelton er vel bedre begrep)
	    \item for kan bli -> project , ved singelton return
	    \item singeltons trenger ikke index
	  \end{itemize} 
\end{itemize}