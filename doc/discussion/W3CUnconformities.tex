\section{W3C Specification Unconformities}
\label{sect:future:knownBugs}
Because of lack of time, our parser is yet not completly in accordance with the W3C XQuery Full-Text specification in some aspects. Here we present these, aswell as an outline of a potential way of accomomodating them:

\begin{itemize}
\item \textbf{Late State Transitions} -- Our state driven lexer depends upon the parser telling it which state it is in before it generates a token. This means that in cases where the parser uses a look-ahead big enough to make the lexer cross a "state border", the lexer may be in the wrong state according to the input stream (remember, the parser is always \emph{behind} the lexer, and "moves" \emph{after} looking ahead). ANTLR generates a parser using as small a look-ahead necessary, but in some cases this is not enough, making e.g. queries as \verb!<a>{ns:name()}</a>! fail. However, the corresponding query without the namespace prefix, or a prefixed function call outside of a \verb!{ }! does not fail. Moving the parser closer to LL(1), as mentioned in \ref{sect:future:improvements}, will solve this bug.

\item \textbf{Incorrect QNames} (ref. section \ref{sect:implementation:xmlVersion}) -- The parser allows whitespace between the prefix and the colon sign, and between the colon sign and the localname in XML qualified names. This can be solved by turning the non-terminal rule \verb!qName! into a terminal production.

\item \textbf{Whitespace in Tags} (ref. section \ref{sect:implementation:whitespace}) -- The parser allows whitespace between the initial \verb!<! of a tag and the element name. This can be solved by introducing a new terminal production for the start-of-tag-sign (to separate it from the less-than sign), e.g. like this: \verb!TagStart : LTSi QName!, and letting this production emit subtokens (section \ref{sect:implementation:emittingMoreTokens}).

\item \textbf{Incorrect Element Nesting} (ref. section \ref{sect:implementation:xmlVersion}) -- The parser allows inpropper nesting of elements, e.g. \verb!<a><b></a></b>!. It does, however, not allow a mismatch between the number of start tags and the number of end-tags. A simple solution to only allow correct nesting would be to push the names of a start tags to a stack, and for each end tag assure that this tags name is the same as the one pop'ed from the stack.

\item \textbf{Contradicting Match Options} (ref. section \ref{sect:implementation:multipleMatchOptions}) -- The parser allows contradicting full-text match options, e.g. \verb!"dog" with stemming without stemming!. This can be solved by rewriting the grammar: by making potentially contradicting options alternatives to a production, and an the higher level rule allows only zero or one occurence \emph{per} such production.

\item \textbf{Reserved Keywords} -- The parser does not allow function or variables with the same name as any keyword, e.g. \verb!$for := 1;! is illegal. This can be solved by introducing a non-terminal rule that has all the keywords as well as \verb!NCName! as alternatives. All references to \verb!NCName! would then have to be replaced with references to this new rule. This would, however, lead to parser non-determinisms, meaning that we would have to augment many non-terminal productions with syntactic predicates.

\end{itemize}

\underline{\textbf{\LARGE //ODOT:}}Andreas, har du noe \aa~ legge til?
