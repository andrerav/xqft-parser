\section{Design Decisions}
\label{sect:discussion:designDecisions}

Of the alternatives in section \ref{sect:ambiguousgrammar:ambigTerm}, we ended up, as previously mentioned, on the parser controlled state driven lexer alternative. This strategy depends upon the lexer not generating any tokens before they are needed by the parser, dealt with by our implementation of \verb!UnbufferedCommonTokenStream!, and that most terminal alternatives are augmented with semantic predicates controlling which alternatives are available in which state.

\subsection{Parser Controlled Lexer}
Making the lexer emit one and one token instead of processing the input as a whole, most probably leads to a slightly prolonged execution time as the runtime controll will be shunted between the parser and lexer multiple times per query parsed. Yet we do not belive that this will cause too much problems as input queries are approximated to be about one hundred lines long. The eXist XML database system(section \ref{sect:stateOfTheArt:eXist}) also employs a parser controlled strategy, showing that it is applicable in real world situations.

The option would be to implement a pure state driven lexer. This would let the lexer operate completely autonomous, though at the cost of a much more complex control structure than is the case of the parser controlled solution. All in all this strategy would probably not lead to any significant performance gain, but rather the oposite. In addition, as mentioned in section \ref{sect:amiguousgrammar:stateDriven}, we made a prototype with this strategy for a subset of XQuery, and decided that this would be a quite complicated task for the full version of the grammar -- a task that would result in a greater deal of time being consumed by implementing and bug-fixing.

Our grammar, by being dependant on our custom token stream, would render gUnit(section \ref{sect:method:gUnit}) and ANTLRWorks(section \ref{sect:method:debugging}) a greatly diminished utility value. This is because these tools both depend on their own proprietary token stream implementation. The reducing of the unit testing capabilities were not a big loss however, as they were mended by the manual covrage tests, which in fact proved to be a simpler and more thorough way of testing our parser. 

The deprication of ANTLRWorks is not such a great loss either; because of its instability, it never was the grammar editor of choice. Furthermore, the drawing of syntax diagrams -- a handy way of resolving non-determinisms in the parser -- is done during grammar compile time, and is therefore still functional. And finally, by tricking the application with a simple hack, it can still parse input and draw the corresponding parsing tree, though not in a step-by-step manner.

\subsection{State Driven Lexer}

The states of our lexer is implemented by gated semantic predicates and the \verb!TOKENSWITCH! construct. This may have made our grammar quite complex and less easily readable. An alternative to this approach would be to write the lexer by hand. In this way we could have made a much easier state controll structure, with a more complete division between each states functionallity. But future modificatibility would be a problem, as a lot rewriting would be necessary for even the simplest change in grammar semantics.

Using island grammars (section \ref{sect:amiguousgrammar:islandGrammar}) would render each subgrammar very simple and readable. Simple grammars intuitively also generates simple recognizers, giving an additional benefit in performace time. Though a performace overhead would come in form of switching between the lexers, we belive this is significantly outweighted by the gain by having completly unambiguous grammars. The catch is that using multiple lexers are not naitively supported by ANTLR as of yet, and the tampering needed to make this work is something we are not prepared to do. If however ANTLR is to include this in the near future, we will alter the grammar accordingly.

As there are only a few productions that are available per state, exept for in the \verb!DEFAULT! state, a third option would be a hybrid of island grammars and writing the lexer by hand. In this solution, a lexer rule not a member of this state would be removed from the grammar, and be replaced by corresponding handwritten lexer in the form of a method in the lexer class called by a inline action in the ANTLR grammar. The problem with this option is that much of the lexer specification would not be in form of ANTLR grammar, thus decreasing readability and ease of change. Another issue would be that the manual lexer would have to conform to the ANTLR generated lexer's manner of operation with regards to generating tokens, handling the inputstream and pointers etc., which may not be a trivial task to implement.