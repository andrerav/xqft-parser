\section{Target Relational Algebra Language}
\label{sect:method:mql}
The target algebra for this project is a dialect of relational algebra (see
section \ref{sect:theory:relAlg}) developed by FAST Search \& Transfer. The
language is dubbed MQL (Mars Query Language). This section will describe the
operators of this language as well as the indexes they operate on, and will
demonstrate some important traits of this language with a few examples. 

TODO: kanskje ordne en referanse til FAST p\aa~en eller annen m\aa~te slik at
sensoren kan ordne seg en kopi av mql-dokumentet. Ogs\aa~nevne at greiene var
konfidensielle.

\subsection{General concepts}
\label{sect:method:mql:indexes}
\label{sect:method:mql:concepts}
All queries for MQL are written as strings with a syntax reminiscient of Lisp
dialects. TODO: kodeeksempel + relalgtre?

\marginpar{\underline{\Large TODO} \footnotesize Er ikke helt sikker, men tror den heter value occurence index,
value index er en tredje type, som vi ikke kommer til \aa~bruke? Valocc er en
hypotetisk index, kan sikkert presisere det} Data is stored in \textit{indexes}
rather than in DOM trees. Naturally, this is a prerequisite for efficient execution of relational algebra on the data. There are two basic index types: \textit{occurence} indexes and \textit{value}
indexes. In the case of an occurence index, a lookup for a term will map the
term to the occurences of this term. In a \textit{value} index, a key (for
example document id) is associated to one or more \textit{values} in the
document collection. Lookups in \textit{value} indexes can be combined with
lookups in \textit{occurence} indexes to add data to the result set for the
user.

The schema of the indexes determins the fields/columns in the result sets from
a lookup, but typically these three fields will be included on a lookup of a
term in the \textit{occurence} index:
\begin{itemize}
  \item Document ID: Internal identifier for the document in which the term
  occurs
  \item Position: The term position in the document (counted by terms, not
  characters or nodes)
  \item Scope: the context of the occurence, e.g \texttt{/a/b}. Note that the
  scope also contains metadata about the \textit{instance} of the scope
\end{itemize}

Hvordan skal man egentlig formulere seg her slik at Oystein ikke blir trist og
lei?

\begin{itemize}
  \item hvilke indexer bruker vi..
  \item hvordan ser resultatsettene ut n\aa r vi sp\o r i disse indexene?
  \item Vi regner med at oppslag i valloc gir {documentId, pos, scope, value} (tror ikke den egentlig heter value,
  men heller navnet p\aa~scopet) og at scope holder inkludert seg selv -> alts\aa~at noe som: <a> hei </a> er
  lagret som {value = ``hei'', scope = a}. Hvis dette er umulig m\aa~vi forutsette en project for hver gang.. kan
  ikke la det feltet hete hva det vil\ldots\ldots\ldots
\end{itemize}

\subsection{Language syntax}
The syntax of MQL (Mars Query Language) is, as mentioned above, reminiscent of
Lisp dialects. Consider the example in figure \ref{figure:mql:op_example}. This
example will lookup the term ``c'' in the scope \texttt{/a/b} in the index
\textit{valocc}\footnote{The index \textit{valocc} is a hypothetical index
which is simply thought to be a combined lookup in an \textit{occurence}
index and a \textit{value} index}.

\begin{figure}[!h]
\centering
\begin{Verbatim}
index(valocc; 
  scope(/a/b;
    lookup(c)));
\end{Verbatim}
\caption{Simple MQL example}
\label{figure:mql:op_example}
\end{figure}

The syntax for MQL can be described in a condensed form using EBNF notation as
can be seen in figure \ref{figure:mql:ebnf}
\begin{figure}[!h]
\centering
\begin{Verbatim}
OPERATORNAME  ::= IDENTIFIER
OPERATOR      ::= OPERATORNAME "(" PARAMETERLIST? 
                  (";" OPERATORLIST)? ")"
OPERATORLIST  ::= OPERATOR ( "," OPERATOR )*
\end{Verbatim}
\caption{Simplified MQL EBNF}
\label{figure:mql:ebnf}
\end{figure}

Note that \texttt{PARAMETERLIST} has no definition. This production will be
described for each operator, if applicable.

Also note that parameters and child operators are separated by a semicolon. For
example, in the MQL expression \texttt{index(valocc;lookup(hairdresser))} the
\texttt{index()} operator is given one parameter (\textit{valocc}) and one
child operator (\textit{lookup(hairdresser)}).

\subsection{Operators}
\label{sect:method:marsOperators}
\subsubsection{Lookup}
\label{sect:method:marsOperators:lookup}
The \texttt{lookup()} operator performs a lookup in the default index (if none
other defined by an \texttt{index()} operator, see
\ref{sect:method:marsOperators:index}). The result set returned from this
operator contains all occurences of the given term, if any. This operator will
use the last index specified by the \texttt{index()} operator, otherwise the
default index. See figure \ref{figure:mql:op_example} for an example of usage. 

\subsubsection{Scope}
\label{sect:method:marsOperators:scope}
The \texttt{scope()} operator accepts one parameter and one child operator. The
result set from the child operator is filtered to match the first parameter, which is a
scope given on a form similar to a XPath expression. See figure
\ref{figure:mql:op_example} for an example of usage. 

\subsubsection{Index}
\label{sect:method:marsOperators:index}
This operator modifies the behaviour of the child operator such that any lookup
will use the specified index. See figure \ref{figure:mql:op_example} for an
example of usage where the child operators will operate on the index
\textit{valocc}.

\subsubsection{Project}
\label{sect:method:marsOperators:project}
\marginpar{\underline{\Large TODO} \footnotesize rename - project combo egentlig}
The \texttt{project()} operator lends its name and semantics from the project
operator known from basic relational algebra (projection is described in
section \ref{sect:theory:relAlg:projection}). The \texttt{project()} operator
has a more complex syntax described in EBNF notation in figure
\ref{figure:mql:ebnf:project_ebnf}.

\begin{figure}[!h]
\centering
\begin{Verbatim}
RESULTFIELD  ::= IDENTIFIER
ARGUMENTS    ::= ARGUMENTDEF ( "," ARGUMENTDEF )*
ARGUMENTDEF  ::= ( RESULTFIELD "=" )? ARGUMENT
RETAIN_PARAM ::= "retain:=" BOOLEAN
OPERATOR     ::= "project" "(" (RETAIN_PARAM ",")? 
                 ARGUMENTS ";" OPERATOR ")"
\end{Verbatim}
\caption{Project operator EBNF}
\label{figure:mql:ebnf:project_ebnf}
\end{figure}
Consider the trivial example in \ref{figure:mql:project_example} which is an
extension of the example in figure \ref{figure:mql:op_example}. This will
project the result set on the field \texttt{DocumentID}, and rename it to
\texttt{id}. 

\begin{figure}[!h]
\centering
\begin{Verbatim}
project(id=DocumentID;
  index(valocc; 
    scope(/a/b;
      lookup(c))));
\end{Verbatim}
\caption{Simple MQL \texttt{project()} example}
\label{figure:mql:project_example}
\end{figure}

Note that it is also possible to execute functions and apply constant values to
the projection. The example in figure \ref{figure:mql:project_example2} may
produce an output similar to that of figure
\ref{figure:mql:project_example2_result}.

\begin{figure}[!h]
\centering
\begin{Verbatim}
project(id=DocumentID, cid=max(100,DocumentID), one="1");
  index(valocc;
    scope(/a/b;
      lookup(c))));
\end{Verbatim}
\caption{Simple MQL \texttt{project()} example with inline function call 
and an applied constant field}
\label{figure:mql:project_example2}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tabular}{|c | c | c |}
\hline
id & cid & one \\ \hline
45 & 100 & 1 \\ \hline
103 & 103 & 1 \\ \hline
90 & 100 & 1 \\ \hline
33 & 100 & 1 \\ \hline
289 & 289 & 1 \\ \hline
\end{tabular}
\caption{Hypothetical result of query in figure
\ref{figure:mql:project_example2}}
\label{figure:mql:project_example2_result}
\end{figure}

\subsubsection{Select}
The \texttt{select()} operator filters tuples from the child operator based on
boolean function predicates. Consider the example in figure
\ref{figure:mql:select_example}, where eq() compares the two parameters and
returns \textit{true} if the parameters are equal. A hypothetical result (based
on the example for \texttt{project()}) can be seen in figure
\ref{figure:mql:select_example_result}.

\begin{figure}[!h]
\centering
\begin{Verbatim}
select(eq(100, cid);
  project(id=DocumentID, cid=max(100,DocumentID), one="1");
    index(valocc;
      scope(/a/b;
        lookup(c)))));
\end{Verbatim}
\caption{Simple MQL \texttt{select()} example}
\label{figure:mql:select_example}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tabular}{|c | c | c |}
\hline
id & cid & one \\ \hline
45 & 100 & 1 \\ \hline
90 & 100 & 1 \\ \hline
33 & 100 & 1 \\ \hline
\end{tabular}
\caption{Hypothetical result of query in figure
\ref{figure:mql:select_example}}
\label{figure:mql:select_example_result}
\end{figure}

\subsubsection{Join}
A join operator (one of \texttt{hhjoin()}, \texttt{hljoin()}, or
\texttt{mergejoin()}) performs an equi-join operation as described in section
\ref{sect:theory:relAlg:equiAndThetaJoin}. In the case of a
\texttt{mergejoin()}, the input result set must be sorted. The complete syntax
for any of the join operations can be described with EBNF notation as can be
seen in figure \ref{figure:mql:ebnf:join}.
\begin{figure}[!h]
\centering
\begin{Verbatim}
JOINFIELD    ::= ("left." | "right.")? FIELDNAME
PROJECTFIELD ::= (FIELDNAME "=")? JOINFIELD
PROJECTLIST  ::= PROJECTFIELD ("," PROJECTFIELD)*
JOINNAME     ::= "hhjoin" | "hljoin" | "mergejoin"
OPERATOR     ::= JOINNAME "(" "[" FIELDLIST "]" "," 
                 "[" FIELDLIST "]" "," "[" PROJECTLIST "]"
                  ("," "left" | "right" | "full")? ";"
                  OPERATOR "," OPERATOR ")"
\end{Verbatim}
\caption{Join operator EBNF}
\label{figure:mql:ebnf:join}
\end{figure}
A trivial usage example of the \texttt{mergejoin()} operator can be seen in
figure \ref{figure:mql:mergejoin_example}, where the result sets from two
hypothetical child operators \texttt{Query1()} and \texttt{Query2()} is joined
on their document ids, and the result is projected on the
fields \textit{DocumentID} and \textit{Position}.

\begin{figure}[!h]
\centering
\begin{Verbatim}
mergejoin([DocumentID], [DocumentID], [DocumentID, Position]; 
  Query1(..),
  Query2(..))
\end{Verbatim}
\caption{Simple MQL \texttt{mergejoin()} example}
\label{figure:mql:mergejoin_example}
\end{figure}


\subsubsection{Make}
The \texttt{make()} operator is used to synthesize result sets from the given
(constant) arguments. Field names can be specified, but are not required. The
default field names are \textit{field0}, \textit{field1}, \ldots,
\textit{fieldN}, where \textit{N} is the number of fields. The example in
figure \ref{figure:mql:make_example1} will produce the output seen in figure
\ref{figure:mql:make_example1_result}

\begin{figure}[!h]
\centering
\begin{Verbatim}
make(1,2,3)
\end{Verbatim}
\caption{Trivial MQL \texttt{make()} example}
\label{figure:mql:make_example1}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tabular}{|c | c | c |}
\hline
field0 & field1 & field2 \\ \hline
1 & 2 & 3 \\ \hline
\end{tabular}
\caption{Hypothetical result of query in figure
\ref{figure:mql:make_example1}}
\label{figure:mql:make_example1_result}
\end{figure}

A more complex example can be seen in \ref{figure:mql:make_example2}, where
field names are specified, and several tuples are synthesized. The
corresponding result is shown in figure \ref{figure:mql:make_example2_result}.

\begin{figure}[!h]
\centering
\begin{Verbatim}
make(name:=["A","B","C"], [1,4], [2,5] [3,6])
\end{Verbatim}
\caption{MQL \texttt{make()} example}
\label{figure:mql:make_example2}
\end{figure}

\begin{figure}[!h]
\centering
\begin{tabular}{|c | c | c |}
\hline
A & B & C \\ \hline
1 & 2 & 3 \\ \hline
4 & 5 & 6 \\ \hline
\end{tabular}
\caption{Hypothetical result of query in figure
\ref{figure:mql:make_example2}}
\label{figure:mql:make_example2_result}
\end{figure}


\begin{itemize}
  \item Lookup
  \item Scope
  \item Join\ldots tror vi m\aa~bruke hhjoin, lurer p\aa~om optimalisatoren velger merge hvis den kan?
  \item Project
  \item Select
  \item Index
  \item Make
  \item Etc..
\end{itemize}

\subsection{Assumed functionality}
\label{sect:method:marsAddedOperators}

TODO: skrive en liten innledning her om hvorfor vi assumer ting.

\subsubsection{isInScope (scope comparison)}
This function (not operator) accepts two arguments which must be scope fields
from index lookups (as described in section \ref{sect:method:mql:indexes}).
This boolean function returns \textit{true} if the first argument has an equal
but deeper path than the second argument, otherwise \textit{false}. This
function is designed to be used in conjunction with the \texttt{select()}
operator as a boolean predicate. See figure \ref{figure:mql:isinscope_example}
for an example of usage.

TODO: eksempelet er kanskje litt jalla.

\begin{figure}[!h]
\centering
\begin{Verbatim}
select(isInScope(lscope, rscope);
  mergejoin([DocumentID],[DocumentID], 
            [DocumentID, lscope = left.Scope, rscope = right.Scope];
    lookup(engineer),
    lookup(nurse)))
\end{Verbatim}
\caption{Example of assumed isInScope() functionality}
\label{figure:mql:isinscope_example}
\end{figure}

\subsubsection{xqBoolean/boolean truth value coercion}
This function (not operator) accepts one argument and determines its
\textit{truth value}. XQuery truth values were described in
section \ref{sect:theory:xquery:basics}.

\begin{figure}[!h]
\centering
\mbox{
\subfigure[Input for example in figure
\ref{figure:mql:xqboolean_example}]{
\begin{tabular}{|c | c | c |}
\hline
A & B & C \\ \hline
1 & 0 & 3 \\ \hline
4 & 5 & 6 \\ \hline
\end{tabular}
\label{figure:mql:xqboolean_example_input}
}
\quad
\subfigure[Output from example in figure
\ref{figure:mql:xqboolean_example}]{
\begin{tabular}{| c |}
\hline
truthVal \\ \hline
\textit{true} \\ \hline
\textit{false} \\ \hline
\end{tabular}
\label{figure:mql:xqboolean_example_output}
}
}
\end{figure}

\begin{figure}[!h]
\centering
\begin{Verbatim}
project(truthVal=xqBoolean(B); 
  make(name:=["A","B","C"], [1,4], [0,5] [3,6]))
\end{Verbatim}
\caption{Example of xqBoolean() usage}
\label{figure:mql:xqboolean_example}
\end{figure}


\subsubsection{numberate/sequence generator}
\subsubsection{Union/disjoint union}


hvilke operatorer/ funksjoner har vi lagt til / forutsatt?
\begin{itemize}
  	\item funksjonen \verb!isInScope(a, b)! if a has an equal but deeper path than
		b -> true (same element required) 
	\item isNumber(pred) -> fordi vi ikke har polymorphic type attributes\ldots typesystem igjen\ldots Skal vi
	g\aa~ut ifra at vi har polymorphic type attributes? Og si at type m\aa~bli ordna p\aa~en eller annen m\aa te..
	\item xqBoolean(pred) tom streng, null og teksten ``false''(p\aa~grunn av skrint typesystem) gir \textbf{false}
	\item scopeIndex(scope, pred)\ldots Trenger kanskje ikke allikevel\ldots Vet ikke enn\aa
	\item numberate(fieldName, [sortByList], [partiTionByList], operator) 
		\begin{itemize}
        	\item hadde v\ae rt flott om kolonnene i sortByList forsvant etterp\aa~.
        	\item g\aa r ikke det, m\aa~ vi gj\o re slik: project(fieldName = fieldNameAlt, ~sortByList,
        	numberate(fieldNameAlt, \ldots))
        \end{itemize}
	\item union
		\begin{itemize}
			  \item noe med schema\ldots virka ikke som thorbj\o rnsen var helt forn\o yd
				  med at v\aa r tenkte \texttt{union} dret i schema og helte p\aa~
				  \texttt{NULL} verdier indiscriminately
			\item This method assumes that the \texttt{union} operator accepts relations with
different schemas, and does not remove duplicates (disjoint union (hva skjer med markering av origin-relation?)).
The schema for the result relation can be described as:
\begin{equation*}
schema(\texttt{union(}\alpha, \beta\texttt{)}) = schema(\alpha) \cup
schema(\beta).
\end{equation*}
Provided this is a
unreasonable task to implement, it can be done manually by the translator with
the help of \texttt{project} operators.		
        \end{itemize}	
\end{itemize}
