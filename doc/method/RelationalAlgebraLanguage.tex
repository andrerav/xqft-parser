\section{Target Relational Algebra Language}
The target algebra for this project is a dialect of relational algebra
developed by FAST Search \& Transfer. This section will describe the operators
of this language as well as the indices they operate on, and will demonstrate some 
important traits of this language with a few examples.

\subsection{General concepts}
Hvordan skal man egentlig formulere seg her slik at Oystein ikke blir trist og
lei?

\subsection{Intexes and Resultsets}
\begin{itemize}
  \item hvilke indexer bruker vi..
  \item hvordan ser resultatsettene ut n\aa r vi sp\o r i disse indexene?
  \item Vi regner med at oppslag i valloc gir {documentId, pos, scope, value} (tror ikke den egentlig heter value,
  men heller navnet p\aa~scopet) og at scope holder inkludert seg selv -> alts\aa~at noe som: <a> hei </a> er
  lagret som {value = ``hei'', scope = a}. Hvis dette er umulig m\aa~vi forutsette en project for hver gang.. kan
  ikke la det feltet hete hva det vil\ldots\ldots\ldots
\end{itemize}


\subsection{Operatorz}
\label{sect:method:marsOperators}

\begin{itemize}
  \item Lookup
  \item Scope
  \item Mergejoin
  \item Project
  \item Select
  \item Index
  \item Etc..
\end{itemize}

\subsection{Assumed Other Mr functionality plz}
\label{sect:method:marsAddedOperators}
hvilke operatorer/ funksjoner har vi lagt til / forutsatt?
\begin{itemize}
  	\item funksjonen \verb!isInScope(a, b)! if a has an equal but deeper path than
		b -> true (same element required) 
	\item isNumber(pred), 
	\item xqBoolean(pred)
	\item scopeIndex(scope, pred)
	\item counter()
	\item numberate(fieldName, [sortByList], [partiTionByList], operator) 
		\begin{itemize}
        	\item hadde v\ae rt flott om kolonnene i sortByList forsvant etterp\aa~.
        	\item g\aa r ikke det, m\aa~ vi gj\o re slik: project(fieldName = fieldNameAlt, ~sortByList,
        	numberate(fieldNameAlt, \ldots))
        \end{itemize}
	\item union
		\begin{itemize}
			  \item noe med schema\ldots virka ikke som thorbj\o rnsen var helt forn\o yd
				  med at v\aa r tenkte \texttt{union} dret i schema og helte p\aa~
				  \texttt{NULL} verdier indiscriminately
			\item This method assumes that the \texttt{union} operator accepts relations with
different schemas, and does not remove duplicates (disjoint union (hva skjer med markering av origin-relation?)).
The schema for the result relation can be described as:
\begin{equation*}
schema(\texttt{union(}\alpha, \beta\texttt{)}) = schema(\alpha) \cup
schema(\beta).
\end{equation*}
Provided this is a
unreasonable task to implement, it can be done manually by the translator with
the help of \texttt{project} operators.		
        \end{itemize}	
\end{itemize}
