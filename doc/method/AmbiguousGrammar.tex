\section{Ambiguous Terminals}
\label{sect:ambiguousgrammar:ambigTerm}
The W3C EBNF specification of XQuery Full Text\cite{w3c01} defines among other these terminals (somewhat simplified):
\begin{verbatim}
ElementContentChar       ::= Char - [{}<&]
QuotAttrContentChar      ::= Char - ["{}<&]
AposAttrContentChar      ::= Char - ['{}<&]
IntegerLiteral           ::= Digits
NCName                   ::= NCNameStartChar NCNameChar*
NCNameChar               ::= Letter | Digit | '.' | '-' | '_'
NCNameStartChar          ::= Letter | '_'
\end{verbatim}
Where \verb!Char! denotes all possible legal characters in XQuery, \verb!Digits! is all possible number characters and \verb!Letter! denotes all possible letter characters. In their specification, the W3C uses a dash operator, which has the following
semantic meaning in a grammar (\cite{w3c03}, section 6):
\begin{quote}
A - B: matches any string that matches A but does not match B.
\end{quote}
In addition, the specification contains explicit defined literals and symbols such as \verb!'for'! and \verb!'::'!, aswell as \verb!StringLitteral! which is indeed comparable with the non-terminal \verb!DirAttributeList! (credit to the eXist\cite{exist_doc}~implementation for making us aware of this ambiguity) as shown here (simplified):
\begin{verbatim}
DirAttributeValue        ::= ('"' (QuotAttrContentChar)* '"')
                           | ("'" (AposAttrContentChar)* "'")
StringLiteral            ::= ('"' ([^"&])* '"') 
                           | ("'" ([^'&])* "'")
\end{verbatim}
Where \verb!QuotAttrContentChar! and \verb!AposAttrContentChar! is as defined earlier, and the hat operator (\verb!^!) is defined as follows(\cite{w3c03}, section 6):
\begin{quote}
[\^{}abc] matches any Char with a value not among the characters given.
\end{quote}
Meaning that e.g. \verb![^"&]! equals \verb!Char - ["&]!. It is easy to see that the characters that can be matched by these productions would overlap significantly, thus the lexer must be aware of the context of a incomming symbol to differanciate between the rules. We considered several alternatives for solving this, as discussed in the following sections.

\subsection{Scan-While-Parse scanner}
\label{sect:ambiguousgrammar:scanWhileParse}
With a scan-while-parse stragegy the parser would evaluate the character stream into tokens, while at the same time branching to the respective hierarchical context. This means essentialy that there would be no lexer (it would only return one and one character), only a huge parser. Such a parser would be very complex, and most likely slow, too.

\subsection{Fuzzy Token Lexer}
A fuzzy token lexer is typicaly a simple lexer which leaves the meaning of the tokens somewhat ambiguous. Such a lexer may e.g. have a production \verb!Letters! which bundles all consecutive letter characters into tokens. The tokens would then be refined to their appropriate type during the context sensitive parsing process. Problems would occur, though, if e.g. the parser encounters a \verb!Letters! token but is expecting a token consisting of both letters, numbers and other symbols. The parser would then need to do the comlicated task of splitting and merging such tokens.

\subsection{State Driven Lexer}
\label{sect:amiguousgrammar:stateDriven}
With this method the lexer would only sets of words when in an appropriate state. The acceptance of a word in one state may lead to a state transition. I.e. the lexical recognition would be implemented as transition tables for a push-down automata. A suggestion for such transition tables for XQuery (not Full Text) are published as W3C working draft\cite{createTokenizer} with the following disclaimer:
\begin{quote}
The following tables were hand-constructed and have not, at the time of this writing, been exhaustively verified against all possible paths that may be legal in the XQuery and XPath EBNFs, which is to say, it is possible they contain bugs.
\end{quote}
We made a prototype of a state driven lexer for a subset of XQuery, leading us to the conclusion that it would be a cumbersome task to implement for a the full XQuery Full Text grammar.

\subsection{Island Grammars}
\label{sect:amiguousgrammar:islandGrammar}
Island grammars \cite{islandGrammar} is a strategy where ambiguous parts of a grammar can be taken out of the main section and turned into its own subgrammar. This will lead to a case where the system will consist of more than one lexer. The parser would then, in the power of being aware of the context, switch between the lexers when necessary. Communication between the lexers is a must, as they need to know where to start scanning in the input stream. ANTLR does not support island grammars by default, allthough there is thoughs about implementing it in future versions \footnote{http://www.antlr.org/wiki/display/ANTLR3/island+grammar+formalization}, but can be implemented through various tweaks and "hacks". We went away from this idea, because of the more intuitive strategy of the parser controlled state driven lexer.

\subsection{Parser Controlled State Driven Lexer}
\label{sect:amiguousgrammar:parserControlled}
When working with the prototype of the state driven lexer, we discovered that we would not need more than maybe four or five states to differenciate between the ambiguous terminals. A possible solution would then be to transform the transition tables in \cite{createTokenizer} to a system with a lot fewer states aswell as adding state transitions for the tokens added in the full text version of XQuery. But a more comprehensible solution would be to let the parser be responsible for the state transitions. By blocking off or promoting some productions with the help of gated semantic predicates or disambiguating semantic predicates, respectably, depending on which state it is in, the lexer would be able to pick the right alternative. We choose this strategy mainly because its intuitive and easier to implement compared to the other alternatives. A more thorough review of our implementation of the parser controlled state driven lexer is found in the implementation chapter.
