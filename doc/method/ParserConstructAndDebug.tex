\section{Parser construction}
Writing a parser from scratch was ruled out early for being too time consuming.
Instead it was decided to use tools for compiler and parser construction to
generate a parser from the XQuery 1.0 and XPath 2.0 grammar  
specifications\cite{w3c01} developed by the W3C.

Some important requirements were taken into account when evaluating these
alternatives. Specifically, the generator must:
\begin{itemize}
  \item generate Java source code for the parser
  \item be able to generate an LL(1) (or LL(k)) parser, because the grammar  
  specification is given by W3C in LL(k)
  \item be licensed liberally, either GPL or BSD, or an equivalent license
  approved by OSI
\end{itemize}

\subsection{Evaluated alternatives}
\label{sect:method:alternatives}
\subsubsection{JFlex/CUP}
JFlex and CUP is a versatile combination consisting of JFlex which is a lexer
generator, and CUP which is a parser generator. These tools can be interfaced to
generate a complete parser with a separate lexical analyzer.

JFlex and CUP produces only LALR parsers, and since the W3C has specified an
LL(1) grammar for XQuery 1.0 and XPath 2.0, the combination of JFlex and CUP was
rejected from this project. Additionally, some basic occurence operators such as
*,+ and ? is not supported by CUP.

In the light of this decision, it is important to note that a large amount of
work can be avoided by rejecting a LALR parser generator solution for this
project. Consider the examples in figure \ref{code:parsers:lalr} and
\ref{code:parsers:ll} and compare it to the reference grammar specification in
figure \ref{code:parsers:w3c}.

\begin{figure}[h!]
\begin{verbatim}
LetClause : "let $" LetBindings_
LetBindings_ : VarName OptTypeDeclaration_ ":=" ExprSingle
        | VarName OptTypeDeclaration_ ":=" ExprSingle
        "," "$" LetBindings_
\end{verbatim}
\caption[LALR grammar example]{LALR grammar example from the Pathfinder project
(see section \ref{sect:soa:pathfinder})}
\label{code:parsers:lalr}
\end{figure}

\begin{figure}[h!]
\begin{verbatim}
letClause : LET varBinding (COMMA varBinding)*

varBinding : (DOLLAR varName typeDeclaration? | 
             SCORE DOLLAR varName )
             ASSIGN exprSingle
\end{verbatim}
\caption[LL grammar example]{LL grammar example, actual code used in this project}
\label{code:parsers:ll}
\end{figure}

\begin{figure}[h!]
\begin{verbatim}
LetClause ::=  (("let" "$" VarName TypeDeclaration?) 
 				| ("let" "score" "$"  VarName)) ":=" ExprSingle ("," 
 				(("$" VarName TypeDeclaration?) 
 				| FTScoreVar) ":=" ExprSingle)*
\end{verbatim}
\caption{ W3C reference grammar example }
\label{code:parsers:w3c}
\end{figure}

Obviously, the LALR-grammar has suffered an extensive rewrite into a recursive
rule to compensate for the lack of support for occurence indicators. The LL
example stands out as clear and readable, even more so than the W3C
grammar specification.

In the case of JFlex/CUP, building abstract syntax trees is a process that must
be done manually by adding action code snippets to the grammar. This is
unfortunate for several reasons - it dilutes the grammar and decreases
readability and clarity.


\subsubsection{JavaCC}
JavaCC could have been a viable alternative as it produces LL(k) parsers,
however compared to Antlr its grammar specification syntax deviated more
from the W3C EBNF syntax, meaning that the grammar would have had to be
extensively rewritten. However, JavaCC supports the same occurence indicators
used in the XQuery grammar specification. Figure \ref{code:parsers:javacc} shows
a grammar fragment translated to JavaCC syntax, compare to the original grammar
in figure \ref{code:parsers:w3c}.

\begin{figure}[h!]
\begin{verbatim}
void letClause() :
{ }
{
    <LET> varBinding() (COMMA varBinding())*
} 

void varBinding()
{ }
{
    (<DOLLAR> varName() typeDeclaration()? | 
     <SCORE> <DOLLAR> varName() )
     <ASSIGN> exprSingle()
}
\end{verbatim}
\caption{ JavaCC reference grammar example }
\label{code:parsers:javacc}
\end{figure}

For AST construction, JavaCC requires the use of preprocessor tool known as  
JJTree. This tool will parse the grammar and insert tree building actions where
appropriate. 

\subsubsection{ANTLR}
ANTLR is a renowned tool for parser generation, and can generate LL(*) parsers.
Additionally, ANTLR accepts a grammar specification syntactically very close to
the EBNF used by the W3C. This is the parser generater chosen for our project,
based on the criteria outlined in this section.

The details of this parser generator is outlined in chapter \ref{sect:antlr}.

\section{Debugging}
\label{sect:method:debugging}
There are several approaches to debugging. ANTLRWorks \cite{antlrwrks00} is a
simple tool for writing, testing and debugging Antlr grammars. The debugging
interface is useful in that it draws a realtime step-by-step parse tree as the
input is being parsed, as well as displaying a list of parser events.
ANTLRWorks also helps eliminate grammar nondeterminisms by drawing the syntax
diagram associated with a grammar and highlighting nondeterministic paths. A
big drawback, though, is as the grammar grows bigger, the application tends to
become unstable.    

When working properly, ANTLRWorks is a great tool for debuging the parser, but
no so much for the lexer. It will show the tokens returned to the parser, but
no information or decision path indicating the reason for returning just that
token. A more appropriate tool for such a task would be the standard debuging
environment in Eclipse (\cite{eclipse}).    
