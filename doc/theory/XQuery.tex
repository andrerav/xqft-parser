\section{XQuery}
\label{sect:theory:xquery}

XQuery is a query language developed by the XML Query working group of W3C.
Version 1.0\cite{w3c00} became a W3C Recommendation January 2007. It was designed as a
response to an emerging task: to intelligently express queries in theincreasing
amounts of information stored, exchanged and presented using XML. The language
is derived from Quilt\cite{quilt_queryLanguage}.


\begin{itemize}
\item itroduksjon
\item historie
\item bruksomr\aa der
\item ...
\end{itemize}

\subsection{Basics}
\label{sect:theory:basics}
\begin{itemize}
  \item sekvenser og ting atomisk, alt je sekvenser er endimensjonale\ldots
  \item andre ting som er basisk og ikke surt
  \item context item '.'
\end{itemize}

\subsection{Path Expressions}
\label{sect:theory:xqueryPathExpressions}
\begin{itemize}
\item fra XPath / brukt i mange andre ting (XSLT yeye)
\item ...
\item akser -> [Definition: The following axes are designated as optional axes:
ancestor, ancestor-or-self, following, following-sibling, preceding, and
preceding-sibling.] (http://www.w3.org/TR/xquery/\#dt-optional-axis)
\item semantikk 
\item eksikveringsorden etc
\end{itemize}

\subsection{Predicates}
\label{sect:theory:xqueryPredicates}
\begin{itemize}
  \item predikater kan brukes etter b\aa de stepExprz og filterExprz
  \item de gj\o r egentlig ikke noe annet enn \aa~ begrense hva som er i settet
  f\o r (og alt er jo sett)
  \item unntaket er talltingen.. som sikkert er en forkortelse for
  plzReturnTheNumberInTheSequenceIamInRightNow() ellerno.. har ikke lest
  tingen: http://www.w3.org/TR/xquery/\#id-predicates
\end{itemize}

\subsection{FLWOR}

\begin{itemize}
\item motiv
\item ...
\item F L W O R semantikk
\item \^{} --- eksikveringsorden etc
\item scoping, hvilke variable er i hvilke scopes (for \$i in \$i..)
\end{itemize}

\subsection{Binary Operators}

\begin{itemize}
\item motiv
\item ...
\item semantikk
\item hva er sant, hva er usant?
\end{itemize}

\subsection{Types}
\begin{itemize}
  \item skrive om dette ogs\aa~selv om vi ikke skal implementere?
  \item har planer om \aa~diskutere det litt i diskusjonskap iallefall..
\end{itemize}

\subsection{Evt andre ting fra XQuery vi kommer til \aa~implementere}

\begin{itemize}
\item if then else

\end{itemize}

\subsection{Full Text Extensions}

\begin{itemize}
\item motiv
\item ...
\item semantikk
\item hva har man? ftcontains er kilden...
\end{itemize}

\subsection{XQuery core}
\begin{itemize}
  \item Hva er xquery core?
  \item Hva er poenget med XQuery core?
  \item Normaliseringsprosessen (hva blir til hva)
\end{itemize}

XQuery Core is a less powerful but semantically equivalent form of expressing
XQuery queries. XQuery Core as well as the process of normalizing regular
XQuery to XQuery Core is described in the document ``XQuery 1.0 and XPath 2.0
Formal Semantics''\cite{xquery_semantics}.

The goal of XQuery Core is to simplify queries and remove syntactic sugar,
leaving only the essential semantics without loss of expressiveness.
This is useful for optimization routines and translations into new types of
queries, for example relational algebra or SQL.

The process of normalization is described through a rich set of mapping
rules. These are documented in detail throughout ``XQuery 1.0 and XPath 2.0
Formal Semantics''\cite{xquery_semantics} and will not be reiterated here.
However we will examine some important examples.

First, however, it is important to take note of the syntax of the mapping
rules, as described in \cite{xquery_semantics}, section 3.2.2. 
 
\begin{figure}[!h]
  \centering
$
[Object]_{Subscript}, premises == Mapped Object
$
  \caption{Mapping rules syntax}
  \label{figure:xquery:mapping_rules}
\end{figure}

Consider figure \ref{figure:xquery:mapping_rules}. The left-hand side of the
equality symbol (==) denotes the original object to be rewritten. The
subscript indicates the type or kind of the object to be mapped, and/or
additional information to be passed between mapping rules. The right-hand side
denotes the rewritten object.

\subsubsection{Rewriting FLWOR expressions}

\begin{figure}[!h]
\centering
[for $\$VarName_1$ $OptTypeDeclaration_1$ $OptPositionalVar_1$ in $Expr_1$,
\ldots, $\$VarName_n$ $OptTypeDeclaration_n$ $OptPositionalVar_n$ in $Expr_n$
$FormalReturnClause]_{Expr}$ \newline
$==$ \newline
for $\$VarName_1$ $OptTypeDeclaration_1$
$OptPositionalVar_1$ in $[Expr_1]_{Expr}$ return \ldots for $\$VarName_n$
$OptTypeDeclaration_n$ $OptPositionalVar_n$ in $[Expr_n]_{Expr}$ return
$[FormalReturnClause]_{Expr}$
  \caption{FLWOR expression mapping rule}
  \label{figure:xquery:flwor_mapping_rule}
\end{figure}

The mapping rule for FLWOR forclause-expressions can be seen in figure
\ref{figure:xquery:flwor_mapping_rule}. The mapping rule for LET expressions is
similar and omitted from this document for brevity, however they are also
normalized into several nested bindings.

\begin{figure}[!h]
\centering
$[where Expr_1 FormalReturnClause]_Expr$ \newline
$==$ \newline
$if ([Expr_1]_Expr ) then [FormalReturnClause]_Expr else ()$
  \caption{Where-clause mapping rule}
  \label{figure:xquery:where_mapping_rule}
\end{figure}

\begin{figure}[!h]
\centering
$[stable? order by OrderSpecList FormalReturnClause]_Expr$ \newline
$==$ \newline
$[OrderSpecList]_OrderSpecList return [FormalReturnClause]_Expr$
  \caption{Order by clause mapping rule}
  \label{figure:xquery:orderby_mapping_rule}
\end{figure}

\begin{figure}[!h]
\centering
$[return Expr]_Expr$ \newline
$==$ \newline
$[Expr]_Expr$
  \caption{Return clause mapping rule}
  \label{figure:xquery:return_mapping_rule}
\end{figure}

Similarly, the mapping rules for where-clauses, orderby-clauses and
return-clauses can be seen in figures \ref{figure:xquery:where_mapping_rule},
\ref{figure:xquery:orderby_mapping_rule},
and \ref{figure:xquery:return_mapping_rule}.

The W3C formal specification document provides one example of a FLWOR rewrite
using these mapping rules. Consider the following FLWOR expression:
\begin{verbatim}
  for $i as xs:integer in (1, 2),
      $j in (3, 4)
  let $k := $i + $j
  where $k >= 5
  return
    <tuple>
       <i> { $i } </i>
       <j> { $j } </j>
    </tuple>
\end{verbatim}

By applying the mapping rules described,  this expression is typically
rewritten to:
\begin{verbatim}
  for $i as xs:integer in (1, 2) return
    for $j in (3, 4) return
      let $k := $i + $j return
        if ($k >= 5) then 
          <tuple>
            <i> { $i } </i>
            <j> { $j } </j>
          </tuple>
        else
          ()
\end{verbatim}

In particular, note that multiple for-clauses in a FLWOR expression is
rewritten into several nested FLWOR expressions, and that the where-clause is
rewritten into an if-then-else expression.

\subsubsection{Rewriting path expressions}
\subsection{AllMatches}
\label{sect:theory:xquery:allmatches}
\begin{itemize}
  \item http://www.w3.org/TR/xpath-full-text-10/\#AllMatchesSec
  \item Hva er AllMatches?
  \item Kobling til fulltekst
  \item Noen eksempler
  \item Den store forskjellen med AllMatches er at den minste enheten i et 
        dokument er et ord og ikke en tekstnode
\end{itemize}
TODO: Ikke sikkert at dette er noe poeng aa skrive om hvis vi bare ignorerer
fulltekst uansett. Kunne foreslaatt en tilnarming ala galatex kanskje, som bare
oversetter greiene til funksjonskall.
