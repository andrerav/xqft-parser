\chapter{Discussion}
We decided to start this project because parser construction is an interesting
subject, and because the outcome, if successfull, would have real world
applicability. The rationale for writing a new parser instead of using an
existing one is simple - as shown in section \ref{sect:theory:stateoftheart},
current full-text implementations are tightly coupled with their
host environment and unsuitable for integration with new backends, limited by
restrictive licenses, or simply available only in platform-dependent binaries
(as opposed to Java). 

In this chapter, we will discuss the outcome of this project and reflect over
our decisions. We will present and evaluate alternative decisions, and what
might have come of them. We will also discuss problems, how they were
solved, and attempt to reflect over how these problems could have been solved
differently.

 \underline{\textbf{\LARGE //TODO:}} tekst her... innledning

Hvorfor skrive en parser i det heletatt, hvorfor ikke bare bruke en
eksisterende. Fordi det er oppgaven, hva med lisens? Hvorfor valgte vi denne
oppgaven, og ikke den andre...? Sette seg inn i kode tar masse tid, lager vi
selv har vi mer oversikt...

Mads: legg til noe fett e.l
\underline{\textbf{\LARGE //ODOT:}}

husk generelt: Gjorde vi riktige valg? Ble ting som forventet? Hva hadde skjedd
om vi brukte annet alternativ etc.. 

\input{discussion/DesignDecisions}

\input{discussion/AdaptW3C}

\input{discussion/ANTLR}

\input{discussion/W3CUnconformities}

\input{discussion/AST}

\input{discussion/ErrorHandling}

\input{discussion/ScopingAndSymbol}

\input{discussion/DeadEnds}

\section{Lookahead}
\underline{\textbf{\LARGE //TODO:}}

The W3C claims their XQuery specification is expressed as a LL(1)-grammar\cite{createTokenizer}, as in the simplest cases can be seen with bare eyes, and also noted by \cite{kang_xquery_diglib}, this is not true. Because we chose the parser controlled strategy, our system's correctness depends on that the parser is a LL(k) parser with a small k.

\section{NCNames and Reserved Keywords}
\underline{\textbf{\LARGE //TODO:}}
\begin{verbatim}
typeswitch($c) 
      case $e as element() return local:copy($a)
      case $t as text() return $t
      case $c as comment() return $c ftcontains "host" case sensitive
      case sensitiv:fg return $p
      default return ()
\end{verbatim}


kanskje jeg skal ha noe her ogs\aa .


\section{Covrage Test Results}
\label{sect:discussion:coverageResults}
\underline{\textbf{\LARGE //TODO:}} Ikke skrevet enn\aa~ i p\aa vente av bedre resultater i l\o pet av helga..
\begin{itemize}
\item Testresultater, bra/d\aa rlig
\item testresultater (hva var de forskjellige feilene)
\item Generelt resultater vi skrev om i forrige kapittel
\item Resultatene maa sees relativt - vi har ikke faatt testet hele settet siden
vi ikke kan kjore run-time tester, og vi returnerer heller ikke noe som kan
sammenlignes med forventet resultat
\end{itemize}

W3C Unconformities delen forklarer egentlig testresultatet.

Covrage er ikke h\o yere mest sannsynlig p\aa~grunn av vi har reserved keywords, og noen ganger ser parseren for langt frem... skal se om jeg f\aa~r fiksa noe av dette til helga, sp\o rs p\aa~ hvor lang vi har kommet med rapporten.... Covrage testene er eXtremt bra til \aa~finne bugz.

\underline{\textbf{\LARGE //ODOT:}}