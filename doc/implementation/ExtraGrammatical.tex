\section{Extra-grammatical Constraints}
\label{sect:implementation:extraGrammatical}
As well as the grammatical constraints specified in the EBNF grammar, W3C also specifies some extra-grammatical constrains and grammar notes in \cite{w3c00}. In this section we will present these constraints and how we accommodated for them. 

\subsection{Occurrence Indicators}
\label{sect:implementation:occurence}

The W3C grammar specifies the non-terminal \verb!SequenceType! as follows:
\begin{Verbatim}
SequenceType ::= ("empty-sequence" "(" ")")
               | (ItemType OccurrenceIndicator?)
\end{Verbatim}
It also specifies this extra-gramatical constraint (\cite{w3c00}, section A.1.2):
\begin{quote}
As written, the grammar in A XQuery Grammar is ambiguous for some forms using the '+' and '*' Kleene operators. The ambiguity is resolved as follows: [\ldots] Any occurrence of '+' and '*', as well as '?', following a sequence type is assumed to be an occurrence indicator. That is, a "+", "*", or "?" immediately following an ItemType must be an OccurrenceIndicator\ldots
\end{quote}

This is a clasical case for a syntactic predicate (section \ref{sect:antlr:syntacticPredicate}), which can force the parser to consider a something that looks like a \verb!OccurrenceIndicator! as a \verb!OccurenceIndicator! and not e.g. a arithmetic operator. The implementation of which can be seen in figure \ref{fig:occurrenceIndicator}. The alternative with \verb!ItemType! had to be split into two more alternatives to rank the one with with the \verb!OccurenceIndicator! over the one without.

\begin{figure}[h!]
\begin{Verbatim}
sequenceType : (itemType occurrenceIndicator)=> 
               itemType occurrenceIndicator
             | itemType
             | EMPTY_SEQUENCE LPARSi RPARSi
             ;
\end{Verbatim}
\caption[The \texttt{OccurenceIndicator} ambiguity solved]{The \texttt{OccurenceIndicator} ambiguity solved by means of a syntactic predicate}
\label{fig:occurrenceIndicator}
\end{figure}

\subsection{Leading Lone Slash}
The constraint is expressed as follows (\cite{w3c00}, section A.1.2):
\begin{quote}
A single slash may appear either as a complete path expression or as the first part of a path expression in which it is followed by a RelativePathExpr, which can take the form of a NameTest ("*" or a QName). In contexts where operators like "*", "union", etc., can occur, parsers may have difficulty distinguishing operators from NameTests. [\ldots] If the token immediately following a slash is "*" or a keyword, then the slash must be the beginning, but not the entirety, of a PathExpr\ldots
\end{quote}

W3Cs \verb!PathExpr! is expressed like this:
\begin{Verbatim}
PathExpr  ::= ("/" RelativePathExpr?)
            | ("//" RelativePathExpr)
            | RelativePathExpr
\end{Verbatim}

As with the \verb!occurenceIndicator! we split the alternative with the $?$-kleene operator into two explicit alternatives. And by using a syntactic predicate, the parser will prefer the alternative with the \verb!RelativePathExpr! over the single slash one, as seen in figure \ref{fig:leadingSlash}.
\begin{figure}[h!]
\begin{Verbatim}
pathExpr    : (SLASHSi relativePathExpr)=> 
              SLASHSi relativePathExpr
            | SLASHSi
            | DBLSLASHSi relativePathExpr
            | relativePathExpr
            ;
\end{Verbatim}
\caption[The \texttt{PathExpr} ambiguity solved]{The \texttt{PathExpr} ambiguity solved by means of a syntactic predicate}
\label{fig:leadingSlash}
\end{figure}

\subsection{Reserved Function Names}
\label{sect:implementation:reservedFunctionNames}
W3C specifies the constraint like this (\cite{w3c00}, section A.1.2):
\begin{quote}
Unprefixed function names spelled the same way as language keywords could make the language harder to recognize. For instance, if(foo) could be taken either as a FunctionCall or as the beginning of an IfExpr. Therefore it is not legal syntax for a user to invoke functions with unprefixed names which match any of the names in [\cite{w3c00}, section] A.3 Reserved Function Names.
\end{quote}

Where "A.3 Reserved Function Names" lists a number of names such as \verb!if!, \verb!text! and \verb!node! (thirteen in total). As mentioned in \ref{sect:impl:reserved_keywords} this restriction is provided to solve some non-detererminisms arising from the fact that XQuery does not have reserved keywords. The start of a function call is written as the function name followed by a \verb!(!, and the reserved function names appear in the leftmost position followed by a \verb!(! in each of their own productions. The amiguity is that in some non-terminals these productions are alternatives to the function call rule.

The problem is solved by means of syntactic predicates, example of which can be seen in figure \ref{fig:reservedFunction}. These are not employed to block a function call from containing these words, as such, but rather to force the parser to choose the alternative production when confronted with the ambiguity. This is sufficient as the parser has no way to match a function call production without facing all the alternatives.

\begin{figure}[h!]
\begin{Verbatim}
stepExpr       : (TEXT | NODE | ...) LPARSi)=> 
                 axisStep
               | axisStep
               | filterExpr
               ;
axisStep       : #productions# ... |...
               | ...
filterExpr     : primaryExpr...;
primaryExpr    : ...
               | {input.LA(1)!=ITEM}?=>
                 functionCall
               ;
#procuctions#  : textTest
               | anyKindTest
               | ...
textTest       : TEXT LPARSi ...;
anyKindTest    : NODE LPARSi ...;
\end{Verbatim}
\caption[Reserved function names diverted by syntactic predicates]{An example of forcing the parser to choose alternative production when faced with a reserved function name token. \texttt{#productions#} denotes a series of productions which all are on the leftmost end consecutively.}
\label{fig:reservedFunction}
\end{figure}

The word \verb!item! is also on the list of reserved function names, but are not part of any ambiguity with function call. We belive that this may be a remainder of some earlier XQuery spesification, but have with a gated semantic predicate, to be in compliance with the constraint, blocked the word from being a function name.

\subsection{Whitespace Explicit}
\label{sect:implementation:whitespace}
In the grammar specification some productions is marked with \verb!ws: explicit!, which have the following explanation (\cite{w3c00}, section A.2.4):
\begin{quote}
/* ws: explicit */ means that the EBNF notation explicitly notates, with S or otherwise, where whitespace characters are allowed. [\ldots] Comments are also not allowed in these productions.
\end{quote} 

The productions with this constraint are mainly those associated with XML markup and those we have turned into lexer rules (section \ref{sect:rewriteGrammar:enclosedComposite}). In the case of the enclosed composite rules we have explicitly specified where whitespace is allowed, as can be seen from the referring of \verb!S! in the \verb!DirPIConstructor! in figure \ref{fig:pragmaLEX}. And because these are defined as terminals they cannot contain comments (which is also terminals).

In the case of the XML markup rules we blocked these from containing whitespace and by not allowing in the states the lexer must be in to process these terminals. However, we have allowed default whitespace handling in the \verb!IN_TAG! state for the sake of simplicity, which leads to the bug of allowing space in the start of a tag. This is reported in section \ref{sect:future:knownBugs}.

\subsection{XML Version}
\label{sect:implementation:xmlVersion}
This constraint is specified as follows (\cite{w3c00}, section A.1.2):
\begin{quote}
An implementation's choice to support the XML 1.0 and XML Names, or XML 1.1 and XML Names 1.1 lexical specification determines the external document from which to obtain the definition for this production[s].[\ldots] Also please note that these external productions follow the whitespace rules of their respective specifications, and not the rules of this specification,
\end{quote}

The productions refered to of interest in our case is \verb!NCName! and \verb!Char!. For both of these we have employed the 1.0 specification, as this is the one in most widespread use. However, at this date our parser yet allows inpropper nesting of tags. This violation of the constraint have a quite easy fix and are reported in section \ref{sect:future:knownBugs}.

\subsection{Multiple Match Options}
\label{sect:implementation:multipleMatchOptions}
Which is by W3C specified as follows (\cite{w3c00}, section A.1.2):
\begin{quote}
No single alternative for FTMatchOption can be specified more than once as part of the same FTMatchOptions. For example, if the FTCaseOption "lowercase" is specified, then "uppercase" cannot also be specified as part of the same FTMatchOptions.
\end{quote}

As of yet, our parser does not accomodate this constraint, as reported in section \ref{sect:future:knownBugs}.

